{"version":3,"file":"index-ZgMUSvkK.js","sources":["../../node_modules/.pnpm/essentia.js@0.1.3/node_modules/essentia.js/dist/essentia.js-core.es.js","../../src/audio/audioManager.js","../../src/utils/drumConfig.js","../../src/components/DrumVisualizer.js","../../src/components/NotationBuilder.js","../../src/components/LayoutBuilder.js","../../src/main.js"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright (C) 2006-2020  Music Technology Group - Universitat Pompeu Fabra\r\n *\r\n * This file is part of Essentia\r\n *\r\n * Essentia is free software: you can redistribute it and/or modify it under\r\n * the terms of the GNU Affero General Public License as published by the Free\r\n * Software Foundation (FSF), either version 3 of the License, or (at your\r\n * option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT\r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\r\n * details.\r\n *\r\n * You should have received a copy of the Affero GNU General Public License\r\n * version 3 along with this program.  If not, see http://www.gnu.org/licenses/\r\n */\r\n// NOTE: The following code snippets are machine generated. Do not edit.\r\n/**\r\n * essentia.js-core JS API\r\n * @class\r\n * @example\r\n * const essentia = new Essentia(EssentiaWASM);\r\n */\r\nvar Essentia = /** @class */ (function () {\r\n    /**\r\n    * @constructs\r\n    * @param {EssentiaWASM} Essentia WASM backend (emcripten global module object) which is loaded from 'essentia-wasm.*.js file'\r\n    * @param {boolean} [isDebug=false]\r\n    */\r\n    function Essentia(EssentiaWASM, isDebug) {\r\n        if (isDebug === void 0) { isDebug = false; }\r\n        this.EssentiaWASM = EssentiaWASM;\r\n        this.isDebug = isDebug;\r\n        this.algorithms = new EssentiaWASM.EssentiaJS(isDebug);\r\n        this.module = EssentiaWASM;\r\n        this.version = this.algorithms.version;\r\n        this.algorithmNames = this.algorithms.algorithmNames;\r\n    }\r\n    /**\r\n     * Decode and returns the audio buffer of a given audio url or blob uri using Web Audio API.\r\n     * (NOTE: This method doesn't works on Safari browser)\r\n     * @async\r\n     * @method\r\n     * @param {string} audioURL web url or blob uri of a audio file\r\n     * @param {AudioContext} webAudioCtx an instance of Web Audio API `AudioContext`\r\n     * @returns {AudioBuffer} decoded audio buffer object\r\n     * @memberof Essentia\r\n     */\r\n    Essentia.prototype.getAudioBufferFromURL = function (audioURL, webAudioCtx) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var response, arrayBuffer, audioBuffer;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, fetch(audioURL)];\r\n                    case 1:\r\n                        response = _a.sent();\r\n                        return [4 /*yield*/, response.arrayBuffer()];\r\n                    case 2:\r\n                        arrayBuffer = _a.sent();\r\n                        return [4 /*yield*/, webAudioCtx.decodeAudioData(arrayBuffer)];\r\n                    case 3:\r\n                        audioBuffer = _a.sent();\r\n                        return [2 /*return*/, audioBuffer];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Decode and returns the audio channel data from an given audio url or blob uri using Web Audio API.\r\n     * (NOTE: This method doesn't works on Safari browser)\r\n     * @async\r\n     * @method\r\n     * @param {string} audioURL web url or blob uri of a audio file\r\n     * @param {AudioContext} webAudioCtx an instance of Web Audio API `AudioContext`\r\n     * @param {number} [channel=0] audio channel number\r\n     * @returns {Float32Array} decode and returns the audio data as Float32 array for the given channel\r\n     * @memberof Essentia\r\n     */\r\n    Essentia.prototype.getAudioChannelDataFromURL = function (audioURL, webAudioCtx, channel) {\r\n        if (channel === void 0) { channel = 0; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var response, arrayBuffer, audioBuffer;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, fetch(audioURL)];\r\n                    case 1:\r\n                        response = _a.sent();\r\n                        return [4 /*yield*/, response.arrayBuffer()];\r\n                    case 2:\r\n                        arrayBuffer = _a.sent();\r\n                        return [4 /*yield*/, webAudioCtx.decodeAudioData(arrayBuffer)];\r\n                    case 3:\r\n                        audioBuffer = _a.sent();\r\n                        return [2 /*return*/, audioBuffer.getChannelData(channel)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Convert an AudioBuffer object to a Mono audio signal array. The audio signal is downmixed\r\n     * to mono using essentia `MonoMixer` algorithm if the audio buffer has 2 channels of audio.\r\n     * Throws an expection if the input AudioBuffer object has more than 2 channels of audio.\r\n     * @method\r\n     * @param {AudioBuffer} buffer `AudioBuffer` object decoded from an audio file.\r\n     * @returns {Float32Array} audio channel data. (downmixed to mono if its stereo signal).\r\n     * @memberof Essentia\r\n     */\r\n    Essentia.prototype.audioBufferToMonoSignal = function (buffer) {\r\n        if (buffer.numberOfChannels === 1) {\r\n            return buffer.getChannelData(0);\r\n        }\r\n        if (buffer.numberOfChannels === 2) {\r\n            var left = this.arrayToVector(buffer.getChannelData(0));\r\n            var right = this.arrayToVector(buffer.getChannelData(1));\r\n            var monoSignal = this.MonoMixer(left, right).audio;\r\n            return this.vectorToArray(monoSignal);\r\n        }\r\n        throw new Error('Unexpected number of channels found in audio buffer. Only accepts mono or stereo audio buffers.');\r\n    };\r\n    /**\r\n     * Method to shutdown essentia algorithm instance after it's use\r\n     * @method\r\n     * @memberof Essentia\r\n     */\r\n    Essentia.prototype.shutdown = function () {\r\n        this.algorithms.shutdown();\r\n    };\r\n    /**\r\n     * Method for re-instantiating essentia algorithms instance after using the shutdown method\r\n     * @method\r\n     * @memberof Essentia\r\n     */\r\n    Essentia.prototype.reinstantiate = function () {\r\n        this.algorithms = new this.module.EssentiaJS(this.isDebug);\r\n    };\r\n    /**\r\n     * Delete essentiajs class instance\r\n     * @method\r\n     * @memberof Essentia\r\n     */\r\n    Essentia.prototype.delete = function () {\r\n        this.algorithms.delete();\r\n    };\r\n    /**\r\n     * Convert an input JS array into VectorFloat type\r\n     * @method\r\n     * @param {Float32Array} inputArray input JS typed array\r\n     * @returns {VectorFloat} returns vector float\r\n     * @memberof Essentia\r\n     */\r\n    Essentia.prototype.arrayToVector = function (inputArray) {\r\n        return this.module.arrayToVector(inputArray);\r\n    };\r\n    /**\r\n     * Convert an input VectorFloat array into typed JS Float32Array\r\n     * @method\r\n     * @param {VectorFloat} inputVector input VectorFloat array\r\n     * @returns {Float32Array} returns converted JS typed array\r\n     * @memberof Essentia\r\n     */\r\n    Essentia.prototype.vectorToArray = function (inputVector) {\r\n        return this.module.vectorToArray(inputVector);\r\n    };\r\n    /**\r\n     * Cuts an audio signal data into overlapping frames given frame size and hop size\r\n     * @method\r\n     * @param {Float32Array} inputAudioData a single channel audio channel data\r\n     * @param {number} [frameSize=2048] frame size for cutting the audio signal\r\n     * @param {number} [hopSize=1024] size of overlapping frame\r\n     * @returns {VectorVectorFloat} Returns a 2D vector float of sliced audio frames\r\n     * @memberof Essentia\r\n     */\r\n    Essentia.prototype.FrameGenerator = function (inputAudioData, frameSize, hopSize) {\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (hopSize === void 0) { hopSize = 1024; }\r\n        return this.algorithms.FrameGenerator(inputAudioData, frameSize, hopSize);\r\n    };\r\n    /**\r\n    * This algorithm downmixes the signal into a single channel given a stereo signal. It is a wrapper around https://essentia.upf.edu/reference/std_MonoMixer.html.\r\n    * @method\r\n    * @param {VectorFloat} leftChannel the left channel of the stereo audio signal\r\n    * @param {VectorFloat} rightChannel the right channel of the stereo audio signal\r\n    * @returns {object} {audio: 'the downmixed mono signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.MonoMixer = function (leftSignal, rightSignal) {\r\n        return this.algorithms.MonoMixer(leftSignal, rightSignal);\r\n    };\r\n    /**\r\n    * This algorithm computes the EBUR128 loudness descriptors of an audio signal. It is a wrapper around https://essentia.upf.edu/reference/std_LoudnessEBUR128.html.\r\n    * @method\r\n    * @param {VectorFloat} leftChannel the left channel of the stereo audio signal\r\n    * @param {VectorFloat} rightChannel the right channel of the stereo audio signal\r\n    * @param {number} [hopSize=0.1] the hop size with which the loudness is computed [s]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {boolean} [startAtZero=false] start momentary/short-term loudness estimation at time 0 (zero-centered loudness estimation windows) if true; otherwise start both windows at time 0 (time positions for momentary and short-term values will not be syncronized)\r\n    * @returns {object} {momentaryLoudness: 'momentary loudness (over 400ms) (LUFS)', shortTermLoudness: 'short-term loudness (over 3 seconds) (LUFS)', integratedLoudness: 'integrated loudness (overall) (LUFS)', loudnessRange: 'loudness range over an arbitrary long time interval [3] (dB, LU)'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.LoudnessEBUR128 = function (leftSignal, rightSignal, hopSize, sampleRate, startAtZero) {\r\n        if (hopSize === void 0) { hopSize = 0.1; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (startAtZero === void 0) { startAtZero = false; }\r\n        return this.algorithms.LoudnessEBUR128(leftSignal, rightSignal, hopSize, sampleRate, startAtZero);\r\n    };\r\n    // NOTE: The following code snippets are machine generated. Do not edit.\r\n    /**\r\n    * This algorithm computes the ratio between the pitch energy after the pitch maximum and the pitch energy before the pitch maximum. Sounds having an monotonically ascending pitch or one unique pitch will show a value of (0,1], while sounds having a monotonically descending pitch will show a value of [1,inf). In case there is no energy before the max pitch, the algorithm will return the energy after the maximum pitch. Check https://essentia.upf.edu/reference/std_AfterMaxToBeforeMaxEnergyRatio.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} pitch the array of pitch values [Hz]\r\n    * @returns {object} {afterMaxToBeforeMaxEnergyRatio: 'the ratio between the pitch energy after the pitch maximum to the pitch energy before the pitch maximum'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.AfterMaxToBeforeMaxEnergyRatio = function (pitch) {\r\n        return this.algorithms.AfterMaxToBeforeMaxEnergyRatio(pitch);\r\n    };\r\n    /**\r\n    * This algorithm implements a IIR all-pass filter of order 1 or 2. Because of its dependence on IIR, IIR's requirements are inherited. Check https://essentia.upf.edu/reference/std_AllPass.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [bandwidth=500] the bandwidth of the filter [Hz] (used only for 2nd-order filters)\r\n    * @param {number} [cutoffFrequency=1500] the cutoff frequency for the filter [Hz]\r\n    * @param {number} [order=1] the order of the filter\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {signal: 'the filtered signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.AllPass = function (signal, bandwidth, cutoffFrequency, order, sampleRate) {\r\n        if (bandwidth === void 0) { bandwidth = 500; }\r\n        if (cutoffFrequency === void 0) { cutoffFrequency = 1500; }\r\n        if (order === void 0) { order = 1; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.AllPass(signal, bandwidth, cutoffFrequency, order, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm creates a wave file in which a given audio signal is mixed with a series of time onsets. The sonification of the onsets can be heard as beeps, or as short white noise pulses if configured to do so. Check https://essentia.upf.edu/reference/std_AudioOnsetsMarker.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {any[]} [onsets=[]] the list of onset locations [s]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the output signal [Hz]\r\n    * @param {string} [type=beep] the type of sound to be added on the event\r\n    * @returns {object} {signal: 'the input signal mixed with bursts at onset locations'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.AudioOnsetsMarker = function (signal, onsets, sampleRate, type) {\r\n        if (onsets === void 0) { onsets = []; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (type === void 0) { type = 'beep'; }\r\n        var veconsets = new this.module.VectorFloat();\r\n        for (var i = 0; i < veconsets.size(); i++) {\r\n            veconsets.push_back(onsets[i]);\r\n        }\r\n        return this.algorithms.AudioOnsetsMarker(signal, veconsets, sampleRate, type);\r\n    };\r\n    /**\r\n    * This algorithm computes the autocorrelation vector of a signal.\r\n    It uses the version most commonly used in signal processing, which doesn't remove the mean from the observations.\r\n    Using the 'generalized' option this algorithm computes autocorrelation as described in [3]. Check https://essentia.upf.edu/reference/std_AutoCorrelation.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the array to be analyzed\r\n    * @param {number} [frequencyDomainCompression=0.5] factor at which FFT magnitude is compressed (only used if 'generalized' is set to true, see [3])\r\n    * @param {boolean} [generalized=false] bool value to indicate whether to compute the 'generalized' autocorrelation as described in [3]\r\n    * @param {string} [normalization=standard] type of normalization to compute: either 'standard' (default) or 'unbiased'\r\n    * @returns {object} {autoCorrelation: 'the autocorrelation vector'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.AutoCorrelation = function (array, frequencyDomainCompression, generalized, normalization) {\r\n        if (frequencyDomainCompression === void 0) { frequencyDomainCompression = 0.5; }\r\n        if (generalized === void 0) { generalized = false; }\r\n        if (normalization === void 0) { normalization = 'standard'; }\r\n        return this.algorithms.AutoCorrelation(array, frequencyDomainCompression, generalized, normalization);\r\n    };\r\n    /**\r\n    * This algorithm computes the bark-frequency cepstrum coefficients of a spectrum. Bark bands and their subsequent usage in cepstral analysis have shown to be useful in percussive content [1, 2]\r\n    This algorithm is implemented using the Bark scaling approach in the Rastamat version of the MFCC algorithm and in a similar manner to the MFCC-FB40 default specs: Check https://essentia.upf.edu/reference/std_BFCC.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the audio spectrum\r\n    * @param {number} [dctType=2] the DCT type\r\n    * @param {number} [highFrequencyBound=11000] the upper bound of the frequency range [Hz]\r\n    * @param {number} [inputSize=1025] the size of input spectrum\r\n    * @param {number} [liftering=0] the liftering coefficient. Use '0' to bypass it\r\n    * @param {string} [logType=dbamp] logarithmic compression type. Use 'dbpow' if working with power and 'dbamp' if working with magnitudes\r\n    * @param {number} [lowFrequencyBound=0] the lower bound of the frequency range [Hz]\r\n    * @param {string} [normalize=unit_sum] 'unit_max' makes the vertex of all the triangles equal to 1, 'unit_sum' makes the area of all the triangles equal to 1\r\n    * @param {number} [numberBands=40] the number of bark bands in the filter\r\n    * @param {number} [numberCoefficients=13] the number of output cepstrum coefficients\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {string} [type=power] use magnitude or power spectrum\r\n    * @param {string} [weighting=warping] type of weighting function for determining triangle area\r\n    * @returns {object} {bands: 'the energies in bark bands', bfcc: 'the bark frequency cepstrum coefficients'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.BFCC = function (spectrum, dctType, highFrequencyBound, inputSize, liftering, logType, lowFrequencyBound, normalize, numberBands, numberCoefficients, sampleRate, type, weighting) {\r\n        if (dctType === void 0) { dctType = 2; }\r\n        if (highFrequencyBound === void 0) { highFrequencyBound = 11000; }\r\n        if (inputSize === void 0) { inputSize = 1025; }\r\n        if (liftering === void 0) { liftering = 0; }\r\n        if (logType === void 0) { logType = 'dbamp'; }\r\n        if (lowFrequencyBound === void 0) { lowFrequencyBound = 0; }\r\n        if (normalize === void 0) { normalize = 'unit_sum'; }\r\n        if (numberBands === void 0) { numberBands = 40; }\r\n        if (numberCoefficients === void 0) { numberCoefficients = 13; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (type === void 0) { type = 'power'; }\r\n        if (weighting === void 0) { weighting = 'warping'; }\r\n        return this.algorithms.BFCC(spectrum, dctType, highFrequencyBound, inputSize, liftering, logType, lowFrequencyBound, normalize, numberBands, numberCoefficients, sampleRate, type, weighting);\r\n    };\r\n    /**\r\n    * This algorithm implements a break point function which linearly interpolates between discrete xy-coordinates to construct a continuous function. Check https://essentia.upf.edu/reference/std_BPF.html for more details.\r\n    * @method\r\n    * @param {number} x the input coordinate (x-axis)\r\n    * @param {any[]} [xPoints=[0, 1]] the x-coordinates of the points forming the break-point function (the points must be arranged in ascending order and cannot contain duplicates)\r\n    * @param {any[]} [yPoints=[0, 1]] the y-coordinates of the points forming the break-point function\r\n    * @returns {object} {y: 'the output coordinate (y-axis)'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.BPF = function (x, xPoints, yPoints) {\r\n        if (xPoints === void 0) { xPoints = [0, 1]; }\r\n        if (yPoints === void 0) { yPoints = [0, 1]; }\r\n        var vecxPoints = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecxPoints.size(); i++) {\r\n            vecxPoints.push_back(xPoints[i]);\r\n        }\r\n        var vecyPoints = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecyPoints.size(); i++) {\r\n            vecyPoints.push_back(yPoints[i]);\r\n        }\r\n        return this.algorithms.BPF(x, vecxPoints, vecyPoints);\r\n    };\r\n    /**\r\n    * This algorithm implements a 2nd order IIR band-pass filter. Because of its dependence on IIR, IIR's requirements are inherited. Check https://essentia.upf.edu/reference/std_BandPass.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio signal\r\n    * @param {number} [bandwidth=500] the bandwidth of the filter [Hz]\r\n    * @param {number} [cutoffFrequency=1500] the cutoff frequency for the filter [Hz]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {signal: 'the filtered signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.BandPass = function (signal, bandwidth, cutoffFrequency, sampleRate) {\r\n        if (bandwidth === void 0) { bandwidth = 500; }\r\n        if (cutoffFrequency === void 0) { cutoffFrequency = 1500; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.BandPass(signal, bandwidth, cutoffFrequency, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm implements a 2nd order IIR band-reject filter. Because of its dependence on IIR, IIR's requirements are inherited. Check https://essentia.upf.edu/reference/std_BandReject.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [bandwidth=500] the bandwidth of the filter [Hz]\r\n    * @param {number} [cutoffFrequency=1500] the cutoff frequency for the filter [Hz]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {signal: 'the filtered signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.BandReject = function (signal, bandwidth, cutoffFrequency, sampleRate) {\r\n        if (bandwidth === void 0) { bandwidth = 500; }\r\n        if (cutoffFrequency === void 0) { cutoffFrequency = 1500; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.BandReject(signal, bandwidth, cutoffFrequency, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes energy in Bark bands of a spectrum. The band frequencies are: [0.0, 50.0, 100.0, 150.0, 200.0, 300.0, 400.0, 510.0, 630.0, 770.0, 920.0, 1080.0, 1270.0, 1480.0, 1720.0, 2000.0, 2320.0, 2700.0, 3150.0, 3700.0, 4400.0, 5300.0, 6400.0, 7700.0, 9500.0, 12000.0, 15500.0, 20500.0, 27000.0]. The first two Bark bands [0,100] and [100,200] have been split in half for better resolution (because of an observed better performance in beat detection). For each bark band the power-spectrum (mag-squared) is summed. Check https://essentia.upf.edu/reference/std_BarkBands.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input spectrum\r\n    * @param {number} [numberBands=27] the number of desired barkbands\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {bands: 'the energy of the bark bands'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.BarkBands = function (spectrum, numberBands, sampleRate) {\r\n        if (numberBands === void 0) { numberBands = 27; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.BarkBands(spectrum, numberBands, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm estimates the beat positions given an input signal. It computes 'complex spectral difference' onset detection function and utilizes the beat tracking algorithm (TempoTapDegara) to extract beats [1]. The algorithm works with the optimized settings of 2048/1024 frame/hop size for the computation of the detection function, with its posterior x2 resampling.) While it has a lower accuracy than BeatTrackerMultifeature (see the evaluation results in [2]), its computational speed is significantly higher, which makes reasonable to apply this algorithm for batch processings of large amounts of audio signals. Check https://essentia.upf.edu/reference/std_BeatTrackerDegara.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the audio input signal\r\n    * @param {number} [maxTempo=208] the fastest tempo to detect [bpm]\r\n    * @param {number} [minTempo=40] the slowest tempo to detect [bpm]\r\n    * @returns {object} {ticks: ' the estimated tick locations [s]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.BeatTrackerDegara = function (signal, maxTempo, minTempo) {\r\n        if (maxTempo === void 0) { maxTempo = 208; }\r\n        if (minTempo === void 0) { minTempo = 40; }\r\n        return this.algorithms.BeatTrackerDegara(signal, maxTempo, minTempo);\r\n    };\r\n    /**\r\n    * This algorithm estimates the beat positions given an input signal. It computes a number of onset detection functions and estimates beat location candidates from them using TempoTapDegara algorithm. Thereafter the best candidates are selected using TempoTapMaxAgreement. The employed detection functions, and the optimal frame/hop sizes used for their computation are:\r\n      - complex spectral difference (see 'complex' method in OnsetDetection algorithm, 2048/1024 with posterior x2 upsample or the detection function)\r\n      - energy flux (see 'rms' method in OnsetDetection algorithm, the same settings)\r\n      - spectral flux in Mel-frequency bands (see 'melflux' method in OnsetDetection algorithm, the same settings)\r\n      - beat emphasis function (see 'beat_emphasis' method in OnsetDetectionGlobal algorithm, 2048/512)\r\n      - spectral flux between histogrammed spectrum frames, measured by the modified information gain (see 'infogain' method in OnsetDetectionGlobal algorithm, 2048/512) Check https://essentia.upf.edu/reference/std_BeatTrackerMultiFeature.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the audio input signal\r\n    * @param {number} [maxTempo=208] the fastest tempo to detect [bpm]\r\n    * @param {number} [minTempo=40] the slowest tempo to detect [bpm]\r\n    * @returns {object} {ticks: ' the estimated tick locations [s]', confidence: 'confidence of the beat tracker [0, 5.32]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.BeatTrackerMultiFeature = function (signal, maxTempo, minTempo) {\r\n        if (maxTempo === void 0) { maxTempo = 208; }\r\n        if (minTempo === void 0) { minTempo = 40; }\r\n        return this.algorithms.BeatTrackerMultiFeature(signal, maxTempo, minTempo);\r\n    };\r\n    /**\r\n    * This algorithm filters the loudness matrix given by BeatsLoudness algorithm in order to keep only the most salient beat band representation.\r\n    This algorithm has been found to be useful for estimating time signatures. Check https://essentia.upf.edu/reference/std_Beatogram.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} loudness the loudness at each beat\r\n    * @param {VectorVectorFloat} loudnessBandRatio matrix of loudness ratios at each band and beat\r\n    * @param {number} [size=16] number of beats for dynamic filtering\r\n    * @returns {object} {beatogram: 'filtered matrix loudness'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Beatogram = function (loudness, loudnessBandRatio, size) {\r\n        if (size === void 0) { size = 16; }\r\n        return this.algorithms.Beatogram(loudness, loudnessBandRatio, size);\r\n    };\r\n    /**\r\n    * This algorithm computes the spectrum energy of beats in an audio signal given their positions. The energy is computed both on the whole frequency range and for each of the specified frequency bands. See the SingleBeatLoudness algorithm for a more detailed explanation. Check https://essentia.upf.edu/reference/std_BeatsLoudness.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio signal\r\n    * @param {number} [beatDuration=0.05] the duration of the window in which the beat will be restricted [s]\r\n    * @param {number} [beatWindowDuration=0.1] the duration of the window in which to look for the beginning of the beat (centered around the positions in 'beats') [s]\r\n    * @param {any[]} [beats=[]] the list of beat positions (each position is in seconds)\r\n    * @param {any[]} [frequencyBands=[20, 150, 400, 3200, 7000, 22000]] the list of bands to compute energy ratios [Hz\r\n    * @param {number} [sampleRate=44100] the audio sampling rate [Hz]\r\n    * @returns {object} {loudness: 'the beat's energy in the whole spectrum', loudnessBandRatio: 'the ratio of the beat's energy on each frequency band'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.BeatsLoudness = function (signal, beatDuration, beatWindowDuration, beats, frequencyBands, sampleRate) {\r\n        if (beatDuration === void 0) { beatDuration = 0.05; }\r\n        if (beatWindowDuration === void 0) { beatWindowDuration = 0.1; }\r\n        if (beats === void 0) { beats = []; }\r\n        if (frequencyBands === void 0) { frequencyBands = [20, 150, 400, 3200, 7000, 22000]; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        var vecbeats = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecbeats.size(); i++) {\r\n            vecbeats.push_back(beats[i]);\r\n        }\r\n        var vecfrequencyBands = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecfrequencyBands.size(); i++) {\r\n            vecfrequencyBands.push_back(frequencyBands[i]);\r\n        }\r\n        return this.algorithms.BeatsLoudness(signal, beatDuration, beatWindowDuration, vecbeats, vecfrequencyBands, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm performs basic arithmetical operations element by element given two arrays.\r\n    Note:\r\n      - using this algorithm in streaming mode can cause diamond shape graphs which have not been tested with the current scheduler. There is NO GUARANTEE of its correct work for diamond shape graphs.\r\n      - for y<0, x/y is invalid Check https://essentia.upf.edu/reference/std_BinaryOperator.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array1 the first operand input array\r\n    * @param {VectorFloat} array2 the second operand input array\r\n    * @param {string} [type=add] the type of the binary operator to apply to the input arrays\r\n    * @returns {object} {array: 'the array containing the result of binary operation'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.BinaryOperator = function (array1, array2, type) {\r\n        if (type === void 0) { type = 'add'; }\r\n        return this.algorithms.BinaryOperator(array1, array2, type);\r\n    };\r\n    /**\r\n    * This algorithm performs basic arithmetical operations element by element given two arrays.\r\n    Note:\r\n      - using this algorithm in streaming mode can cause diamond shape graphs which have not been tested with the current scheduler. There is NO GUARANTEE of its correct work for diamond shape graphs.\r\n      - for y<0, x/y is invalid Check https://essentia.upf.edu/reference/std_BinaryOperatorStream.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array1 the first operand input array\r\n    * @param {VectorFloat} array2 the second operand input array\r\n    * @param {string} [type=add] the type of the binary operator to apply to the input arrays\r\n    * @returns {object} {array: 'the array containing the result of binary operation'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.BinaryOperatorStream = function (array1, array2, type) {\r\n        if (type === void 0) { type = 'add'; }\r\n        return this.algorithms.BinaryOperatorStream(array1, array2, type);\r\n    };\r\n    /**\r\n    * This algorithm computes beats per minute histogram and its statistics for the highest and second highest peak.\r\n    Note: histogram vector contains occurance frequency for each bpm value, 0-th element corresponds to 0 bpm value. Check https://essentia.upf.edu/reference/std_BpmHistogramDescriptors.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} bpmIntervals the list of bpm intervals [s]\r\n    * @returns {object} {firstPeakBPM: 'value for the highest peak [bpm]', firstPeakWeight: 'weight of the highest peak', firstPeakSpread: 'spread of the highest peak', secondPeakBPM: 'value for the second highest peak [bpm]', secondPeakWeight: 'weight of the second highest peak', secondPeakSpread: 'spread of the second highest peak', histogram: 'bpm histogram [bpm]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.BpmHistogramDescriptors = function (bpmIntervals) {\r\n        return this.algorithms.BpmHistogramDescriptors(bpmIntervals);\r\n    };\r\n    /**\r\n    * This algorithm extracts the locations of large tempo changes from a list of beat ticks. Check https://essentia.upf.edu/reference/std_BpmRubato.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} beats list of detected beat ticks [s]\r\n    * @param {number} [longRegionsPruningTime=20] time for the longest constant tempo region inside a rubato region [s]\r\n    * @param {number} [shortRegionsMergingTime=4] time for the shortest constant tempo region from one tempo region to another [s]\r\n    * @param {number} [tolerance=0.08] minimum tempo deviation to look for\r\n    * @returns {object} {rubatoStart: 'list of timestamps where the start of a rubato region was detected [s]', rubatoStop: 'list of timestamps where the end of a rubato region was detected [s]', rubatoNumber: 'number of detected rubato regions'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.BpmRubato = function (beats, longRegionsPruningTime, shortRegionsMergingTime, tolerance) {\r\n        if (longRegionsPruningTime === void 0) { longRegionsPruningTime = 20; }\r\n        if (shortRegionsMergingTime === void 0) { shortRegionsMergingTime = 4; }\r\n        if (tolerance === void 0) { tolerance = 0.08; }\r\n        return this.algorithms.BpmRubato(beats, longRegionsPruningTime, shortRegionsMergingTime, tolerance);\r\n    };\r\n    /**\r\n    * This algorithm extracts the 0th, 1st, 2nd, 3rd and 4th central moments of an array. It returns a 5-tuple in which the index corresponds to the order of the moment. Check https://essentia.upf.edu/reference/std_CentralMoments.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @param {string} [mode=pdf] compute central moments considering array values as a probability density function over array index or as sample points of a distribution\r\n    * @param {number} [range=1] the range of the input array, used for normalizing the results in the 'pdf' mode\r\n    * @returns {object} {centralMoments: 'the central moments of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.CentralMoments = function (array, mode, range) {\r\n        if (mode === void 0) { mode = 'pdf'; }\r\n        if (range === void 0) { range = 1; }\r\n        return this.algorithms.CentralMoments(array, mode, range);\r\n    };\r\n    /**\r\n    * This algorithm computes the centroid of an array. The centroid is normalized to a specified range. This algorithm can be used to compute spectral centroid or temporal centroid. Check https://essentia.upf.edu/reference/std_Centroid.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @param {number} [range=1] the range of the input array, used for normalizing the results\r\n    * @returns {object} {centroid: 'the centroid of the array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Centroid = function (array, range) {\r\n        if (range === void 0) { range = 1; }\r\n        return this.algorithms.Centroid(array, range);\r\n    };\r\n    /**\r\n    * Given a chord progression this algorithm describes it by means of key, scale, histogram, and rate of change.\r\n    Note:\r\n      - chordsHistogram indexes follow the circle of fifths order, while being shifted to the input key and scale\r\n      - key and scale are taken from the most frequent chord. In the case where multiple chords are equally frequent, the chord is hierarchically chosen from the circle of fifths.\r\n      - chords should follow this name convention `<A-G>[<#/b><m>]` (i.e. C, C# or C#m are valid chords). Chord names not fitting this convention will throw an exception. Check https://essentia.upf.edu/reference/std_ChordsDescriptors.html for more details.\r\n    * @method\r\n    * @param {VectorString} chords the chord progression\r\n    * @param {string} key the key of the whole song, from A to G\r\n    * @param {string} scale the scale of the whole song (major or minor)\r\n    * @returns {object} {chordsHistogram: 'the normalized histogram of chords', chordsNumberRate: 'the ratio of different chords from the total number of chords in the progression', chordsChangesRate: 'the rate at which chords change in the progression', chordsKey: 'the most frequent chord of the progression', chordsScale: 'the scale of the most frequent chord of the progression (either 'major' or 'minor')'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.ChordsDescriptors = function (chords, key, scale) {\r\n        return this.algorithms.ChordsDescriptors(chords, key, scale);\r\n    };\r\n    /**\r\n    * This algorithm estimates chords given an input sequence of harmonic pitch class profiles (HPCPs). It finds the best matching major or minor triad and outputs the result as a string (e.g. A#, Bm, G#m, C). This algorithm uses the Sharp versions of each Flatted note (i.e. Bb -> A#). Check https://essentia.upf.edu/reference/std_ChordsDetection.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} pcp the pitch class profile from which to detect the chord\r\n    * @param {number} [hopSize=2048] the hop size with which the input PCPs were computed\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [windowSize=2] the size of the window on which to estimate the chords [s]\r\n    * @returns {object} {chords: 'the resulting chords, from A to G', strength: 'the strength of the chord'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.ChordsDetection = function (pcp, hopSize, sampleRate, windowSize) {\r\n        if (hopSize === void 0) { hopSize = 2048; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (windowSize === void 0) { windowSize = 2; }\r\n        return this.algorithms.ChordsDetection(pcp, hopSize, sampleRate, windowSize);\r\n    };\r\n    /**\r\n    * This algorithm estimates chords using pitch profile classes on segments between beats. It is similar to ChordsDetection algorithm, but the chords are estimated on audio segments between each pair of consecutive beats. For each segment the estimation is done based on a chroma (HPCP) vector characterizing it, which can be computed by two methods:\r\n      - 'interbeat_median', each resulting chroma vector component is a median of all the component values in the segment\r\n      - 'starting_beat', chroma vector is sampled from the start of the segment (that is, its starting beat position) using its first frame. It makes sense if chroma is preliminary smoothed. Check https://essentia.upf.edu/reference/std_ChordsDetectionBeats.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} pcp the pitch class profile from which to detect the chord\r\n    * @param {VectorFloat} ticks the list of beat positions (in seconds)\r\n    * @param {string} [chromaPick=interbeat_median] method of calculating singleton chroma for interbeat interval\r\n    * @param {number} [hopSize=2048] the hop size with which the input PCPs were computed\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {chords: 'the resulting chords, from A to G', strength: 'the strength of the chords'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.ChordsDetectionBeats = function (pcp, ticks, chromaPick, hopSize, sampleRate) {\r\n        if (chromaPick === void 0) { chromaPick = 'interbeat_median'; }\r\n        if (hopSize === void 0) { hopSize = 2048; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.ChordsDetectionBeats(pcp, ticks, chromaPick, hopSize, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes a binary cross similarity matrix from two chromagam feature vectors of a query and reference song. Check https://essentia.upf.edu/reference/std_ChromaCrossSimilarity.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} queryFeature frame-wise chromagram of the query song (e.g., a HPCP)\r\n    * @param {VectorVectorFloat} referenceFeature frame-wise chromagram of the reference song (e.g., a HPCP)\r\n    * @param {number} [binarizePercentile=0.095] maximum percent of distance values to consider as similar in each row and each column\r\n    * @param {number} [frameStackSize=9] number of input frames to stack together and treat as a feature vector for similarity computation. Choose 'frameStackSize=1' to use the original input frames without stacking\r\n    * @param {number} [frameStackStride=1] stride size to form a stack of frames (e.g., 'frameStackStride'=1 to use consecutive frames; 'frameStackStride'=2 for using every second frame)\r\n    * @param {number} [noti=12] number of circular shifts to be checked for Optimal Transposition Index [1]\r\n    * @param {boolean} [oti=true] whether to transpose the key of the reference song to the query song by Optimal Transposition Index [1]\r\n    * @param {boolean} [otiBinary=false] whether to use the OTI-based chroma binary similarity method [3]\r\n    * @param {boolean} [streaming=false] whether to accumulate the input 'queryFeature' in the euclidean similarity matrix calculation on each compute() method call\r\n    * @returns {object} {csm: '2D binary cross-similarity matrix of the query and reference features'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.ChromaCrossSimilarity = function (queryFeature, referenceFeature, binarizePercentile, frameStackSize, frameStackStride, noti, oti, otiBinary, streaming) {\r\n        if (binarizePercentile === void 0) { binarizePercentile = 0.095; }\r\n        if (frameStackSize === void 0) { frameStackSize = 9; }\r\n        if (frameStackStride === void 0) { frameStackStride = 1; }\r\n        if (noti === void 0) { noti = 12; }\r\n        if (oti === void 0) { oti = true; }\r\n        if (otiBinary === void 0) { otiBinary = false; }\r\n        if (streaming === void 0) { streaming = false; }\r\n        return this.algorithms.ChromaCrossSimilarity(queryFeature, referenceFeature, binarizePercentile, frameStackSize, frameStackStride, noti, oti, otiBinary, streaming);\r\n    };\r\n    /**\r\n    * This algorithm computes the Constant-Q chromagram using FFT. See ConstantQ algorithm for more details.\r\n     Check https://essentia.upf.edu/reference/std_Chromagram.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input audio frame\r\n    * @param {number} [binsPerOctave=12] number of bins per octave\r\n    * @param {number} [minFrequency=32.7] minimum frequency [Hz]\r\n    * @param {number} [minimumKernelSize=4] minimum size allowed for frequency kernels\r\n    * @param {string} [normalizeType=unit_max] normalize type\r\n    * @param {number} [numberBins=84] number of frequency bins, starting at minFrequency\r\n    * @param {number} [sampleRate=44100] FFT sampling rate [Hz]\r\n    * @param {number} [scale=1] filters scale. Larger values use longer windows\r\n    * @param {number} [threshold=0.01] bins whose magnitude is below this quantile are discarded\r\n    * @param {string} [windowType=hann] the window type, which can be 'hamming', 'hann', 'triangular', 'square' or 'blackmanharrisXX'\r\n    * @param {boolean} [zeroPhase=true] a boolean value that enables zero-phase windowing. Input audio frames should be windowed with the same phase mode\r\n    * @returns {object} {chromagram: 'the magnitude constant-Q chromagram'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Chromagram = function (frame, binsPerOctave, minFrequency, minimumKernelSize, normalizeType, numberBins, sampleRate, scale, threshold, windowType, zeroPhase) {\r\n        if (binsPerOctave === void 0) { binsPerOctave = 12; }\r\n        if (minFrequency === void 0) { minFrequency = 32.7; }\r\n        if (minimumKernelSize === void 0) { minimumKernelSize = 4; }\r\n        if (normalizeType === void 0) { normalizeType = 'unit_max'; }\r\n        if (numberBins === void 0) { numberBins = 84; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (scale === void 0) { scale = 1; }\r\n        if (threshold === void 0) { threshold = 0.01; }\r\n        if (windowType === void 0) { windowType = 'hann'; }\r\n        if (zeroPhase === void 0) { zeroPhase = true; }\r\n        return this.algorithms.Chromagram(frame, binsPerOctave, minFrequency, minimumKernelSize, normalizeType, numberBins, sampleRate, scale, threshold, windowType, zeroPhase);\r\n    };\r\n    /**\r\n    * This algorithm detects the locations of impulsive noises (clicks and pops) on the input audio frame. It relies on LPC coefficients to inverse-filter the audio in order to attenuate the stationary part and enhance the prediction error (or excitation noise)[1]. After this, a matched filter is used to further enhance the impulsive peaks. The detection threshold is obtained from a robust estimate of the excitation noise power [2] plus a parametric gain value. Check https://essentia.upf.edu/reference/std_ClickDetector.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input frame (must be non-empty)\r\n    * @param {number} [detectionThreshold=30] 'detectionThreshold' the threshold is based on the instant power of the noisy excitation signal plus detectionThreshold dBs\r\n    * @param {number} [frameSize=512] the expected size of the input audio signal (this is an optional parameter to optimize memory allocation)\r\n    * @param {number} [hopSize=256] hop size used for the analysis. This parameter must be set correctly as it cannot be obtained from the input data\r\n    * @param {number} [order=12] scalar giving the number of LPCs to use\r\n    * @param {number} [powerEstimationThreshold=10] the noisy excitation is clipped to 'powerEstimationThreshold' times its median.\r\n    * @param {number} [sampleRate=44100] sample rate used for the analysis\r\n    * @param {number} [silenceThreshold=-50] threshold to skip silent frames\r\n    * @returns {object} {starts: 'starting indexes of the clicks', ends: 'ending indexes of the clicks'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.ClickDetector = function (frame, detectionThreshold, frameSize, hopSize, order, powerEstimationThreshold, sampleRate, silenceThreshold) {\r\n        if (detectionThreshold === void 0) { detectionThreshold = 30; }\r\n        if (frameSize === void 0) { frameSize = 512; }\r\n        if (hopSize === void 0) { hopSize = 256; }\r\n        if (order === void 0) { order = 12; }\r\n        if (powerEstimationThreshold === void 0) { powerEstimationThreshold = 10; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (silenceThreshold === void 0) { silenceThreshold = -50; }\r\n        return this.algorithms.ClickDetector(frame, detectionThreshold, frameSize, hopSize, order, powerEstimationThreshold, sampleRate, silenceThreshold);\r\n    };\r\n    /**\r\n    * This algorithm clips the input signal to fit its values into a specified interval. Check https://essentia.upf.edu/reference/std_Clipper.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [max=1] the maximum value above which the signal will be clipped\r\n    * @param {number} [min=-1] the minimum value below which the signal will be clipped\r\n    * @returns {object} {signal: 'the output signal with the added noise'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Clipper = function (signal, max, min) {\r\n        if (max === void 0) { max = 1; }\r\n        if (min === void 0) { min = -1; }\r\n        return this.algorithms.Clipper(signal, max, min);\r\n    };\r\n    /**\r\n    * This algorithm computes a cover song similiarity measure from a binary cross similarity matrix input between two chroma vectors of a query and reference song using various alignment constraints of smith-waterman local-alignment algorithm. Check https://essentia.upf.edu/reference/std_CoverSongSimilarity.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} inputArray  a 2D binary cross-similarity matrix between two audio chroma vectors (query vs reference song) (refer 'ChromaCrossSimilarity' algorithm').\r\n    * @param {string} [alignmentType=serra09] choose either one of the given local-alignment constraints for smith-waterman algorithm as described in [2] or [3] respectively.\r\n    * @param {number} [disExtension=0.5] penalty for disruption extension\r\n    * @param {number} [disOnset=0.5] penalty for disruption onset\r\n    * @param {string} [distanceType=asymmetric] choose the type of distance. By default the algorithm outputs a asymmetric disctance which is obtained by normalising the maximum score in the alignment score matrix with length of reference song\r\n    * @returns {object} {scoreMatrix: 'a 2D smith-waterman alignment score matrix from the input binary cross-similarity matrix', distance: 'cover song similarity distance between the query and reference song from the input similarity matrix. Either 'asymmetric' (as described in [2]) or 'symmetric' (maximum score in the alignment score matrix).'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.CoverSongSimilarity = function (inputArray, alignmentType, disExtension, disOnset, distanceType) {\r\n        if (alignmentType === void 0) { alignmentType = 'serra09'; }\r\n        if (disExtension === void 0) { disExtension = 0.5; }\r\n        if (disOnset === void 0) { disOnset = 0.5; }\r\n        if (distanceType === void 0) { distanceType = 'asymmetric'; }\r\n        return this.algorithms.CoverSongSimilarity(inputArray, alignmentType, disExtension, disOnset, distanceType);\r\n    };\r\n    /**\r\n    * This algorithm computes the crest of an array. The crest is defined as the ratio between the maximum value and the arithmetic mean of an array. Typically it is used on the magnitude spectrum. Check https://essentia.upf.edu/reference/std_Crest.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array (cannot contain negative values, and must be non-empty)\r\n    * @returns {object} {crest: 'the crest of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Crest = function (array) {\r\n        return this.algorithms.Crest(array);\r\n    };\r\n    /**\r\n    * This algorithm computes the cross-correlation vector of two signals. It accepts 2 parameters, minLag and maxLag which define the range of the computation of the innerproduct. Check https://essentia.upf.edu/reference/std_CrossCorrelation.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} arrayX the first input array\r\n    * @param {VectorFloat} arrayY the second input array\r\n    * @param {number} [maxLag=1] the maximum lag to be computed between the two vectors\r\n    * @param {number} [minLag=0] the minimum lag to be computed between the two vectors\r\n    * @returns {object} {crossCorrelation: 'the cross-correlation vector between the two input arrays (its size is equal to maxLag - minLag + 1)'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.CrossCorrelation = function (arrayX, arrayY, maxLag, minLag) {\r\n        if (maxLag === void 0) { maxLag = 1; }\r\n        if (minLag === void 0) { minLag = 0; }\r\n        return this.algorithms.CrossCorrelation(arrayX, arrayY, maxLag, minLag);\r\n    };\r\n    /**\r\n    * This algorithm computes a euclidean cross-similarity matrix of two sequences of frame features. Similarity values can be optionally binarized Check https://essentia.upf.edu/reference/std_CrossSimilarityMatrix.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} queryFeature input frame features of the query song (e.g., a chromagram)\r\n    * @param {VectorVectorFloat} referenceFeature input frame features of the reference song (e.g., a chromagram)\r\n    * @param {boolean} [binarize=false] whether to binarize the euclidean cross-similarity matrix\r\n    * @param {number} [binarizePercentile=0.095] maximum percent of distance values to consider as similar in each row and each column\r\n    * @param {number} [frameStackSize=1] number of input frames to stack together and treat as a feature vector for similarity computation. Choose 'frameStackSize=1' to use the original input frames without stacking\r\n    * @param {number} [frameStackStride=1] stride size to form a stack of frames (e.g., 'frameStackStride'=1 to use consecutive frames; 'frameStackStride'=2 for using every second frame)\r\n    * @returns {object} {csm: '2D cross-similarity matrix of two input frame sequences (query vs reference)'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.CrossSimilarityMatrix = function (queryFeature, referenceFeature, binarize, binarizePercentile, frameStackSize, frameStackStride) {\r\n        if (binarize === void 0) { binarize = false; }\r\n        if (binarizePercentile === void 0) { binarizePercentile = 0.095; }\r\n        if (frameStackSize === void 0) { frameStackSize = 1; }\r\n        if (frameStackStride === void 0) { frameStackStride = 1; }\r\n        return this.algorithms.CrossSimilarityMatrix(queryFeature, referenceFeature, binarize, binarizePercentile, frameStackSize, frameStackStride);\r\n    };\r\n    /**\r\n    * Computes the second derivatives of a piecewise cubic spline.\r\n    The input value, i.e. the point at which the spline is to be evaluated typically should be between xPoints[0] and xPoints[size-1]. If the value lies outside this range, extrapolation is used.\r\n    Regarding [left/right] boundary condition flag parameters:\r\n      - 0: the cubic spline should be a quadratic over the first interval\r\n      - 1: the first derivative at the [left/right] endpoint should be [left/right]BoundaryFlag\r\n      - 2: the second derivative at the [left/right] endpoint should be [left/right]BoundaryFlag\r\n    References:\r\n      [1] Spline interpolation - Wikipedia, the free encyclopedia,\r\n      http://en.wikipedia.org/wiki/Spline_interpolation Check https://essentia.upf.edu/reference/std_CubicSpline.html for more details.\r\n    * @method\r\n    * @param {number} x the input coordinate (x-axis)\r\n    * @param {number} [leftBoundaryFlag=0] type of boundary condition for the left boundary\r\n    * @param {number} [leftBoundaryValue=0] the value to be used in the left boundary, when leftBoundaryFlag is 1 or 2\r\n    * @param {number} [rightBoundaryFlag=0] type of boundary condition for the right boundary\r\n    * @param {number} [rightBoundaryValue=0] the value to be used in the right boundary, when rightBoundaryFlag is 1 or 2\r\n    * @param {any[]} [xPoints=[0, 1]] the x-coordinates where data is specified (the points must be arranged in ascending order and cannot contain duplicates)\r\n    * @param {any[]} [yPoints=[0, 1]] the y-coordinates to be interpolated (i.e. the known data)\r\n    * @returns {object} {y: 'the value of the spline at x', dy: 'the first derivative of the spline at x', ddy: 'the second derivative of the spline at x'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.CubicSpline = function (x, leftBoundaryFlag, leftBoundaryValue, rightBoundaryFlag, rightBoundaryValue, xPoints, yPoints) {\r\n        if (leftBoundaryFlag === void 0) { leftBoundaryFlag = 0; }\r\n        if (leftBoundaryValue === void 0) { leftBoundaryValue = 0; }\r\n        if (rightBoundaryFlag === void 0) { rightBoundaryFlag = 0; }\r\n        if (rightBoundaryValue === void 0) { rightBoundaryValue = 0; }\r\n        if (xPoints === void 0) { xPoints = [0, 1]; }\r\n        if (yPoints === void 0) { yPoints = [0, 1]; }\r\n        var vecxPoints = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecxPoints.size(); i++) {\r\n            vecxPoints.push_back(xPoints[i]);\r\n        }\r\n        var vecyPoints = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecyPoints.size(); i++) {\r\n            vecyPoints.push_back(yPoints[i]);\r\n        }\r\n        return this.algorithms.CubicSpline(x, leftBoundaryFlag, leftBoundaryValue, rightBoundaryFlag, rightBoundaryValue, vecxPoints, vecyPoints);\r\n    };\r\n    /**\r\n    * This algorithm removes the DC offset from a signal using a 1st order IIR highpass filter. Because of its dependence on IIR, IIR's requirements are inherited. Check https://essentia.upf.edu/reference/std_DCRemoval.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio signal\r\n    * @param {number} [cutoffFrequency=40] the cutoff frequency for the filter [Hz]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {signal: 'the filtered signal, with the DC component removed'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.DCRemoval = function (signal, cutoffFrequency, sampleRate) {\r\n        if (cutoffFrequency === void 0) { cutoffFrequency = 40; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.DCRemoval(signal, cutoffFrequency, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the Discrete Cosine Transform of an array.\r\n    It uses the DCT-II form, with the 1/sqrt(2) scaling factor for the first coefficient. Check https://essentia.upf.edu/reference/std_DCT.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @param {number} [dctType=2] the DCT type\r\n    * @param {number} [inputSize=10] the size of the input array\r\n    * @param {number} [liftering=0] the liftering coefficient. Use '0' to bypass it\r\n    * @param {number} [outputSize=10] the number of output coefficients\r\n    * @returns {object} {dct: 'the discrete cosine transform of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.DCT = function (array, dctType, inputSize, liftering, outputSize) {\r\n        if (dctType === void 0) { dctType = 2; }\r\n        if (inputSize === void 0) { inputSize = 10; }\r\n        if (liftering === void 0) { liftering = 0; }\r\n        if (outputSize === void 0) { outputSize = 10; }\r\n        return this.algorithms.DCT(array, dctType, inputSize, liftering, outputSize);\r\n    };\r\n    /**\r\n    * This algorithm estimates danceability of a given audio signal. The algorithm is derived from Detrended Fluctuation Analysis (DFA) described in [1]. The parameters minTau and maxTau are used to define the range of time over which DFA will be performed. The output of this algorithm is the danceability of the audio signal. These values usually range from 0 to 3 (higher values meaning more danceable). Check https://essentia.upf.edu/reference/std_Danceability.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [maxTau=8800] maximum segment length to consider [ms]\r\n    * @param {number} [minTau=310] minimum segment length to consider [ms]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [tauMultiplier=1.1] multiplier to increment from min to max tau\r\n    * @returns {object} {danceability: 'the danceability value. Normal values range from 0 to ~3. The higher, the more danceable.', dfa: 'the DFA exponent vector for considered segment length (tau) values'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Danceability = function (signal, maxTau, minTau, sampleRate, tauMultiplier) {\r\n        if (maxTau === void 0) { maxTau = 8800; }\r\n        if (minTau === void 0) { minTau = 310; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (tauMultiplier === void 0) { tauMultiplier = 1.1; }\r\n        return this.algorithms.Danceability(signal, maxTau, minTau, sampleRate, tauMultiplier);\r\n    };\r\n    /**\r\n    * This algorithm computes the decrease of an array defined as the linear regression coefficient. The range parameter is used to normalize the result. For a spectral centroid, the range should be equal to Nyquist and for an audio centroid the range should be equal to (audiosize - 1) / samplerate.\r\n    The size of the input array must be at least two elements for \"decrease\" to be computed, otherwise an exception is thrown.\r\n    References:\r\n      [1] Least Squares Fitting -- from Wolfram MathWorld,\r\n      http://mathworld.wolfram.com/LeastSquaresFitting.html Check https://essentia.upf.edu/reference/std_Decrease.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @param {number} [range=1] the range of the input array, used for normalizing the results\r\n    * @returns {object} {decrease: 'the decrease of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Decrease = function (array, range) {\r\n        if (range === void 0) { range = 1; }\r\n        return this.algorithms.Decrease(array, range);\r\n    };\r\n    /**\r\n    * This algorithm returns the first-order derivative of an input signal. That is, for each input value it returns the value minus the previous one. Check https://essentia.upf.edu/reference/std_Derivative.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @returns {object} {signal: 'the derivative of the input signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Derivative = function (signal) {\r\n        return this.algorithms.Derivative(signal);\r\n    };\r\n    /**\r\n    * This algorithm computes two descriptors that are based on the derivative of a signal envelope. Check https://essentia.upf.edu/reference/std_DerivativeSFX.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} envelope the envelope of the signal\r\n    * @returns {object} {derAvAfterMax: 'the weighted average of the derivative after the maximum amplitude', maxDerBeforeMax: 'the maximum derivative before the maximum amplitude'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.DerivativeSFX = function (envelope) {\r\n        return this.algorithms.DerivativeSFX(envelope);\r\n    };\r\n    /**\r\n    * This algorithm uses LPC and some heuristics to detect discontinuities in an audio signal. [1]. Check https://essentia.upf.edu/reference/std_DiscontinuityDetector.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input frame (must be non-empty)\r\n    * @param {number} [detectionThreshold=8] 'detectionThreshold' times the standard deviation plus the median of the frame is used as detection threshold\r\n    * @param {number} [energyThreshold=-60] threshold in dB to detect silent subframes\r\n    * @param {number} [frameSize=512] the expected size of the input audio signal (this is an optional parameter to optimize memory allocation)\r\n    * @param {number} [hopSize=256] hop size used for the analysis. This parameter must be set correctly as it cannot be obtained from the input data\r\n    * @param {number} [kernelSize=7] scalar giving the size of the median filter window. Must be odd\r\n    * @param {number} [order=3] scalar giving the number of LPCs to use\r\n    * @param {number} [silenceThreshold=-50] threshold to skip silent frames\r\n    * @param {number} [subFrameSize=32] size of the window used to compute silent subframes\r\n    * @returns {object} {discontinuityLocations: 'the index of the detected discontinuities (if any)', discontinuityAmplitudes: 'the peak values of the prediction error for the discontinuities (if any)'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.DiscontinuityDetector = function (frame, detectionThreshold, energyThreshold, frameSize, hopSize, kernelSize, order, silenceThreshold, subFrameSize) {\r\n        if (detectionThreshold === void 0) { detectionThreshold = 8; }\r\n        if (energyThreshold === void 0) { energyThreshold = -60; }\r\n        if (frameSize === void 0) { frameSize = 512; }\r\n        if (hopSize === void 0) { hopSize = 256; }\r\n        if (kernelSize === void 0) { kernelSize = 7; }\r\n        if (order === void 0) { order = 3; }\r\n        if (silenceThreshold === void 0) { silenceThreshold = -50; }\r\n        if (subFrameSize === void 0) { subFrameSize = 32; }\r\n        return this.algorithms.DiscontinuityDetector(frame, detectionThreshold, energyThreshold, frameSize, hopSize, kernelSize, order, silenceThreshold, subFrameSize);\r\n    };\r\n    /**\r\n    * This algorithm computes the sensory dissonance of an audio signal given its spectral peaks. Sensory dissonance (to be distinguished from musical or theoretical dissonance) measures perceptual roughness of the sound and is based on the roughness of its spectral peaks. Given the spectral peaks, the algorithm estimates total dissonance by summing up the normalized dissonance values for each pair of peaks. These values are computed using dissonance curves, which define dissonace between two spectral peaks according to their frequency and amplitude relations. The dissonance curves are based on perceptual experiments conducted in [1].\r\n    Exceptions are thrown when the size of the input vectors are not equal or if input frequencies are not ordered ascendantly\r\n    References:\r\n      [1] R. Plomp and W. J. M. Levelt, \"Tonal Consonance and Critical\r\n      Bandwidth,\" The Journal of the Acoustical Society of America, vol. 38,\r\n      no. 4, pp. 548–560, 1965. Check https://essentia.upf.edu/reference/std_Dissonance.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frequencies the frequencies of the spectral peaks (must be sorted by frequency)\r\n    * @param {VectorFloat} magnitudes the magnitudes of the spectral peaks (must be sorted by frequency\r\n    * @returns {object} {dissonance: 'the dissonance of the audio signal (0 meaning completely consonant, and 1 meaning completely dissonant)'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Dissonance = function (frequencies, magnitudes) {\r\n        return this.algorithms.Dissonance(frequencies, magnitudes);\r\n    };\r\n    /**\r\n    * This algorithm computes the spread (variance), skewness and kurtosis of an array given its central moments. The extracted features are good indicators of the shape of the distribution. For the required input see CentralMoments algorithm.\r\n    The size of the input array must be at least 5. An exception will be thrown otherwise. Check https://essentia.upf.edu/reference/std_DistributionShape.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} centralMoments the central moments of a distribution\r\n    * @returns {object} {spread: 'the spread (variance) of the distribution', skewness: 'the skewness of the distribution', kurtosis: 'the kurtosis of the distribution'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.DistributionShape = function (centralMoments) {\r\n        return this.algorithms.DistributionShape(centralMoments);\r\n    };\r\n    /**\r\n    * This algorithm outputs the total duration of an audio signal. Check https://essentia.upf.edu/reference/std_Duration.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {duration: 'the duration of the signal [s]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Duration = function (signal, sampleRate) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.Duration(signal, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the dynamic complexity defined as the average absolute deviation from the global loudness level estimate on the dB scale. It is related to the dynamic range and to the amount of fluctuation in loudness present in a recording. Silence at the beginning and at the end of a track are ignored in the computation in order not to deteriorate the results. Check https://essentia.upf.edu/reference/std_DynamicComplexity.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio signal\r\n    * @param {number} [frameSize=0.2] the frame size [s]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {dynamicComplexity: 'the dynamic complexity coefficient', loudness: 'an estimate of the loudness [dB]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.DynamicComplexity = function (signal, frameSize, sampleRate) {\r\n        if (frameSize === void 0) { frameSize = 0.2; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.DynamicComplexity(signal, frameSize, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes energies/magnitudes in ERB bands of a spectrum. The Equivalent Rectangular Bandwidth (ERB) scale is used. The algorithm applies a frequency domain filterbank using gammatone filters. Adapted from matlab code in:  D. P. W. Ellis (2009). 'Gammatone-like spectrograms', web resource [1]. Check https://essentia.upf.edu/reference/std_ERBBands.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the audio spectrum\r\n    * @param {number} [highFrequencyBound=22050] an upper-bound limit for the frequencies to be included in the bands\r\n    * @param {number} [inputSize=1025] the size of the spectrum\r\n    * @param {number} [lowFrequencyBound=50] a lower-bound limit for the frequencies to be included in the bands\r\n    * @param {number} [numberBands=40] the number of output bands\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {string} [type=power] use magnitude or power spectrum\r\n    * @param {number} [width=1] filter width with respect to ERB\r\n    * @returns {object} {bands: 'the energies/magnitudes of each band'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.ERBBands = function (spectrum, highFrequencyBound, inputSize, lowFrequencyBound, numberBands, sampleRate, type, width) {\r\n        if (highFrequencyBound === void 0) { highFrequencyBound = 22050; }\r\n        if (inputSize === void 0) { inputSize = 1025; }\r\n        if (lowFrequencyBound === void 0) { lowFrequencyBound = 50; }\r\n        if (numberBands === void 0) { numberBands = 40; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (type === void 0) { type = 'power'; }\r\n        if (width === void 0) { width = 1; }\r\n        return this.algorithms.ERBBands(spectrum, highFrequencyBound, inputSize, lowFrequencyBound, numberBands, sampleRate, type, width);\r\n    };\r\n    /**\r\n    * This algorithm computes the effective duration of an envelope signal. The effective duration is a measure of the time the signal is perceptually meaningful. This is approximated by the time the envelope is above or equal to a given threshold and is above the -90db noise floor. This measure allows to distinguish percussive sounds from sustained sounds but depends on the signal length.\r\n    By default, this algorithm uses 40% of the envelope maximum as the threshold which is suited for short sounds. Note, that the 0% thresold corresponds to the duration of signal above -90db noise floor, while the 100% thresold corresponds to the number of times the envelope takes its maximum value.\r\n    References:\r\n      [1] G. Peeters, \"A large set of audio features for sound description\r\n      (similarity and classification) in the CUIDADO project,\" CUIDADO I.S.T.\r\n      Project Report, 2004 Check https://essentia.upf.edu/reference/std_EffectiveDuration.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [thresholdRatio=0.4] the ratio of the envelope maximum to be used as the threshold\r\n    * @returns {object} {effectiveDuration: 'the effective duration of the signal [s]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.EffectiveDuration = function (signal, sampleRate, thresholdRatio) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (thresholdRatio === void 0) { thresholdRatio = 0.4; }\r\n        return this.algorithms.EffectiveDuration(signal, sampleRate, thresholdRatio);\r\n    };\r\n    /**\r\n    * This algorithm computes the energy of an array. Check https://essentia.upf.edu/reference/std_Energy.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @returns {object} {energy: 'the energy of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Energy = function (array) {\r\n        return this.algorithms.Energy(array);\r\n    };\r\n    /**\r\n    * This algorithm computes energy in a given frequency band of a spectrum including both start and stop cutoff frequencies.\r\n    Note that exceptions will be thrown when input spectrum is empty and if startCutoffFrequency is greater than stopCutoffFrequency. Check https://essentia.upf.edu/reference/std_EnergyBand.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input frequency spectrum\r\n    * @param {number} [sampleRate=44100] the audio sampling rate [Hz]\r\n    * @param {number} [startCutoffFrequency=0] the start frequency from which to sum the energy [Hz]\r\n    * @param {number} [stopCutoffFrequency=100] the stop frequency to which to sum the energy [Hz]\r\n    * @returns {object} {energyBand: 'the energy in the frequency band'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.EnergyBand = function (spectrum, sampleRate, startCutoffFrequency, stopCutoffFrequency) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (startCutoffFrequency === void 0) { startCutoffFrequency = 0; }\r\n        if (stopCutoffFrequency === void 0) { stopCutoffFrequency = 100; }\r\n        return this.algorithms.EnergyBand(spectrum, sampleRate, startCutoffFrequency, stopCutoffFrequency);\r\n    };\r\n    /**\r\n    * This algorithm computes the ratio of the spectral energy in the range [startFrequency, stopFrequency] over the total energy. Check https://essentia.upf.edu/reference/std_EnergyBandRatio.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input audio spectrum\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [startFrequency=0] the frequency from which to start summing the energy [Hz]\r\n    * @param {number} [stopFrequency=100] the frequency up to which to sum the energy [Hz]\r\n    * @returns {object} {energyBandRatio: 'the energy ratio of the specified band over the total energy'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.EnergyBandRatio = function (spectrum, sampleRate, startFrequency, stopFrequency) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (startFrequency === void 0) { startFrequency = 0; }\r\n        if (stopFrequency === void 0) { stopFrequency = 100; }\r\n        return this.algorithms.EnergyBandRatio(spectrum, sampleRate, startFrequency, stopFrequency);\r\n    };\r\n    /**\r\n    * This algorithm computes the Shannon entropy of an array. Entropy can be used to quantify the peakiness of a distribution. This has been used for voiced/unvoiced decision in automatic speech recognition.  Check https://essentia.upf.edu/reference/std_Entropy.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array (cannot contain negative values, and must be non-empty)\r\n    * @returns {object} {entropy: 'the entropy of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Entropy = function (array) {\r\n        return this.algorithms.Entropy(array);\r\n    };\r\n    /**\r\n    * This algorithm computes the envelope of a signal by applying a non-symmetric lowpass filter on a signal. By default it rectifies the signal, but that is optional. Check https://essentia.upf.edu/reference/std_Envelope.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {boolean} [applyRectification=true] whether to apply rectification (envelope based on the absolute value of signal)\r\n    * @param {number} [attackTime=10] the attack time of the first order lowpass in the attack phase [ms]\r\n    * @param {number} [releaseTime=1500] the release time of the first order lowpass in the release phase [ms]\r\n    * @param {number} [sampleRate=44100] the audio sampling rate [Hz]\r\n    * @returns {object} {signal: 'the resulting envelope of the signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Envelope = function (signal, applyRectification, attackTime, releaseTime, sampleRate) {\r\n        if (applyRectification === void 0) { applyRectification = true; }\r\n        if (attackTime === void 0) { attackTime = 10; }\r\n        if (releaseTime === void 0) { releaseTime = 1500; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.Envelope(signal, applyRectification, attackTime, releaseTime, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm implements an equal-loudness filter. The human ear does not perceive sounds of all frequencies as having equal loudness, and to account for this, the signal is filtered by an inverted approximation of the equal-loudness curves. Technically, the filter is a cascade of a 10th order Yulewalk filter with a 2nd order Butterworth high pass filter. Check https://essentia.upf.edu/reference/std_EqualLoudness.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {signal: 'the filtered signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.EqualLoudness = function (signal, sampleRate) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.EqualLoudness(signal, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the flatness of an array, which is defined as the ratio between the geometric mean and the arithmetic mean. Check https://essentia.upf.edu/reference/std_Flatness.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @returns {object} {flatness: 'the flatness (ratio between the geometric and the arithmetic mean of the input array)'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Flatness = function (array) {\r\n        return this.algorithms.Flatness(array);\r\n    };\r\n    /**\r\n    * This algorithm computes the flatness of an array, which is defined as the ratio between the geometric mean and the arithmetic mean converted to dB scale. Check https://essentia.upf.edu/reference/std_FlatnessDB.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @returns {object} {flatnessDB: 'the flatness dB'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.FlatnessDB = function (array) {\r\n        return this.algorithms.FlatnessDB(array);\r\n    };\r\n    /**\r\n    * This algorithm calculates the flatness coefficient of a signal envelope. Check https://essentia.upf.edu/reference/std_FlatnessSFX.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} envelope the envelope of the signal\r\n    * @returns {object} {flatness: 'the flatness coefficient'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.FlatnessSFX = function (envelope) {\r\n        return this.algorithms.FlatnessSFX(envelope);\r\n    };\r\n    /**\r\n    * This algorithm computes the spectral flux of a spectrum. Flux is defined as the L2-norm [1] or L1-norm [2] of the difference between two consecutive frames of the magnitude spectrum. The frames have to be of the same size in order to yield a meaningful result. The default L2-norm is used more commonly. Check https://essentia.upf.edu/reference/std_Flux.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input spectrum\r\n    * @param {boolean} [halfRectify=false] half-rectify the differences in each spectrum bin\r\n    * @param {string} [norm=L2] the norm to use for difference computation\r\n    * @returns {object} {flux: 'the spectral flux of the input spectrum'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Flux = function (spectrum, halfRectify, norm) {\r\n        if (halfRectify === void 0) { halfRectify = false; }\r\n        if (norm === void 0) { norm = 'L2'; }\r\n        return this.algorithms.Flux(spectrum, halfRectify, norm);\r\n    };\r\n    /**\r\n    * This algorithm slices the input buffer into frames. It returns a frame of a constant size and jumps a constant amount of samples forward in the buffer on every compute() call until no more frames can be extracted; empty frame vectors are returned afterwards. Incomplete frames (frames starting before the beginning of the input buffer or going past its end) are zero-padded or dropped according to the \"validFrameThresholdRatio\" parameter. Check https://essentia.upf.edu/reference/std_FrameCutter.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the buffer from which to read data\r\n    * @param {number} [frameSize=1024] the output frame size\r\n    * @param {number} [hopSize=512] the hop size between frames\r\n    * @param {boolean} [lastFrameToEndOfFile=false] whether the beginning of the last frame should reach the end of file. Only applicable if startFromZero is true\r\n    * @param {boolean} [startFromZero=false] whether to start the first frame at time 0 (centered at frameSize/2) if true, or -frameSize/2 otherwise (zero-centered)\r\n    * @param {number} [validFrameThresholdRatio=0] frames smaller than this ratio will be discarded, those larger will be zero-padded to a full frame (i.e. a value of 0 will never discard frames and a value of 1 will only keep frames that are of length 'frameSize')\r\n    * @returns {object} {frame: 'the frame to write to'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.FrameCutter = function (signal, frameSize, hopSize, lastFrameToEndOfFile, startFromZero, validFrameThresholdRatio) {\r\n        if (frameSize === void 0) { frameSize = 1024; }\r\n        if (hopSize === void 0) { hopSize = 512; }\r\n        if (lastFrameToEndOfFile === void 0) { lastFrameToEndOfFile = false; }\r\n        if (startFromZero === void 0) { startFromZero = false; }\r\n        if (validFrameThresholdRatio === void 0) { validFrameThresholdRatio = 0; }\r\n        return this.algorithms.FrameCutter(signal, frameSize, hopSize, lastFrameToEndOfFile, startFromZero, validFrameThresholdRatio);\r\n    };\r\n    /**\r\n    * This algorithm converts a sequence of input audio signal frames into a sequence of audio samples. Check https://essentia.upf.edu/reference/std_FrameToReal.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio frame\r\n    * @param {number} [frameSize=2048] the frame size for computing the overlap-add process\r\n    * @param {number} [hopSize=128] the hop size with which the overlap-add function is computed\r\n    * @returns {object} {signal: 'the output audio samples'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.FrameToReal = function (signal, frameSize, hopSize) {\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (hopSize === void 0) { hopSize = 128; }\r\n        return this.algorithms.FrameToReal(signal, frameSize, hopSize);\r\n    };\r\n    /**\r\n    * This algorithm computes energy in rectangular frequency bands of a spectrum. The bands are non-overlapping. For each band the power-spectrum (mag-squared) is summed. Check https://essentia.upf.edu/reference/std_FrequencyBands.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input spectrum (must be greater than size one)\r\n    * @param {any[]} [frequencyBands=[0, 50, 100, 150, 200, 300, 400, 510, 630, 770, 920, 1080, 1270, 1480, 1720, 2000, 2320, 2700, 3150, 3700, 4400, 5300, 6400, 7700, 9500, 12000, 15500, 20500, 27000]] list of frequency ranges in to which the spectrum is divided (these must be in ascending order and connot contain duplicates)\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {bands: 'the energy in each band'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.FrequencyBands = function (spectrum, frequencyBands, sampleRate) {\r\n        if (frequencyBands === void 0) { frequencyBands = [0, 50, 100, 150, 200, 300, 400, 510, 630, 770, 920, 1080, 1270, 1480, 1720, 2000, 2320, 2700, 3150, 3700, 4400, 5300, 6400, 7700, 9500, 12000, 15500, 20500, 27000]; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        var vecfrequencyBands = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecfrequencyBands.size(); i++) {\r\n            vecfrequencyBands.push_back(frequencyBands[i]);\r\n        }\r\n        return this.algorithms.FrequencyBands(spectrum, vecfrequencyBands, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the Gammatone-frequency cepstral coefficients of a spectrum. This is an equivalent of MFCCs, but using a gammatone filterbank (ERBBands) scaled on an Equivalent Rectangular Bandwidth (ERB) scale. Check https://essentia.upf.edu/reference/std_GFCC.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the audio spectrum\r\n    * @param {number} [dctType=2] the DCT type\r\n    * @param {number} [highFrequencyBound=22050] the upper bound of the frequency range [Hz]\r\n    * @param {number} [inputSize=1025] the size of input spectrum\r\n    * @param {string} [logType=dbamp] logarithmic compression type. Use 'dbpow' if working with power and 'dbamp' if working with magnitudes\r\n    * @param {number} [lowFrequencyBound=40] the lower bound of the frequency range [Hz]\r\n    * @param {number} [numberBands=40] the number of bands in the filter\r\n    * @param {number} [numberCoefficients=13] the number of output cepstrum coefficients\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [silenceThreshold=1e-10] silence threshold for computing log-energy bands\r\n    * @param {string} [type=power] use magnitude or power spectrum\r\n    * @returns {object} {bands: 'the energies in ERB bands', gfcc: 'the gammatone feature cepstrum coefficients'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.GFCC = function (spectrum, dctType, highFrequencyBound, inputSize, logType, lowFrequencyBound, numberBands, numberCoefficients, sampleRate, silenceThreshold, type) {\r\n        if (dctType === void 0) { dctType = 2; }\r\n        if (highFrequencyBound === void 0) { highFrequencyBound = 22050; }\r\n        if (inputSize === void 0) { inputSize = 1025; }\r\n        if (logType === void 0) { logType = 'dbamp'; }\r\n        if (lowFrequencyBound === void 0) { lowFrequencyBound = 40; }\r\n        if (numberBands === void 0) { numberBands = 40; }\r\n        if (numberCoefficients === void 0) { numberCoefficients = 13; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (silenceThreshold === void 0) { silenceThreshold = 1e-10; }\r\n        if (type === void 0) { type = 'power'; }\r\n        return this.algorithms.GFCC(spectrum, dctType, highFrequencyBound, inputSize, logType, lowFrequencyBound, numberBands, numberCoefficients, sampleRate, silenceThreshold, type);\r\n    };\r\n    /**\r\n    * This algorithm uses energy and time thresholds to detect gaps in the waveform. A median filter is used to remove spurious silent samples. The power of a small audio region before the detected gaps (prepower) is thresholded to detect intentional pauses as described in [1]. This technique isextended to the region after the gap.\r\n    The algorithm was designed for a framewise use and returns the start and end timestamps related to the first frame processed. Call configure() or reset() in order to restart the count. Check https://essentia.upf.edu/reference/std_GapsDetector.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input frame (must be non-empty)\r\n    * @param {number} [attackTime=0.05] the attack time of the first order lowpass in the attack phase [ms]\r\n    * @param {number} [frameSize=2048] frame size used for the analysis. Should match the input frame size. Otherwise, an exception will be thrown\r\n    * @param {number} [hopSize=1024] hop size used for the analysis\r\n    * @param {number} [kernelSize=11] scalar giving the size of the median filter window. Must be odd\r\n    * @param {number} [maximumTime=3500] time of the maximum gap duration [ms]\r\n    * @param {number} [minimumTime=10] time of the minimum gap duration [ms]\r\n    * @param {number} [postpowerTime=40] time for the postpower calculation [ms]\r\n    * @param {number} [prepowerThreshold=-30] prepower threshold [dB].\r\n    * @param {number} [prepowerTime=40] time for the prepower calculation [ms]\r\n    * @param {number} [releaseTime=0.05] the release time of the first order lowpass in the release phase [ms]\r\n    * @param {number} [sampleRate=44100] sample rate used for the analysis\r\n    * @param {number} [silenceThreshold=-50] silence threshold [dB]\r\n    * @returns {object} {starts: 'the start indexes of the detected gaps (if any) in seconds', ends: 'the end indexes of the detected gaps (if any) in seconds'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.GapsDetector = function (frame, attackTime, frameSize, hopSize, kernelSize, maximumTime, minimumTime, postpowerTime, prepowerThreshold, prepowerTime, releaseTime, sampleRate, silenceThreshold) {\r\n        if (attackTime === void 0) { attackTime = 0.05; }\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (hopSize === void 0) { hopSize = 1024; }\r\n        if (kernelSize === void 0) { kernelSize = 11; }\r\n        if (maximumTime === void 0) { maximumTime = 3500; }\r\n        if (minimumTime === void 0) { minimumTime = 10; }\r\n        if (postpowerTime === void 0) { postpowerTime = 40; }\r\n        if (prepowerThreshold === void 0) { prepowerThreshold = -30; }\r\n        if (prepowerTime === void 0) { prepowerTime = 40; }\r\n        if (releaseTime === void 0) { releaseTime = 0.05; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (silenceThreshold === void 0) { silenceThreshold = -50; }\r\n        return this.algorithms.GapsDetector(frame, attackTime, frameSize, hopSize, kernelSize, maximumTime, minimumTime, postpowerTime, prepowerThreshold, prepowerTime, releaseTime, sampleRate, silenceThreshold);\r\n    };\r\n    /**\r\n    * This algorithm computes the geometric mean of an array of positive values. Check https://essentia.upf.edu/reference/std_GeometricMean.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @returns {object} {geometricMean: 'the geometric mean of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.GeometricMean = function (array) {\r\n        return this.algorithms.GeometricMean(array);\r\n    };\r\n    /**\r\n    * This algorithm computes the High Frequency Content of a spectrum. It can be computed according to the following techniques:\r\n      - 'Masri' (default) which does: sum |X(n)|^2*k,\r\n      - 'Jensen' which does: sum |X(n)|*k^2\r\n      - 'Brossier' which does: sum |X(n)|*k Check https://essentia.upf.edu/reference/std_HFC.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input audio spectrum\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {string} [type=Masri] the type of HFC coefficient to be computed\r\n    * @returns {object} {hfc: 'the high-frequency coefficient'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.HFC = function (spectrum, sampleRate, type) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (type === void 0) { type = 'Masri'; }\r\n        return this.algorithms.HFC(spectrum, sampleRate, type);\r\n    };\r\n    /**\r\n    * Computes a Harmonic Pitch Class Profile (HPCP) from the spectral peaks of a signal. HPCP is a k*12 dimensional vector which represents the intensities of the twelve (k==1) semitone pitch classes (corresponsing to notes from A to G#), or subdivisions of these (k>1). Check https://essentia.upf.edu/reference/std_HPCP.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frequencies the frequencies of the spectral peaks [Hz]\r\n    * @param {VectorFloat} magnitudes the magnitudes of the spectral peaks\r\n    * @param {boolean} [bandPreset=true] enables whether to use a band preset\r\n    * @param {number} [bandSplitFrequency=500] the split frequency for low and high bands, not used if bandPreset is false [Hz]\r\n    * @param {number} [harmonics=0] number of harmonics for frequency contribution, 0 indicates exclusive fundamental frequency contribution\r\n    * @param {number} [maxFrequency=5000] the maximum frequency that contributes to the HPCP [Hz] (the difference between the max and split frequencies must not be less than 200.0 Hz)\r\n    * @param {boolean} [maxShifted=false] whether to shift the HPCP vector so that the maximum peak is at index 0\r\n    * @param {number} [minFrequency=40] the minimum frequency that contributes to the HPCP [Hz] (the difference between the min and split frequencies must not be less than 200.0 Hz)\r\n    * @param {boolean} [nonLinear=false] apply non-linear post-processing to the output (use with normalized='unitMax'). Boosts values close to 1, decreases values close to 0.\r\n    * @param {string} [normalized=unitMax] whether to normalize the HPCP vector\r\n    * @param {number} [referenceFrequency=440] the reference frequency for semitone index calculation, corresponding to A3 [Hz]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [size=12] the size of the output HPCP (must be a positive nonzero multiple of 12)\r\n    * @param {string} [weightType=squaredCosine] type of weighting function for determining frequency contribution\r\n    * @param {number} [windowSize=1] the size, in semitones, of the window used for the weighting\r\n    * @returns {object} {hpcp: 'the resulting harmonic pitch class profile'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.HPCP = function (frequencies, magnitudes, bandPreset, bandSplitFrequency, harmonics, maxFrequency, maxShifted, minFrequency, nonLinear, normalized, referenceFrequency, sampleRate, size, weightType, windowSize) {\r\n        if (bandPreset === void 0) { bandPreset = true; }\r\n        if (bandSplitFrequency === void 0) { bandSplitFrequency = 500; }\r\n        if (harmonics === void 0) { harmonics = 0; }\r\n        if (maxFrequency === void 0) { maxFrequency = 5000; }\r\n        if (maxShifted === void 0) { maxShifted = false; }\r\n        if (minFrequency === void 0) { minFrequency = 40; }\r\n        if (nonLinear === void 0) { nonLinear = false; }\r\n        if (normalized === void 0) { normalized = 'unitMax'; }\r\n        if (referenceFrequency === void 0) { referenceFrequency = 440; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (size === void 0) { size = 12; }\r\n        if (weightType === void 0) { weightType = 'squaredCosine'; }\r\n        if (windowSize === void 0) { windowSize = 1; }\r\n        return this.algorithms.HPCP(frequencies, magnitudes, bandPreset, bandSplitFrequency, harmonics, maxFrequency, maxShifted, minFrequency, nonLinear, normalized, referenceFrequency, sampleRate, size, weightType, windowSize);\r\n    };\r\n    /**\r\n    * This algorithm extracts bpms that are harmonically related to the tempo given by the 'bpm' parameter.\r\n    The algorithm assumes a certain bpm is harmonically related to parameter bpm, when the greatest common divisor between both bpms is greater than threshold.\r\n    The 'tolerance' parameter is needed in order to consider if two bpms are related. For instance, 120, 122 and 236 may be related or not depending on how much tolerance is given Check https://essentia.upf.edu/reference/std_HarmonicBpm.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} bpms list of bpm candidates\r\n    * @param {number} [bpm=60] the bpm used to find its harmonics\r\n    * @param {number} [threshold=20] bpm threshold below which greatest common divisors are discarded\r\n    * @param {number} [tolerance=5] percentage tolerance to consider two bpms are equal or equal to a harmonic\r\n    * @returns {object} {harmonicBpms: 'a list of bpms which are harmonically related to the bpm parameter '}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.HarmonicBpm = function (bpms, bpm, threshold, tolerance) {\r\n        if (bpm === void 0) { bpm = 60; }\r\n        if (threshold === void 0) { threshold = 20; }\r\n        if (tolerance === void 0) { tolerance = 5; }\r\n        return this.algorithms.HarmonicBpm(bpms, bpm, threshold, tolerance);\r\n    };\r\n    /**\r\n    * This algorithm finds the harmonic peaks of a signal given its spectral peaks and its fundamental frequency.\r\n    Note:\r\n      - \"tolerance\" parameter defines the allowed fixed deviation from ideal harmonics, being a percentage over the F0. For example: if the F0 is 100Hz you may decide to allow a deviation of 20%, that is a fixed deviation of 20Hz; for the harmonic series it is: [180-220], [280-320], [380-420], etc.\r\n      - If \"pitch\" is zero, it means its value is unknown, or the sound is unpitched, and in that case the HarmonicPeaks algorithm returns an empty vector.\r\n      - The output frequency and magnitude vectors are of size \"maxHarmonics\". If a particular harmonic was not found among spectral peaks, its ideal frequency value is output together with 0 magnitude.\r\n    This algorithm is intended to receive its \"frequencies\" and \"magnitudes\" inputs from the SpectralPeaks algorithm.\r\n      - When input vectors differ in size or are empty, an exception is thrown. Input vectors must be ordered by ascending frequency excluding DC components and not contain duplicates, otherwise an exception is thrown. Check https://essentia.upf.edu/reference/std_HarmonicPeaks.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frequencies the frequencies of the spectral peaks [Hz] (ascending order)\r\n    * @param {VectorFloat} magnitudes the magnitudes of the spectral peaks (ascending frequency order)\r\n    * @param {number} pitch an estimate of the fundamental frequency of the signal [Hz]\r\n    * @param {number} [maxHarmonics=20] the number of harmonics to return including F0\r\n    * @param {number} [tolerance=0.2] the allowed ratio deviation from ideal harmonics\r\n    * @returns {object} {harmonicFrequencies: 'the frequencies of harmonic peaks [Hz]', harmonicMagnitudes: 'the magnitudes of harmonic peaks'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.HarmonicPeaks = function (frequencies, magnitudes, pitch, maxHarmonics, tolerance) {\r\n        if (maxHarmonics === void 0) { maxHarmonics = 20; }\r\n        if (tolerance === void 0) { tolerance = 0.2; }\r\n        return this.algorithms.HarmonicPeaks(frequencies, magnitudes, pitch, maxHarmonics, tolerance);\r\n    };\r\n    /**\r\n    * This algorithm implements a 1st order IIR high-pass filter. Because of its dependence on IIR, IIR's requirements are inherited. Check https://essentia.upf.edu/reference/std_HighPass.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio signal\r\n    * @param {number} [cutoffFrequency=1500] the cutoff frequency for the filter [Hz]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {signal: 'the filtered signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.HighPass = function (signal, cutoffFrequency, sampleRate) {\r\n        if (cutoffFrequency === void 0) { cutoffFrequency = 1500; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.HighPass(signal, cutoffFrequency, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes high-resolution chroma features from an HPCP vector. The vector's size must be a multiple of 12 and it is recommended that it be larger than 120. In otherwords, the HPCP's resolution should be 10 Cents or more.\r\n    The high-resolution features being computed are: Check https://essentia.upf.edu/reference/std_HighResolutionFeatures.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} hpcp the HPCPs, preferably of size >= 120\r\n    * @param {number} [maxPeaks=24] maximum number of HPCP peaks to consider when calculating outputs\r\n    * @returns {object} {equalTemperedDeviation: 'measure of the deviation of HPCP local maxima with respect to equal-tempered bins', nonTemperedEnergyRatio: 'ratio between the energy on non-tempered bins and the total energy', nonTemperedPeaksEnergyRatio: 'ratio between the energy on non-tempered peaks and the total energy'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.HighResolutionFeatures = function (hpcp, maxPeaks) {\r\n        if (maxPeaks === void 0) { maxPeaks = 24; }\r\n        return this.algorithms.HighResolutionFeatures(hpcp, maxPeaks);\r\n    };\r\n    /**\r\n    * This algorithm computes a histogram. Values outside the range are ignored Check https://essentia.upf.edu/reference/std_Histogram.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @param {number} [maxValue=1] the max value of the histogram\r\n    * @param {number} [minValue=0] the min value of the histogram\r\n    * @param {string} [normalize=none] the normalization setting.\r\n    * @param {number} [numberBins=10] the number of bins\r\n    * @returns {object} {histogram: 'the values in the equally-spaced bins', binEdges: 'the edges of the equally-spaced bins. Size is _histogram.size() + 1'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Histogram = function (array, maxValue, minValue, normalize, numberBins) {\r\n        if (maxValue === void 0) { maxValue = 1; }\r\n        if (minValue === void 0) { minValue = 0; }\r\n        if (normalize === void 0) { normalize = 'none'; }\r\n        if (numberBins === void 0) { numberBins = 10; }\r\n        return this.algorithms.Histogram(array, maxValue, minValue, normalize, numberBins);\r\n    };\r\n    /**\r\n    * This algorithm computes the harmonic plus residual model analysis. Check https://essentia.upf.edu/reference/std_HprModelAnal.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input frame\r\n    * @param {number} pitch external pitch input [Hz].\r\n    * @param {number} [fftSize=2048] the size of the internal FFT size (full spectrum size)\r\n    * @param {number} [freqDevOffset=20] minimum frequency deviation at 0Hz\r\n    * @param {number} [freqDevSlope=0.01] slope increase of minimum frequency deviation\r\n    * @param {number} [harmDevSlope=0.01] slope increase of minimum frequency deviation\r\n    * @param {number} [hopSize=512] the hop size between frames\r\n    * @param {number} [magnitudeThreshold=0] peaks below this given threshold are not outputted\r\n    * @param {number} [maxFrequency=5000] the maximum frequency of the range to evaluate [Hz]\r\n    * @param {number} [maxPeaks=100] the maximum number of returned peaks\r\n    * @param {number} [maxnSines=100] maximum number of sines per frame\r\n    * @param {number} [minFrequency=20] the minimum frequency of the range to evaluate [Hz]\r\n    * @param {number} [nHarmonics=100] maximum number of harmonics per frame\r\n    * @param {string} [orderBy=frequency] the ordering type of the outputted peaks (ascending by frequency or descending by magnitude)\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [stocf=0.2] decimation factor used for the stochastic approximation\r\n    * @returns {object} {frequencies: 'the frequencies of the sinusoidal peaks [Hz]', magnitudes: 'the magnitudes of the sinusoidal peaks', phases: 'the phases of the sinusoidal peaks', res: 'output residual frame'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.HprModelAnal = function (frame, pitch, fftSize, freqDevOffset, freqDevSlope, harmDevSlope, hopSize, magnitudeThreshold, maxFrequency, maxPeaks, maxnSines, minFrequency, nHarmonics, orderBy, sampleRate, stocf) {\r\n        if (fftSize === void 0) { fftSize = 2048; }\r\n        if (freqDevOffset === void 0) { freqDevOffset = 20; }\r\n        if (freqDevSlope === void 0) { freqDevSlope = 0.01; }\r\n        if (harmDevSlope === void 0) { harmDevSlope = 0.01; }\r\n        if (hopSize === void 0) { hopSize = 512; }\r\n        if (magnitudeThreshold === void 0) { magnitudeThreshold = 0; }\r\n        if (maxFrequency === void 0) { maxFrequency = 5000; }\r\n        if (maxPeaks === void 0) { maxPeaks = 100; }\r\n        if (maxnSines === void 0) { maxnSines = 100; }\r\n        if (minFrequency === void 0) { minFrequency = 20; }\r\n        if (nHarmonics === void 0) { nHarmonics = 100; }\r\n        if (orderBy === void 0) { orderBy = 'frequency'; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (stocf === void 0) { stocf = 0.2; }\r\n        return this.algorithms.HprModelAnal(frame, pitch, fftSize, freqDevOffset, freqDevSlope, harmDevSlope, hopSize, magnitudeThreshold, maxFrequency, maxPeaks, maxnSines, minFrequency, nHarmonics, orderBy, sampleRate, stocf);\r\n    };\r\n    /**\r\n    * This algorithm computes the harmonic plus stochastic model analysis.  Check https://essentia.upf.edu/reference/std_HpsModelAnal.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input frame\r\n    * @param {number} pitch external pitch input [Hz].\r\n    * @param {number} [fftSize=2048] the size of the internal FFT size (full spectrum size)\r\n    * @param {number} [freqDevOffset=20] minimum frequency deviation at 0Hz\r\n    * @param {number} [freqDevSlope=0.01] slope increase of minimum frequency deviation\r\n    * @param {number} [harmDevSlope=0.01] slope increase of minimum frequency deviation\r\n    * @param {number} [hopSize=512] the hop size between frames\r\n    * @param {number} [magnitudeThreshold=0] peaks below this given threshold are not outputted\r\n    * @param {number} [maxFrequency=5000] the maximum frequency of the range to evaluate [Hz]\r\n    * @param {number} [maxPeaks=100] the maximum number of returned peaks\r\n    * @param {number} [maxnSines=100] maximum number of sines per frame\r\n    * @param {number} [minFrequency=20] the minimum frequency of the range to evaluate [Hz]\r\n    * @param {number} [nHarmonics=100] maximum number of harmonics per frame\r\n    * @param {string} [orderBy=frequency] the ordering type of the outputted peaks (ascending by frequency or descending by magnitude)\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [stocf=0.2] decimation factor used for the stochastic approximation\r\n    * @returns {object} {frequencies: 'the frequencies of the sinusoidal peaks [Hz]', magnitudes: 'the magnitudes of the sinusoidal peaks', phases: 'the phases of the sinusoidal peaks', stocenv: 'the stochastic envelope'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.HpsModelAnal = function (frame, pitch, fftSize, freqDevOffset, freqDevSlope, harmDevSlope, hopSize, magnitudeThreshold, maxFrequency, maxPeaks, maxnSines, minFrequency, nHarmonics, orderBy, sampleRate, stocf) {\r\n        if (fftSize === void 0) { fftSize = 2048; }\r\n        if (freqDevOffset === void 0) { freqDevOffset = 20; }\r\n        if (freqDevSlope === void 0) { freqDevSlope = 0.01; }\r\n        if (harmDevSlope === void 0) { harmDevSlope = 0.01; }\r\n        if (hopSize === void 0) { hopSize = 512; }\r\n        if (magnitudeThreshold === void 0) { magnitudeThreshold = 0; }\r\n        if (maxFrequency === void 0) { maxFrequency = 5000; }\r\n        if (maxPeaks === void 0) { maxPeaks = 100; }\r\n        if (maxnSines === void 0) { maxnSines = 100; }\r\n        if (minFrequency === void 0) { minFrequency = 20; }\r\n        if (nHarmonics === void 0) { nHarmonics = 100; }\r\n        if (orderBy === void 0) { orderBy = 'frequency'; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (stocf === void 0) { stocf = 0.2; }\r\n        return this.algorithms.HpsModelAnal(frame, pitch, fftSize, freqDevOffset, freqDevSlope, harmDevSlope, hopSize, magnitudeThreshold, maxFrequency, maxPeaks, maxnSines, minFrequency, nHarmonics, orderBy, sampleRate, stocf);\r\n    };\r\n    /**\r\n    * This algorithm computes the Inverse Discrete Cosine Transform of an array.\r\n    It can be configured to perform the inverse DCT-II form, with the 1/sqrt(2) scaling factor for the first coefficient or the inverse DCT-III form based on the HTK implementation. Check https://essentia.upf.edu/reference/std_IDCT.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} dct the discrete cosine transform\r\n    * @param {number} [dctType=2] the DCT type\r\n    * @param {number} [inputSize=10] the size of the input array\r\n    * @param {number} [liftering=0] the liftering coefficient. Use '0' to bypass it\r\n    * @param {number} [outputSize=10] the number of output coefficients\r\n    * @returns {object} {idct: 'the inverse cosine transform of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.IDCT = function (dct, dctType, inputSize, liftering, outputSize) {\r\n        if (dctType === void 0) { dctType = 2; }\r\n        if (inputSize === void 0) { inputSize = 10; }\r\n        if (liftering === void 0) { liftering = 0; }\r\n        if (outputSize === void 0) { outputSize = 10; }\r\n        return this.algorithms.IDCT(dct, dctType, inputSize, liftering, outputSize);\r\n    };\r\n    /**\r\n    * This algorithm implements a standard IIR filter. It filters the data in the input vector with the filter described by parameter vectors 'numerator' and 'denominator' to create the output filtered vector. In the litterature, the numerator is often referred to as the 'B' coefficients and the denominator as the 'A' coefficients. Check https://essentia.upf.edu/reference/std_IIR.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {any[]} [denominator=[1]] the list of coefficients of the denominator. Often referred to as the A coefficient vector.\r\n    * @param {any[]} [numerator=[1]] the list of coefficients of the numerator. Often referred to as the B coefficient vector.\r\n    * @returns {object} {signal: 'the filtered signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.IIR = function (signal, denominator, numerator) {\r\n        if (denominator === void 0) { denominator = [1]; }\r\n        if (numerator === void 0) { numerator = [1]; }\r\n        var vecdenominator = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecdenominator.size(); i++) {\r\n            vecdenominator.push_back(denominator[i]);\r\n        }\r\n        var vecnumerator = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecnumerator.size(); i++) {\r\n            vecnumerator.push_back(numerator[i]);\r\n        }\r\n        return this.algorithms.IIR(signal, vecdenominator, vecnumerator);\r\n    };\r\n    /**\r\n    * This algorithm calculates the inharmonicity of a signal given its spectral peaks. The inharmonicity value is computed as an energy weighted divergence of the spectral components from their closest multiple of the fundamental frequency. The fundamental frequency is taken as the first spectral peak from the input. The inharmonicity value ranges from 0 (purely harmonic signal) to 1 (inharmonic signal). Check https://essentia.upf.edu/reference/std_Inharmonicity.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frequencies the frequencies of the harmonic peaks [Hz] (in ascending order)\r\n    * @param {VectorFloat} magnitudes the magnitudes of the harmonic peaks (in frequency ascending order\r\n    * @returns {object} {inharmonicity: 'the inharmonicity of the audio signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Inharmonicity = function (frequencies, magnitudes) {\r\n        return this.algorithms.Inharmonicity(frequencies, magnitudes);\r\n    };\r\n    /**\r\n    * This algorithm computes the instant power of an array. That is, the energy of the array over its size. Check https://essentia.upf.edu/reference/std_InstantPower.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @returns {object} {power: 'the instant power of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.InstantPower = function (array) {\r\n        return this.algorithms.InstantPower(array);\r\n    };\r\n    /**\r\n    * This algorithm classifies the input audio signal as either relaxed (-1), moderate (0), or aggressive (1). Check https://essentia.upf.edu/reference/std_Intensity.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio signal\r\n    * @param {number} [sampleRate=44100] the input audio sampling rate [Hz]\r\n    * @returns {object} {intensity: 'the intensity value'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Intensity = function (signal, sampleRate) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.Intensity(signal, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes key estimate given a pitch class profile (HPCP). The algorithm was severely adapted and changed from the original implementation for readability and speed. Check https://essentia.upf.edu/reference/std_Key.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} pcp the input pitch class profile\r\n    * @param {number} [numHarmonics=4] number of harmonics that should contribute to the polyphonic profile (1 only considers the fundamental harmonic)\r\n    * @param {number} [pcpSize=36] number of array elements used to represent a semitone times 12 (this parameter is only a hint, during computation, the size of the input PCP is used instead)\r\n    * @param {string} [profileType=bgate] the type of polyphic profile to use for correlation calculation\r\n    * @param {number} [slope=0.6] value of the slope of the exponential harmonic contribution to the polyphonic profile\r\n    * @param {boolean} [useMajMin=false] use a third profile called 'majmin' for ambiguous tracks [4]. Only avalable for the edma, bgate and braw profiles\r\n    * @param {boolean} [usePolyphony=true] enables the use of polyphonic profiles to define key profiles (this includes the contributions from triads as well as pitch harmonics)\r\n    * @param {boolean} [useThreeChords=true] consider only the 3 main triad chords of the key (T, D, SD) to build the polyphonic profiles\r\n    * @returns {object} {key: 'the estimated key, from A to G', scale: 'the scale of the key (major or minor)', strength: 'the strength of the estimated key', firstToSecondRelativeStrength: 'the relative strength difference between the best estimate and second best estimate of the key'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Key = function (pcp, numHarmonics, pcpSize, profileType, slope, useMajMin, usePolyphony, useThreeChords) {\r\n        if (numHarmonics === void 0) { numHarmonics = 4; }\r\n        if (pcpSize === void 0) { pcpSize = 36; }\r\n        if (profileType === void 0) { profileType = 'bgate'; }\r\n        if (slope === void 0) { slope = 0.6; }\r\n        if (useMajMin === void 0) { useMajMin = false; }\r\n        if (usePolyphony === void 0) { usePolyphony = true; }\r\n        if (useThreeChords === void 0) { useThreeChords = true; }\r\n        return this.algorithms.Key(pcp, numHarmonics, pcpSize, profileType, slope, useMajMin, usePolyphony, useThreeChords);\r\n    };\r\n    /**\r\n    * This algorithm extracts key/scale for an audio signal. It computes HPCP frames for the input signal and applies key estimation using the Key algorithm. Check https://essentia.upf.edu/reference/std_KeyExtractor.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} audio the audio input signal\r\n    * @param {boolean} [averageDetuningCorrection=true] shifts a pcp to the nearest tempered bin\r\n    * @param {number} [frameSize=4096] the framesize for computing tonal features\r\n    * @param {number} [hopSize=4096] the hopsize for computing tonal features\r\n    * @param {number} [hpcpSize=12] the size of the output HPCP (must be a positive nonzero multiple of 12)\r\n    * @param {number} [maxFrequency=3500] max frequency to apply whitening to [Hz]\r\n    * @param {number} [maximumSpectralPeaks=60] the maximum number of spectral peaks\r\n    * @param {number} [minFrequency=25] min frequency to apply whitening to [Hz]\r\n    * @param {number} [pcpThreshold=0.2] pcp bins below this value are set to 0\r\n    * @param {string} [profileType=bgate] the type of polyphic profile to use for correlation calculation\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [spectralPeaksThreshold=0.0001] the threshold for the spectral peaks\r\n    * @param {number} [tuningFrequency=440] the tuning frequency of the input signal\r\n    * @param {string} [weightType=cosine] type of weighting function for determining frequency contribution\r\n    * @param {string} [windowType=hann] the window type, which can be 'hamming', 'hann', 'triangular', 'square' or 'blackmanharrisXX'\r\n    * @returns {object} {key: 'See Key algorithm documentation', scale: 'See Key algorithm documentation', strength: 'See Key algorithm documentation'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.KeyExtractor = function (audio, averageDetuningCorrection, frameSize, hopSize, hpcpSize, maxFrequency, maximumSpectralPeaks, minFrequency, pcpThreshold, profileType, sampleRate, spectralPeaksThreshold, tuningFrequency, weightType, windowType) {\r\n        if (averageDetuningCorrection === void 0) { averageDetuningCorrection = true; }\r\n        if (frameSize === void 0) { frameSize = 4096; }\r\n        if (hopSize === void 0) { hopSize = 4096; }\r\n        if (hpcpSize === void 0) { hpcpSize = 12; }\r\n        if (maxFrequency === void 0) { maxFrequency = 3500; }\r\n        if (maximumSpectralPeaks === void 0) { maximumSpectralPeaks = 60; }\r\n        if (minFrequency === void 0) { minFrequency = 25; }\r\n        if (pcpThreshold === void 0) { pcpThreshold = 0.2; }\r\n        if (profileType === void 0) { profileType = 'bgate'; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (spectralPeaksThreshold === void 0) { spectralPeaksThreshold = 0.0001; }\r\n        if (tuningFrequency === void 0) { tuningFrequency = 440; }\r\n        if (weightType === void 0) { weightType = 'cosine'; }\r\n        if (windowType === void 0) { windowType = 'hann'; }\r\n        return this.algorithms.KeyExtractor(audio, averageDetuningCorrection, frameSize, hopSize, hpcpSize, maxFrequency, maximumSpectralPeaks, minFrequency, pcpThreshold, profileType, sampleRate, spectralPeaksThreshold, tuningFrequency, weightType, windowType);\r\n    };\r\n    /**\r\n    * This algorithm computes Linear Predictive Coefficients and associated reflection coefficients of a signal. Check https://essentia.upf.edu/reference/std_LPC.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input audio frame\r\n    * @param {number} [order=10] the order of the LPC analysis (typically [8,14])\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {string} [type=regular] the type of LPC (regular or warped)\r\n    * @returns {object} {lpc: 'the LPC coefficients', reflection: 'the reflection coefficients'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.LPC = function (frame, order, sampleRate, type) {\r\n        if (order === void 0) { order = 10; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (type === void 0) { type = 'regular'; }\r\n        return this.algorithms.LPC(frame, order, sampleRate, type);\r\n    };\r\n    /**\r\n    * This algorithm estimates the long-term loudness of an audio signal. The LARM model is based on the asymmetrical low-pass filtering of the Peak Program Meter (PPM), combined with Revised Low-frequency B-weighting (RLB) and power mean calculations. LARM has shown to be a reliable and objective loudness estimate of music and speech. Check https://essentia.upf.edu/reference/std_Larm.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the audio input signal\r\n    * @param {number} [attackTime=10] the attack time of the first order lowpass in the attack phase [ms]\r\n    * @param {number} [power=1.5] the power used for averaging\r\n    * @param {number} [releaseTime=1500] the release time of the first order lowpass in the release phase [ms]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {larm: 'the LARM loudness estimate [dB]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Larm = function (signal, attackTime, power, releaseTime, sampleRate) {\r\n        if (attackTime === void 0) { attackTime = 10; }\r\n        if (power === void 0) { power = 1.5; }\r\n        if (releaseTime === void 0) { releaseTime = 1500; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.Larm(signal, attackTime, power, releaseTime, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the Equivalent sound level (Leq) of an audio signal. The Leq measure can be derived from the Revised Low-frequency B-weighting (RLB) or from the raw signal as described in [1]. If the signal contains no energy, Leq defaults to essentias definition of silence which is -90dB.\r\n    This algorithm will throw an exception on empty input. Check https://essentia.upf.edu/reference/std_Leq.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal (must be non-empty)\r\n    * @returns {object} {leq: 'the equivalent sound level estimate [dB]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Leq = function (signal) {\r\n        return this.algorithms.Leq(signal);\r\n    };\r\n    /**\r\n    * This algorithm extracts the loudness of an audio signal in frames using Loudness algorithm. Check https://essentia.upf.edu/reference/std_LevelExtractor.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the audio input signal\r\n    * @param {number} [frameSize=88200] frame size to compute loudness\r\n    * @param {number} [hopSize=44100] hop size to compute loudness\r\n    * @returns {object} {loudness: 'the loudness values'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.LevelExtractor = function (signal, frameSize, hopSize) {\r\n        if (frameSize === void 0) { frameSize = 88200; }\r\n        if (hopSize === void 0) { hopSize = 44100; }\r\n        return this.algorithms.LevelExtractor(signal, frameSize, hopSize);\r\n    };\r\n    /**\r\n    * This algorithm computes the log (base 10) of the attack time of a signal envelope. The attack time is defined as the time duration from when the sound becomes perceptually audible to when it reaches its maximum intensity. By default, the start of the attack is estimated as the point where the signal envelope reaches 20% of its maximum value in order to account for possible noise presence. Also by default, the end of the attack is estimated as as the point where the signal envelope has reached 90% of its maximum value, in order to account for the possibility that the max value occurres after the logAttack, as in trumpet sounds. Check https://essentia.upf.edu/reference/std_LogAttackTime.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal envelope (must be non-empty)\r\n    * @param {number} [sampleRate=44100] the audio sampling rate [Hz]\r\n    * @param {number} [startAttackThreshold=0.2] the percentage of the input signal envelope at which the starting point of the attack is considered\r\n    * @param {number} [stopAttackThreshold=0.9] the percentage of the input signal envelope at which the ending point of the attack is considered\r\n    * @returns {object} {logAttackTime: 'the log (base 10) of the attack time [log10(s)]', attackStart: 'the attack start time [s]', attackStop: 'the attack end time [s]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.LogAttackTime = function (signal, sampleRate, startAttackThreshold, stopAttackThreshold) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (startAttackThreshold === void 0) { startAttackThreshold = 0.2; }\r\n        if (stopAttackThreshold === void 0) { stopAttackThreshold = 0.9; }\r\n        return this.algorithms.LogAttackTime(signal, sampleRate, startAttackThreshold, stopAttackThreshold);\r\n    };\r\n    /**\r\n    * This algorithm computes spectrum with logarithmically distributed frequency bins. This code is ported from NNLS Chroma [1, 2].This algorithm also returns a local tuning that is retrieved for input frame and a global tuning that is updated with a moving average. Check https://essentia.upf.edu/reference/std_LogSpectrum.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum spectrum frame\r\n    * @param {number} [binsPerSemitone=3]  bins per semitone\r\n    * @param {number} [frameSize=1025] the input frame size of the spectrum vector\r\n    * @param {number} [rollOn=0] this removes low-frequency noise - useful in quiet recordings\r\n    * @param {number} [sampleRate=44100] the input sample rate\r\n    * @returns {object} {logFreqSpectrum: 'log frequency spectrum frame', meanTuning: 'normalized mean tuning frequency', localTuning: 'normalized local tuning frequency'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.LogSpectrum = function (spectrum, binsPerSemitone, frameSize, rollOn, sampleRate) {\r\n        if (binsPerSemitone === void 0) { binsPerSemitone = 3; }\r\n        if (frameSize === void 0) { frameSize = 1025; }\r\n        if (rollOn === void 0) { rollOn = 0; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.LogSpectrum(spectrum, binsPerSemitone, frameSize, rollOn, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm takes an audio signal and a BPM estimate for that signal and predicts the reliability of the BPM estimate in a value from 0 to 1. The audio signal is assumed to be a musical loop with constant tempo. The confidence returned is based on comparing the duration of the signal with multiples of the BPM estimate (see [1] for more details). Check https://essentia.upf.edu/reference/std_LoopBpmConfidence.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal loop audio signal\r\n    * @param {number} bpmEstimate estimated BPM for the audio signal\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {confidence: 'confidence value for the BPM estimation'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.LoopBpmConfidence = function (signal, bpmEstimate, sampleRate) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.LoopBpmConfidence(signal, bpmEstimate, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm estimates the BPM of audio loops. It internally uses PercivalBpmEstimator algorithm to produce a BPM estimate and LoopBpmConfidence to asses the reliability of the estimate. If the provided estimate is below the given confidenceThreshold, the algorithm outputs a BPM 0.0, otherwise it outputs the estimated BPM. For more details on the BPM estimation method and the confidence measure please check the used algorithms. Check https://essentia.upf.edu/reference/std_LoopBpmEstimator.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [confidenceThreshold=0.95] confidence threshold below which bpm estimate will be considered unreliable\r\n    * @returns {object} {bpm: 'the estimated bpm (will be 0 if unsure)'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.LoopBpmEstimator = function (signal, confidenceThreshold) {\r\n        if (confidenceThreshold === void 0) { confidenceThreshold = 0.95; }\r\n        return this.algorithms.LoopBpmEstimator(signal, confidenceThreshold);\r\n    };\r\n    /**\r\n    * This algorithm computes the loudness of an audio signal defined by Steven's power law. It computes loudness as the energy of the signal raised to the power of 0.67. Check https://essentia.upf.edu/reference/std_Loudness.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @returns {object} {loudness: 'the loudness of the input signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Loudness = function (signal) {\r\n        return this.algorithms.Loudness(signal);\r\n    };\r\n    /**\r\n    * This algorithm computes Vickers's loudness of an audio signal. Currently, this algorithm only works for signals with a 44100Hz sampling rate. This algorithm is meant to be given frames of audio as input (not entire audio signals). The algorithm described in the paper performs a weighted average of the loudness value computed for each of the given frames, this step is left as a post processing step and is not performed by this algorithm. Check https://essentia.upf.edu/reference/std_LoudnessVickers.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [sampleRate=44100] the audio sampling rate of the input signal which is used to create the weight vector [Hz] (currently, this algorithm only works on signals with a sampling rate of 44100Hz)\r\n    * @returns {object} {loudness: 'the Vickers loudness [dB]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.LoudnessVickers = function (signal, sampleRate) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.LoudnessVickers(signal, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm extracts a set of level spectral features for which it is recommended to apply a preliminary equal-loudness filter over an input audio signal (according to the internal evaluations conducted at Music Technology Group). To this end, you are expected to provide the output of EqualLoudness algorithm as an input for this algorithm. Still, you are free to provide an unprocessed audio input in the case you want to compute these features without equal-loudness filter. Check https://essentia.upf.edu/reference/std_LowLevelSpectralEqloudExtractor.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio signal\r\n    * @param {number} [frameSize=2048] the frame size for computing low level features\r\n    * @param {number} [hopSize=1024] the hop size for computing low level features\r\n    * @param {number} [sampleRate=44100] the audio sampling rate\r\n    * @returns {object} {dissonance: 'See Dissonance algorithm documentation', sccoeffs: 'See SpectralContrast algorithm documentation', scvalleys: 'See SpectralContrast algorithm documentation', spectral_centroid: 'See Centroid algorithm documentation', spectral_kurtosis: 'See DistributionShape algorithm documentation', spectral_skewness: 'See DistributionShape algorithm documentation', spectral_spread: 'See DistributionShape algorithm documentation'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.LowLevelSpectralEqloudExtractor = function (signal, frameSize, hopSize, sampleRate) {\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (hopSize === void 0) { hopSize = 1024; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.LowLevelSpectralEqloudExtractor(signal, frameSize, hopSize, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm extracts all low-level spectral features, which do not require an equal-loudness filter for their computation, from an audio signal Check https://essentia.upf.edu/reference/std_LowLevelSpectralExtractor.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the audio input signal\r\n    * @param {number} [frameSize=2048] the frame size for computing low level features\r\n    * @param {number} [hopSize=1024] the hop size for computing low level features\r\n    * @param {number} [sampleRate=44100] the audio sampling rate\r\n    * @returns {object} {barkbands: 'spectral energy at each bark band. See BarkBands alogithm', barkbands_kurtosis: 'kurtosis from bark bands. See DistributionShape algorithm documentation', barkbands_skewness: 'skewness from bark bands. See DistributionShape algorithm documentation', barkbands_spread: 'spread from barkbands. See DistributionShape algorithm documentation', hfc: 'See HFC algorithm documentation', mfcc: 'See MFCC algorithm documentation', pitch: 'See PitchYinFFT algorithm documentation', pitch_instantaneous_confidence: 'See PitchYinFFT algorithm documentation', pitch_salience: 'See PitchSalience algorithm documentation', silence_rate_20dB: 'See SilenceRate algorithm documentation', silence_rate_30dB: 'See SilenceRate algorithm documentation', silence_rate_60dB: 'See SilenceRate algorithm documentation', spectral_complexity: 'See Spectral algorithm documentation', spectral_crest: 'See Crest algorithm documentation', spectral_decrease: 'See Decrease algorithm documentation', spectral_energy: 'See Energy algorithm documentation', spectral_energyband_low: 'Energy in band (20,150] Hz. See EnergyBand algorithm documentation', spectral_energyband_middle_low: 'Energy in band (150,800] Hz.See EnergyBand algorithm documentation', spectral_energyband_middle_high: 'Energy in band (800,4000] Hz. See EnergyBand algorithm documentation', spectral_energyband_high: 'Energy in band (4000,20000] Hz. See EnergyBand algorithm documentation', spectral_flatness_db: 'See flatnessDB algorithm documentation', spectral_flux: 'See Flux algorithm documentation', spectral_rms: 'See RMS algorithm documentation', spectral_rolloff: 'See RollOff algorithm documentation', spectral_strongpeak: 'See StrongPeak algorithm documentation', zerocrossingrate: 'See ZeroCrossingRate algorithm documentation', inharmonicity: 'See Inharmonicity algorithm documentation', tristimulus: 'See Tristimulus algorithm documentation', oddtoevenharmonicenergyratio: 'See OddToEvenHarmonicEnergyRatio algorithm documentation'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.LowLevelSpectralExtractor = function (signal, frameSize, hopSize, sampleRate) {\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (hopSize === void 0) { hopSize = 1024; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.LowLevelSpectralExtractor(signal, frameSize, hopSize, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm implements a 1st order IIR low-pass filter. Because of its dependence on IIR, IIR's requirements are inherited.\r\n    References:\r\n      [1] U. Zölzer, DAFX - Digital Audio Effects, p. 40,\r\n      John Wiley & Sons, 2002 Check https://essentia.upf.edu/reference/std_LowPass.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio signal\r\n    * @param {number} [cutoffFrequency=1500] the cutoff frequency for the filter [Hz]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {signal: 'the filtered signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.LowPass = function (signal, cutoffFrequency, sampleRate) {\r\n        if (cutoffFrequency === void 0) { cutoffFrequency = 1500; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.LowPass(signal, cutoffFrequency, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the mel-frequency cepstrum coefficients of a spectrum. As there is no standard implementation, the MFCC-FB40 is used by default:\r\n      - filterbank of 40 bands from 0 to 11000Hz\r\n      - take the log value of the spectrum energy in each mel band. Bands energy values below silence threshold will be clipped to its value before computing log-energies\r\n      - DCT of the 40 bands down to 13 mel coefficients\r\n    There is a paper describing various MFCC implementations [1]. Check https://essentia.upf.edu/reference/std_MFCC.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the audio spectrum\r\n    * @param {number} [dctType=2] the DCT type\r\n    * @param {number} [highFrequencyBound=11000] the upper bound of the frequency range [Hz]\r\n    * @param {number} [inputSize=1025] the size of input spectrum\r\n    * @param {number} [liftering=0] the liftering coefficient. Use '0' to bypass it\r\n    * @param {string} [logType=dbamp] logarithmic compression type. Use 'dbpow' if working with power and 'dbamp' if working with magnitudes\r\n    * @param {number} [lowFrequencyBound=0] the lower bound of the frequency range [Hz]\r\n    * @param {string} [normalize=unit_sum] spectrum bin weights to use for each mel band: 'unit_max' to make each mel band vertex equal to 1, 'unit_sum' to make each mel band area equal to 1 summing the actual weights of spectrum bins, 'unit_area' to make each triangle mel band area equal to 1 normalizing the weights of each triangle by its bandwidth\r\n    * @param {number} [numberBands=40] the number of mel-bands in the filter\r\n    * @param {number} [numberCoefficients=13] the number of output mel coefficients\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [silenceThreshold=1e-10] silence threshold for computing log-energy bands\r\n    * @param {string} [type=power] use magnitude or power spectrum\r\n    * @param {string} [warpingFormula=htkMel] The scale implementation type: 'htkMel' scale from the HTK toolkit [2, 3] (default) or 'slaneyMel' scale from the Auditory toolbox [4]\r\n    * @param {string} [weighting=warping] type of weighting function for determining triangle area\r\n    * @returns {object} {bands: 'the energies in mel bands', mfcc: 'the mel frequency cepstrum coefficients'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.MFCC = function (spectrum, dctType, highFrequencyBound, inputSize, liftering, logType, lowFrequencyBound, normalize, numberBands, numberCoefficients, sampleRate, silenceThreshold, type, warpingFormula, weighting) {\r\n        if (dctType === void 0) { dctType = 2; }\r\n        if (highFrequencyBound === void 0) { highFrequencyBound = 11000; }\r\n        if (inputSize === void 0) { inputSize = 1025; }\r\n        if (liftering === void 0) { liftering = 0; }\r\n        if (logType === void 0) { logType = 'dbamp'; }\r\n        if (lowFrequencyBound === void 0) { lowFrequencyBound = 0; }\r\n        if (normalize === void 0) { normalize = 'unit_sum'; }\r\n        if (numberBands === void 0) { numberBands = 40; }\r\n        if (numberCoefficients === void 0) { numberCoefficients = 13; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (silenceThreshold === void 0) { silenceThreshold = 1e-10; }\r\n        if (type === void 0) { type = 'power'; }\r\n        if (warpingFormula === void 0) { warpingFormula = 'htkMel'; }\r\n        if (weighting === void 0) { weighting = 'warping'; }\r\n        return this.algorithms.MFCC(spectrum, dctType, highFrequencyBound, inputSize, liftering, logType, lowFrequencyBound, normalize, numberBands, numberCoefficients, sampleRate, silenceThreshold, type, warpingFormula, weighting);\r\n    };\r\n    /**\r\n    * This algorithm implements a maximum filter for 1d signal using van Herk/Gil-Werman (HGW) algorithm. Check https://essentia.upf.edu/reference/std_MaxFilter.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal signal to be filtered\r\n    * @param {boolean} [causal=true] use casual filter (window is behind current element otherwise it is centered around)\r\n    * @param {number} [width=3] the window size, has to be odd if the window is centered\r\n    * @returns {object} {signal: 'filtered output'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.MaxFilter = function (signal, causal, width) {\r\n        if (causal === void 0) { causal = true; }\r\n        if (width === void 0) { width = 3; }\r\n        return this.algorithms.MaxFilter(signal, causal, width);\r\n    };\r\n    /**\r\n    * This algorithm computes the frequency with the largest magnitude in a spectrum.\r\n    Note that a spectrum must contain at least two elements otherwise an exception is thrown Check https://essentia.upf.edu/reference/std_MaxMagFreq.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input spectrum (must have more than 1 element)\r\n    * @param {number} [sampleRate=44100] the audio sampling rate [Hz]\r\n    * @returns {object} {maxMagFreq: 'the frequency with the largest magnitude [Hz]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.MaxMagFreq = function (spectrum, sampleRate) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.MaxMagFreq(spectrum, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the ratio between the index of the maximum value of the envelope of a signal and the total length of the envelope. This ratio shows how much the maximum amplitude is off-center. Its value is close to 0 if the maximum is close to the beginning (e.g. Decrescendo or Impulsive sounds), close to 0.5 if it is close to the middle (e.g. Delta sounds) and close to 1 if it is close to the end of the sound (e.g. Crescendo sounds). This algorithm is intended to be fed by the output of the Envelope algorithm Check https://essentia.upf.edu/reference/std_MaxToTotal.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} envelope the envelope of the signal\r\n    * @returns {object} {maxToTotal: 'the maximum amplitude position to total length ratio'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.MaxToTotal = function (envelope) {\r\n        return this.algorithms.MaxToTotal(envelope);\r\n    };\r\n    /**\r\n    * This algorithm computes the mean of an array. Check https://essentia.upf.edu/reference/std_Mean.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @returns {object} {mean: 'the mean of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Mean = function (array) {\r\n        return this.algorithms.Mean(array);\r\n    };\r\n    /**\r\n    * This algorithm computes the median of an array. When there is an odd number of numbers, the median is simply the middle number. For example, the median of 2, 4, and 7 is 4. When there is an even number of numbers, the median is the mean of the two middle numbers. Thus, the median of the numbers 2, 4, 7, 12 is (4+7)/2 = 5.5. See [1] for more info. Check https://essentia.upf.edu/reference/std_Median.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array (must be non-empty)\r\n    * @returns {object} {median: 'the median of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Median = function (array) {\r\n        return this.algorithms.Median(array);\r\n    };\r\n    /**\r\n    * This algorithm computes the median filtered version of the input signal giving the kernel size as detailed in [1]. Check https://essentia.upf.edu/reference/std_MedianFilter.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array (must be non-empty)\r\n    * @param {number} [kernelSize=11] scalar giving the size of the median filter window. Must be odd\r\n    * @returns {object} {filteredArray: 'the median-filtered input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.MedianFilter = function (array, kernelSize) {\r\n        if (kernelSize === void 0) { kernelSize = 11; }\r\n        return this.algorithms.MedianFilter(array, kernelSize);\r\n    };\r\n    /**\r\n    * This algorithm computes energy in mel bands of a spectrum. It applies a frequency-domain filterbank (MFCC FB-40, [1]), which consists of equal area triangular filters spaced according to the mel scale. The filterbank is normalized in such a way that the sum of coefficients for every filter equals one. It is recommended that the input \"spectrum\" be calculated by the Spectrum algorithm. Check https://essentia.upf.edu/reference/std_MelBands.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the audio spectrum\r\n    * @param {number} [highFrequencyBound=22050] an upper-bound limit for the frequencies to be included in the bands\r\n    * @param {number} [inputSize=1025] the size of the spectrum\r\n    * @param {boolean} [log=false] compute log-energies (log10 (1 + energy))\r\n    * @param {number} [lowFrequencyBound=0] a lower-bound limit for the frequencies to be included in the bands\r\n    * @param {string} [normalize=unit_sum] spectrum bin weights to use for each mel band: 'unit_max' to make each mel band vertex equal to 1, 'unit_sum' to make each mel band area equal to 1 summing the actual weights of spectrum bins, 'unit_area' to make each triangle mel band area equal to 1 normalizing the weights of each triangle by its bandwidth\r\n    * @param {number} [numberBands=24] the number of output bands\r\n    * @param {number} [sampleRate=44100] the sample rate\r\n    * @param {string} [type=power] 'power' to output squared units, 'magnitude' to keep it as the input\r\n    * @param {string} [warpingFormula=htkMel] The scale implementation type: 'htkMel' scale from the HTK toolkit [2, 3] (default) or 'slaneyMel' scale from the Auditory toolbox [4]\r\n    * @param {string} [weighting=warping] type of weighting function for determining triangle area\r\n    * @returns {object} {bands: 'the energy in mel bands'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.MelBands = function (spectrum, highFrequencyBound, inputSize, log, lowFrequencyBound, normalize, numberBands, sampleRate, type, warpingFormula, weighting) {\r\n        if (highFrequencyBound === void 0) { highFrequencyBound = 22050; }\r\n        if (inputSize === void 0) { inputSize = 1025; }\r\n        if (log === void 0) { log = false; }\r\n        if (lowFrequencyBound === void 0) { lowFrequencyBound = 0; }\r\n        if (normalize === void 0) { normalize = 'unit_sum'; }\r\n        if (numberBands === void 0) { numberBands = 24; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (type === void 0) { type = 'power'; }\r\n        if (warpingFormula === void 0) { warpingFormula = 'htkMel'; }\r\n        if (weighting === void 0) { weighting = 'warping'; }\r\n        return this.algorithms.MelBands(spectrum, highFrequencyBound, inputSize, log, lowFrequencyBound, normalize, numberBands, sampleRate, type, warpingFormula, weighting);\r\n    };\r\n    /**\r\n    * This algorithm estimates the time signature of a given beatogram by finding the highest correlation between beats. Check https://essentia.upf.edu/reference/std_Meter.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} beatogram filtered matrix loudness\r\n    * @returns {object} {meter: 'the time signature'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Meter = function (beatogram) {\r\n        return this.algorithms.Meter(beatogram);\r\n    };\r\n    /**\r\n    * This algorithm calculates the minimum or maximum value of an array.\r\n    If the array has more than one minimum or maximum value, the index of the first one is returned Check https://essentia.upf.edu/reference/std_MinMax.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @param {string} [type=min] the type of the operation\r\n    * @returns {object} {real: 'the minimum or maximum of the input array, according to the type parameter', int: 'the index of the value'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.MinMax = function (array, type) {\r\n        if (type === void 0) { type = 'min'; }\r\n        return this.algorithms.MinMax(array, type);\r\n    };\r\n    /**\r\n    * This algorithm computes the ratio between the index of the minimum value of the envelope of a signal and the total length of the envelope. Check https://essentia.upf.edu/reference/std_MinToTotal.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} envelope the envelope of the signal\r\n    * @returns {object} {minToTotal: 'the minimum amplitude position to total length ratio'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.MinToTotal = function (envelope) {\r\n        return this.algorithms.MinToTotal(envelope);\r\n    };\r\n    /**\r\n    * This algorithm implements a FIR Moving Average filter. Because of its dependece on IIR, IIR's requirements are inherited. Check https://essentia.upf.edu/reference/std_MovingAverage.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio signal\r\n    * @param {number} [size=6] the size of the window [audio samples]\r\n    * @returns {object} {signal: 'the filtered signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.MovingAverage = function (signal, size) {\r\n        if (size === void 0) { size = 6; }\r\n        return this.algorithms.MovingAverage(signal, size);\r\n    };\r\n    /**\r\n    * This algorithm estimates multiple pitch values corresponding to the melodic lines present in a polyphonic music signal (for example, string quartet, piano). This implementation is based on the algorithm in [1]: In each frame, a set of possible fundamental frequency candidates is extracted based on the principle of harmonic summation. In an optimization stage, the number of harmonic sources (polyphony) is estimated and the final set of fundamental frequencies determined. In contrast to the pich salience function proposed in [2], this implementation uses the pitch salience function described in [1].\r\n    The output is a vector for each frame containing the estimated melody pitch values. Check https://essentia.upf.edu/reference/std_MultiPitchKlapuri.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [binResolution=10] salience function bin resolution [cents]\r\n    * @param {number} [frameSize=2048] the frame size for computing pitch saliecnce\r\n    * @param {number} [harmonicWeight=0.8] harmonic weighting parameter (weight decay ratio between two consequent harmonics, =1 for no decay)\r\n    * @param {number} [hopSize=128] the hop size with which the pitch salience function was computed\r\n    * @param {number} [magnitudeCompression=1] magnitude compression parameter for the salience function (=0 for maximum compression, =1 for no compression)\r\n    * @param {number} [magnitudeThreshold=40] spectral peak magnitude threshold (maximum allowed difference from the highest peak in dBs)\r\n    * @param {number} [maxFrequency=1760] the maximum allowed frequency for salience function peaks (ignore peaks above) [Hz]\r\n    * @param {number} [minFrequency=80] the minimum allowed frequency for salience function peaks (ignore peaks below) [Hz]\r\n    * @param {number} [numberHarmonics=10] number of considered harmonics\r\n    * @param {number} [referenceFrequency=55] the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {pitch: 'the estimated pitch values [Hz]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.MultiPitchKlapuri = function (signal, binResolution, frameSize, harmonicWeight, hopSize, magnitudeCompression, magnitudeThreshold, maxFrequency, minFrequency, numberHarmonics, referenceFrequency, sampleRate) {\r\n        if (binResolution === void 0) { binResolution = 10; }\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (harmonicWeight === void 0) { harmonicWeight = 0.8; }\r\n        if (hopSize === void 0) { hopSize = 128; }\r\n        if (magnitudeCompression === void 0) { magnitudeCompression = 1; }\r\n        if (magnitudeThreshold === void 0) { magnitudeThreshold = 40; }\r\n        if (maxFrequency === void 0) { maxFrequency = 1760; }\r\n        if (minFrequency === void 0) { minFrequency = 80; }\r\n        if (numberHarmonics === void 0) { numberHarmonics = 10; }\r\n        if (referenceFrequency === void 0) { referenceFrequency = 55; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.MultiPitchKlapuri(signal, binResolution, frameSize, harmonicWeight, hopSize, magnitudeCompression, magnitudeThreshold, maxFrequency, minFrequency, numberHarmonics, referenceFrequency, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm estimates multiple fundamental frequency contours from an audio signal. It is a multi pitch version of the MELODIA algorithm described in [1]. While the algorithm is originally designed to extract melody in polyphonic music, this implementation is adapted for multiple sources. The approach is based on the creation and characterization of pitch contours, time continuous sequences of pitch candidates grouped using auditory streaming cues. To this end, PitchSalienceFunction, PitchSalienceFunctionPeaks, PitchContours, and PitchContoursMonoMelody algorithms are employed. It is strongly advised to use the default parameter values which are optimized according to [1] (where further details are provided) except for minFrequency, maxFrequency, and voicingTolerance, which will depend on your application. Check https://essentia.upf.edu/reference/std_MultiPitchMelodia.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [binResolution=10] salience function bin resolution [cents]\r\n    * @param {number} [filterIterations=3] number of iterations for the octave errors / pitch outlier filtering process\r\n    * @param {number} [frameSize=2048] the frame size for computing pitch saliecnce\r\n    * @param {boolean} [guessUnvoiced=false] estimate pitch for non-voiced segments by using non-salient contours when no salient ones are present in a frame\r\n    * @param {number} [harmonicWeight=0.8] harmonic weighting parameter (weight decay ratio between two consequent harmonics, =1 for no decay)\r\n    * @param {number} [hopSize=128] the hop size with which the pitch salience function was computed\r\n    * @param {number} [magnitudeCompression=1] magnitude compression parameter for the salience function (=0 for maximum compression, =1 for no compression)\r\n    * @param {number} [magnitudeThreshold=40] spectral peak magnitude threshold (maximum allowed difference from the highest peak in dBs)\r\n    * @param {number} [maxFrequency=20000] the minimum allowed frequency for salience function peaks (ignore contours with peaks above) [Hz]\r\n    * @param {number} [minDuration=100] the minimum allowed contour duration [ms]\r\n    * @param {number} [minFrequency=40] the minimum allowed frequency for salience function peaks (ignore contours with peaks below) [Hz]\r\n    * @param {number} [numberHarmonics=20] number of considered harmonics\r\n    * @param {number} [peakDistributionThreshold=0.9] allowed deviation below the peak salience mean over all frames (fraction of the standard deviation)\r\n    * @param {number} [peakFrameThreshold=0.9] per-frame salience threshold factor (fraction of the highest peak salience in a frame)\r\n    * @param {number} [pitchContinuity=27.5625] pitch continuity cue (maximum allowed pitch change during 1 ms time period) [cents]\r\n    * @param {number} [referenceFrequency=55] the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [timeContinuity=100] time continuity cue (the maximum allowed gap duration for a pitch contour) [ms]\r\n    * @returns {object} {pitch: 'the estimated pitch values [Hz]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.MultiPitchMelodia = function (signal, binResolution, filterIterations, frameSize, guessUnvoiced, harmonicWeight, hopSize, magnitudeCompression, magnitudeThreshold, maxFrequency, minDuration, minFrequency, numberHarmonics, peakDistributionThreshold, peakFrameThreshold, pitchContinuity, referenceFrequency, sampleRate, timeContinuity) {\r\n        if (binResolution === void 0) { binResolution = 10; }\r\n        if (filterIterations === void 0) { filterIterations = 3; }\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (guessUnvoiced === void 0) { guessUnvoiced = false; }\r\n        if (harmonicWeight === void 0) { harmonicWeight = 0.8; }\r\n        if (hopSize === void 0) { hopSize = 128; }\r\n        if (magnitudeCompression === void 0) { magnitudeCompression = 1; }\r\n        if (magnitudeThreshold === void 0) { magnitudeThreshold = 40; }\r\n        if (maxFrequency === void 0) { maxFrequency = 20000; }\r\n        if (minDuration === void 0) { minDuration = 100; }\r\n        if (minFrequency === void 0) { minFrequency = 40; }\r\n        if (numberHarmonics === void 0) { numberHarmonics = 20; }\r\n        if (peakDistributionThreshold === void 0) { peakDistributionThreshold = 0.9; }\r\n        if (peakFrameThreshold === void 0) { peakFrameThreshold = 0.9; }\r\n        if (pitchContinuity === void 0) { pitchContinuity = 27.5625; }\r\n        if (referenceFrequency === void 0) { referenceFrequency = 55; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (timeContinuity === void 0) { timeContinuity = 100; }\r\n        return this.algorithms.MultiPitchMelodia(signal, binResolution, filterIterations, frameSize, guessUnvoiced, harmonicWeight, hopSize, magnitudeCompression, magnitudeThreshold, maxFrequency, minDuration, minFrequency, numberHarmonics, peakDistributionThreshold, peakFrameThreshold, pitchContinuity, referenceFrequency, sampleRate, timeContinuity);\r\n    };\r\n    /**\r\n    * This algorithm returns a single vector from a given number of real values and/or frames. Frames from different inputs are multiplexed onto a single stream in an alternating fashion. Check https://essentia.upf.edu/reference/std_Multiplexer.html for more details.\r\n    * @method\r\n    * @param {number} [numberRealInputs=0] the number of inputs of type Real to multiplex\r\n    * @param {number} [numberVectorRealInputs=0] the number of inputs of type vector<Real> to multiplex\r\n    * @returns {object} {data: 'the frame containing the input values and/or input frames'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Multiplexer = function (numberRealInputs, numberVectorRealInputs) {\r\n        if (numberRealInputs === void 0) { numberRealInputs = 0; }\r\n        if (numberVectorRealInputs === void 0) { numberVectorRealInputs = 0; }\r\n        return this.algorithms.Multiplexer(numberRealInputs, numberVectorRealInputs);\r\n    };\r\n    /**\r\n    * This algorithm extracts treble and bass chromagrams from a sequence of log-frequency spectrum frames.\r\n    On this representation, two processing steps are performed:\r\n      -tuning, after which each centre bin (i.e. bin 2, 5, 8, ...) corresponds to a semitone, even if the tuning of the piece deviates from 440 Hz standard pitch.\r\n      -running standardisation: subtraction of the running mean, division by the running standard deviation. This has a spectral whitening effect.\r\n    This code is ported from NNLS Chroma [1, 2]. To achieve similar results follow this processing chain:\r\n    frame slicing with sample rate = 44100, frame size = 16384, hop size = 2048 -> Windowing with Hann and no normalization -> Spectrum -> LogSpectrum. Check https://essentia.upf.edu/reference/std_NNLSChroma.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} logSpectrogram log spectrum frames\r\n    * @param {VectorFloat} meanTuning mean tuning frames\r\n    * @param {VectorFloat} localTuning local tuning frames\r\n    * @param {string} [chromaNormalization=none] determines whether or how the chromagrams are normalised\r\n    * @param {number} [frameSize=1025] the input frame size of the spectrum vector\r\n    * @param {number} [sampleRate=44100] the input sample rate\r\n    * @param {number} [spectralShape=0.7]  the shape of the notes in the NNLS dictionary\r\n    * @param {number} [spectralWhitening=1] determines how much the log-frequency spectrum is whitened\r\n    * @param {string} [tuningMode=global] local uses a local average for tuning, global uses all audio frames. Local tuning is only advisable when the tuning is likely to change over the audio\r\n    * @param {boolean} [useNNLS=true] toggle between NNLS approximate transcription and linear spectral mapping\r\n    * @returns {object} {tunedLogfreqSpectrum: 'Log frequency spectrum after tuning', semitoneSpectrum: 'a spectral representation with one bin per semitone', bassChromagram: ' a 12-dimensional chromagram, restricted to the bass range', chromagram: 'a 12-dimensional chromagram, restricted with mid-range emphasis'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.NNLSChroma = function (logSpectrogram, meanTuning, localTuning, chromaNormalization, frameSize, sampleRate, spectralShape, spectralWhitening, tuningMode, useNNLS) {\r\n        if (chromaNormalization === void 0) { chromaNormalization = 'none'; }\r\n        if (frameSize === void 0) { frameSize = 1025; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (spectralShape === void 0) { spectralShape = 0.7; }\r\n        if (spectralWhitening === void 0) { spectralWhitening = 1; }\r\n        if (tuningMode === void 0) { tuningMode = 'global'; }\r\n        if (useNNLS === void 0) { useNNLS = true; }\r\n        return this.algorithms.NNLSChroma(logSpectrogram, meanTuning, localTuning, chromaNormalization, frameSize, sampleRate, spectralShape, spectralWhitening, tuningMode, useNNLS);\r\n    };\r\n    /**\r\n    * This algorithm adds noise to an input signal. The average energy of the noise in dB is defined by the level parameter, and is generated using the Mersenne Twister random number generator. Check https://essentia.upf.edu/reference/std_NoiseAdder.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {boolean} [fixSeed=false] if true, 0 is used as the seed for generating random values\r\n    * @param {number} [level=-100] power level of the noise generator [dB]\r\n    * @returns {object} {signal: 'the output signal with the added noise'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.NoiseAdder = function (signal, fixSeed, level) {\r\n        if (fixSeed === void 0) { fixSeed = false; }\r\n        if (level === void 0) { level = -100; }\r\n        return this.algorithms.NoiseAdder(signal, fixSeed, level);\r\n    };\r\n    /**\r\n    * This algorithm detects noise bursts in the waveform by thresholding  the peaks of the second derivative. The threshold is computed using an Exponential Moving Average filter over the RMS of the second derivative of the input frame. Check https://essentia.upf.edu/reference/std_NoiseBurstDetector.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input frame (must be non-empty)\r\n    * @param {number} [alpha=0.9] alpha coefficient for the Exponential Moving Average threshold estimation.\r\n    * @param {number} [silenceThreshold=-50] threshold to skip silent frames\r\n    * @param {number} [threshold=8] factor to control the dynamic theshold\r\n    * @returns {object} {indexes: 'indexes of the noisy samples'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.NoiseBurstDetector = function (frame, alpha, silenceThreshold, threshold) {\r\n        if (alpha === void 0) { alpha = 0.9; }\r\n        if (silenceThreshold === void 0) { silenceThreshold = -50; }\r\n        if (threshold === void 0) { threshold = 8; }\r\n        return this.algorithms.NoiseBurstDetector(frame, alpha, silenceThreshold, threshold);\r\n    };\r\n    /**\r\n    * This algorithm computes the \"novelty curve\" (Grosche & Müller, 2009) onset detection function. The algorithm expects as an input a frame-wise sequence of frequency-bands energies or spectrum magnitudes as originally proposed in [1] (see FrequencyBands and Spectrum algorithms). Novelty in each band (or frequency bin) is computed as a derivative between log-compressed energy (magnitude) values in consequent frames. The overall novelty value is then computed as a weighted sum that can be configured using 'weightCurve' parameter. The resulting novelty curve can be used for beat tracking and onset detection (see BpmHistogram and Onsets). Check https://essentia.upf.edu/reference/std_NoveltyCurve.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} frequencyBands the frequency bands\r\n    * @param {number} [frameRate=344.531] the sampling rate of the input audio\r\n    * @param {boolean} [normalize=false] whether to normalize each band's energy\r\n    * @param {any[]} [weightCurve=[]] vector containing the weights for each frequency band. Only if weightCurveType==supplied\r\n    * @param {string} [weightCurveType=hybrid] the type of weighting to be used for the bands novelty\r\n    * @returns {object} {novelty: 'the novelty curve as a single vector'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.NoveltyCurve = function (frequencyBands, frameRate, normalize, weightCurve, weightCurveType) {\r\n        if (frameRate === void 0) { frameRate = 344.531; }\r\n        if (normalize === void 0) { normalize = false; }\r\n        if (weightCurve === void 0) { weightCurve = []; }\r\n        if (weightCurveType === void 0) { weightCurveType = 'hybrid'; }\r\n        var vecweightCurve = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecweightCurve.size(); i++) {\r\n            vecweightCurve.push_back(weightCurve[i]);\r\n        }\r\n        return this.algorithms.NoveltyCurve(frequencyBands, frameRate, normalize, vecweightCurve, weightCurveType);\r\n    };\r\n    /**\r\n    * This algorithm outputs a histogram of the most probable bpms assuming the signal has constant tempo given the novelty curve. This algorithm is based on the autocorrelation of the novelty curve (see NoveltyCurve algorithm) and should only be used for signals that have a constant tempo or as a first tempo estimator to be used in conjunction with other algorithms such as BpmHistogram.It is a simplified version of the algorithm described in [1] as, in order to predict the best BPM candidate,  it computes autocorrelation of the entire novelty curve instead of analyzing it on frames and histogramming the peaks over frames. Check https://essentia.upf.edu/reference/std_NoveltyCurveFixedBpmEstimator.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} novelty the novelty curve of the audio signal\r\n    * @param {number} [hopSize=512] the hopSize used to computeh the novelty curve from the original signal\r\n    * @param {number} [maxBpm=560] the maximum bpm to look for\r\n    * @param {number} [minBpm=30] the minimum bpm to look for\r\n    * @param {number} [sampleRate=44100] the sampling rate original audio signal [Hz]\r\n    * @param {number} [tolerance=3] tolerance (in percentage) for considering bpms to be equal\r\n    * @returns {object} {bpms: 'the bpm candidates sorted by magnitude', amplitudes: 'the magnitude of each bpm candidate'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.NoveltyCurveFixedBpmEstimator = function (novelty, hopSize, maxBpm, minBpm, sampleRate, tolerance) {\r\n        if (hopSize === void 0) { hopSize = 512; }\r\n        if (maxBpm === void 0) { maxBpm = 560; }\r\n        if (minBpm === void 0) { minBpm = 30; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (tolerance === void 0) { tolerance = 3; }\r\n        return this.algorithms.NoveltyCurveFixedBpmEstimator(novelty, hopSize, maxBpm, minBpm, sampleRate, tolerance);\r\n    };\r\n    /**\r\n    * This algorithm computes the ratio between a signal's odd and even harmonic energy given the signal's harmonic peaks. The odd to even harmonic energy ratio is a measure allowing to distinguish odd-harmonic-energy predominant sounds (such as from a clarinet) from equally important even-harmonic-energy sounds (such as from a trumpet). The required harmonic frequencies and magnitudes can be computed by the HarmonicPeaks algorithm.\r\n    In the case when the even energy is zero, which may happen when only even harmonics where found or when only one peak was found, the algorithm outputs the maximum real number possible. Therefore, this algorithm should be used in conjunction with the harmonic peaks algorithm.\r\n    If no peaks are supplied, the algorithm outputs a value of one, assuming either the spectrum was flat or it was silent. Check https://essentia.upf.edu/reference/std_OddToEvenHarmonicEnergyRatio.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frequencies the frequencies of the harmonic peaks (at least two frequencies in frequency ascending order)\r\n    * @param {VectorFloat} magnitudes the magnitudes of the harmonic peaks (at least two magnitudes in frequency ascending order)\r\n    * @returns {object} {oddToEvenHarmonicEnergyRatio: 'the ratio between the odd and even harmonic energies of the given harmonic peaks'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.OddToEvenHarmonicEnergyRatio = function (frequencies, magnitudes) {\r\n        return this.algorithms.OddToEvenHarmonicEnergyRatio(frequencies, magnitudes);\r\n    };\r\n    /**\r\n    * This algorithm computes various onset detection functions. The output of this algorithm should be post-processed in order to determine whether the frame contains an onset or not. Namely, it could be fed to the Onsets algorithm. It is recommended that the input \"spectrum\" is generated by the Spectrum algorithm.\r\n    Four methods are available:\r\n      - 'HFC', the High Frequency Content detection function which accurately detects percussive events (see HFC algorithm for details).\r\n      - 'complex', the Complex-Domain spectral difference function [1] taking into account changes in magnitude and phase. It emphasizes note onsets either as a result of significant change in energy in the magnitude spectrum, and/or a deviation from the expected phase values in the phase spectrum, caused by a change in pitch.\r\n      - 'complex_phase', the simplified Complex-Domain spectral difference function [2] taking into account phase changes, weighted by magnitude. TODO:It reacts better on tonal sounds such as bowed string, but tends to over-detect percussive events.\r\n      - 'flux', the Spectral Flux detection function which characterizes changes in magnitude spectrum. See Flux algorithm for details.\r\n      - 'melflux', the spectral difference function, similar to spectral flux, but using half-rectified energy changes in Mel-frequency bands of the spectrum [3].\r\n      - 'rms', the difference function, measuring the half-rectified change of the RMS of the magnitude spectrum (i.e., measuring overall energy flux) [4]. Check https://essentia.upf.edu/reference/std_OnsetDetection.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input spectrum\r\n    * @param {VectorFloat} phase the phase vector corresponding to this spectrum (used only by the \"complex\" method)\r\n    * @param {string} [method=hfc] the method used for onset detection\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {onsetDetection: 'the value of the detection function in the current frame'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.OnsetDetection = function (spectrum, phase, method, sampleRate) {\r\n        if (method === void 0) { method = 'hfc'; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.OnsetDetection(spectrum, phase, method, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes various onset detection functions. Detection values are computed frame-wisely given an input signal. The output of this algorithm should be post-processed in order to determine whether the frame contains an onset or not. Namely, it could be fed to the Onsets algorithm.\r\n    The following method are available:\r\n      - 'infogain', the spectral difference measured by the modified information gain [1]. For each frame, it accounts for energy change in between preceding and consecutive frames, histogrammed together, in order to suppress short-term variations on frame-by-frame basis.\r\n      - 'beat_emphasis', the beat emphasis function [1]. This function is a linear combination of onset detection functions (complex spectral differences) in a number of sub-bands, weighted by their beat strength computed over the entire input signal.\r\n    Note:\r\n      - 'infogain' onset detection has been optimized for the default sampleRate=44100Hz, frameSize=2048, hopSize=512.\r\n      - 'beat_emphasis' is optimized for a fixed resolution of 11.6ms, which corresponds to the default sampleRate=44100Hz, frameSize=1024, hopSize=512.\r\n      Optimal performance of beat detection with TempoTapDegara is not guaranteed for other settings. Check https://essentia.upf.edu/reference/std_OnsetDetectionGlobal.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [frameSize=2048] the frame size for computing onset detection function\r\n    * @param {number} [hopSize=512] the hop size for computing onset detection function\r\n    * @param {string} [method=infogain] the method used for onset detection\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {onsetDetections: 'the frame-wise values of the detection function'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.OnsetDetectionGlobal = function (signal, frameSize, hopSize, method, sampleRate) {\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (hopSize === void 0) { hopSize = 512; }\r\n        if (method === void 0) { method = 'infogain'; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.OnsetDetectionGlobal(signal, frameSize, hopSize, method, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the number of onsets per second and their position in time for an audio signal. Onset detection functions are computed using both high frequency content and complex-domain methods available in OnsetDetection algorithm. See OnsetDetection for more information.\r\n    Please note that due to a dependence on the Onsets algorithm, this algorithm is only valid for audio signals with a sampling rate of 44100Hz.\r\n    This algorithm throws an exception if the input signal is empty. Check https://essentia.upf.edu/reference/std_OnsetRate.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @returns {object} {onsets: 'the positions of detected onsets [s]', onsetRate: 'the number of onsets per second'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.OnsetRate = function (signal) {\r\n        return this.algorithms.OnsetRate(signal);\r\n    };\r\n    /**\r\n    * This algorithm returns the output of an overlap-add process for a sequence of frames of an audio signal. It considers that the input audio frames are windowed audio signals. Giving the size of the frame and the hop size, overlapping and adding consecutive frames will produce a continuous signal. A normalization gain can be passed as a parameter. Check https://essentia.upf.edu/reference/std_OverlapAdd.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the windowed input audio frame\r\n    * @param {number} [frameSize=2048] the frame size for computing the overlap-add process\r\n    * @param {number} [gain=1] the normalization gain that scales the output signal. Useful for IFFT output\r\n    * @param {number} [hopSize=128] the hop size with which the overlap-add function is computed\r\n    * @returns {object} {signal: 'the output overlap-add audio signal frame'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.OverlapAdd = function (signal, frameSize, gain, hopSize) {\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (gain === void 0) { gain = 1; }\r\n        if (hopSize === void 0) { hopSize = 128; }\r\n        return this.algorithms.OverlapAdd(signal, frameSize, gain, hopSize);\r\n    };\r\n    /**\r\n    * This algorithm detects local maxima (peaks) in an array. The algorithm finds positive slopes and detects a peak when the slope changes sign and the peak is above the threshold.\r\n    It optionally interpolates using parabolic curve fitting.\r\n    When two consecutive peaks are closer than the `minPeakDistance` parameter, the smallest one is discarded. A value of 0 bypasses this feature. Check https://essentia.upf.edu/reference/std_PeakDetection.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @param {boolean} [interpolate=true] boolean flag to enable interpolation\r\n    * @param {number} [maxPeaks=100] the maximum number of returned peaks\r\n    * @param {number} [maxPosition=1] the maximum value of the range to evaluate\r\n    * @param {number} [minPeakDistance=0] minimum distance between consecutive peaks (0 to bypass this feature)\r\n    * @param {number} [minPosition=0] the minimum value of the range to evaluate\r\n    * @param {string} [orderBy=position] the ordering type of the output peaks (ascending by position or descending by value)\r\n    * @param {number} [range=1] the input range\r\n    * @param {number} [threshold=-1e+06] peaks below this given threshold are not output\r\n    * @returns {object} {positions: 'the positions of the peaks', amplitudes: 'the amplitudes of the peaks'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PeakDetection = function (array, interpolate, maxPeaks, maxPosition, minPeakDistance, minPosition, orderBy, range, threshold) {\r\n        if (interpolate === void 0) { interpolate = true; }\r\n        if (maxPeaks === void 0) { maxPeaks = 100; }\r\n        if (maxPosition === void 0) { maxPosition = 1; }\r\n        if (minPeakDistance === void 0) { minPeakDistance = 0; }\r\n        if (minPosition === void 0) { minPosition = 0; }\r\n        if (orderBy === void 0) { orderBy = 'position'; }\r\n        if (range === void 0) { range = 1; }\r\n        if (threshold === void 0) { threshold = -1e+06; }\r\n        return this.algorithms.PeakDetection(array, interpolate, maxPeaks, maxPosition, minPeakDistance, minPosition, orderBy, range, threshold);\r\n    };\r\n    /**\r\n    * This algorithm estimates the tempo in beats per minute (BPM) from an input signal as described in [1]. Check https://essentia.upf.edu/reference/std_PercivalBpmEstimator.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal input signal\r\n    * @param {number} [frameSize=1024] frame size for the analysis of the input signal\r\n    * @param {number} [frameSizeOSS=2048] frame size for the analysis of the Onset Strength Signal\r\n    * @param {number} [hopSize=128] hop size for the analysis of the input signal\r\n    * @param {number} [hopSizeOSS=128] hop size for the analysis of the Onset Strength Signal\r\n    * @param {number} [maxBPM=210] maximum BPM to detect\r\n    * @param {number} [minBPM=50] minimum BPM to detect\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {bpm: 'the tempo estimation [bpm]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PercivalBpmEstimator = function (signal, frameSize, frameSizeOSS, hopSize, hopSizeOSS, maxBPM, minBPM, sampleRate) {\r\n        if (frameSize === void 0) { frameSize = 1024; }\r\n        if (frameSizeOSS === void 0) { frameSizeOSS = 2048; }\r\n        if (hopSize === void 0) { hopSize = 128; }\r\n        if (hopSizeOSS === void 0) { hopSizeOSS = 128; }\r\n        if (maxBPM === void 0) { maxBPM = 210; }\r\n        if (minBPM === void 0) { minBPM = 50; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.PercivalBpmEstimator(signal, frameSize, frameSizeOSS, hopSize, hopSizeOSS, maxBPM, minBPM, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm implements the 'Enhance Harmonics' step as described in [1].Given an input autocorrelation signal, two time-stretched versions of it (by factors of 2 and 4) are added to the original.In this way, peaks with an harmonic relation are boosted.\r\n    For more details check the referenced paper. Check https://essentia.upf.edu/reference/std_PercivalEnhanceHarmonics.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input signal\r\n    * @returns {object} {array: 'the input signal with enhanced harmonics'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PercivalEnhanceHarmonics = function (array) {\r\n        return this.algorithms.PercivalEnhanceHarmonics(array);\r\n    };\r\n    /**\r\n    * This algorithm implements the 'Evaluate Pulse Trains' step as described in [1].Given an input onset strength signal (OSS) and a number of candidate tempo lag positions, the OSS is correlated with ideal expected pulse trains (for each candidate tempo lag) shifted in time by different amounts. The candidate tempo lag which generates the pulse train that better correlates with the OSS is returned as the preferred tempo candidate.\r\n    For more details check the referenced paper. Check https://essentia.upf.edu/reference/std_PercivalEvaluatePulseTrains.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} oss onset strength signal (or other novelty curve)\r\n    * @param {VectorFloat} positions peak positions of BPM candidates\r\n    * @returns {object} {lag: 'best tempo lag estimate'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PercivalEvaluatePulseTrains = function (oss, positions) {\r\n        return this.algorithms.PercivalEvaluatePulseTrains(oss, positions);\r\n    };\r\n    /**\r\n    * This algorithm converts a pitch sequence estimated from an audio signal into a set of discrete note events. Each note is defined by its onset time, duration and MIDI pitch value, quantized to the equal tempered scale. Check https://essentia.upf.edu/reference/std_PitchContourSegmentation.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} pitch estimated pitch contour [Hz]\r\n    * @param {VectorFloat} signal input audio signal\r\n    * @param {number} [hopSize=128] hop size of the extracted pitch\r\n    * @param {number} [minDuration=0.1] minimum note duration [s]\r\n    * @param {number} [pitchDistanceThreshold=60] pitch threshold for note segmentation [cents]\r\n    * @param {number} [rmsThreshold=-2] zscore threshold for note segmentation\r\n    * @param {number} [sampleRate=44100] sample rate of the audio signal\r\n    * @param {number} [tuningFrequency=440] tuning reference frequency  [Hz]\r\n    * @returns {object} {onset: 'note onset times [s]', duration: 'note durations [s]', MIDIpitch: 'quantized MIDI pitch value'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchContourSegmentation = function (pitch, signal, hopSize, minDuration, pitchDistanceThreshold, rmsThreshold, sampleRate, tuningFrequency) {\r\n        if (hopSize === void 0) { hopSize = 128; }\r\n        if (minDuration === void 0) { minDuration = 0.1; }\r\n        if (pitchDistanceThreshold === void 0) { pitchDistanceThreshold = 60; }\r\n        if (rmsThreshold === void 0) { rmsThreshold = -2; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (tuningFrequency === void 0) { tuningFrequency = 440; }\r\n        return this.algorithms.PitchContourSegmentation(pitch, signal, hopSize, minDuration, pitchDistanceThreshold, rmsThreshold, sampleRate, tuningFrequency);\r\n    };\r\n    /**\r\n    * This algorithm tracks a set of predominant pitch contours of an audio signal. This algorithm is intended to receive its \"frequencies\" and \"magnitudes\" inputs from the PitchSalienceFunctionPeaks algorithm outputs aggregated over all frames in the sequence. The output is a vector of estimated melody pitch values. Check https://essentia.upf.edu/reference/std_PitchContours.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} peakBins frame-wise array of cent bins corresponding to pitch salience function peaks\r\n    * @param {VectorVectorFloat} peakSaliences frame-wise array of values of salience function peaks\r\n    * @param {number} [binResolution=10] salience function bin resolution [cents]\r\n    * @param {number} [hopSize=128] the hop size with which the pitch salience function was computed\r\n    * @param {number} [minDuration=100] the minimum allowed contour duration [ms]\r\n    * @param {number} [peakDistributionThreshold=0.9] allowed deviation below the peak salience mean over all frames (fraction of the standard deviation)\r\n    * @param {number} [peakFrameThreshold=0.9] per-frame salience threshold factor (fraction of the highest peak salience in a frame)\r\n    * @param {number} [pitchContinuity=27.5625] pitch continuity cue (maximum allowed pitch change durig 1 ms time period) [cents]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [timeContinuity=100] time continuity cue (the maximum allowed gap duration for a pitch contour) [ms]\r\n    * @returns {object} {contoursBins: 'array of frame-wise vectors of cent bin values representing each contour', contoursSaliences: 'array of frame-wise vectors of pitch saliences representing each contour', contoursStartTimes: 'array of start times of each contour [s]', duration: 'time duration of the input signal [s]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchContours = function (peakBins, peakSaliences, binResolution, hopSize, minDuration, peakDistributionThreshold, peakFrameThreshold, pitchContinuity, sampleRate, timeContinuity) {\r\n        if (binResolution === void 0) { binResolution = 10; }\r\n        if (hopSize === void 0) { hopSize = 128; }\r\n        if (minDuration === void 0) { minDuration = 100; }\r\n        if (peakDistributionThreshold === void 0) { peakDistributionThreshold = 0.9; }\r\n        if (peakFrameThreshold === void 0) { peakFrameThreshold = 0.9; }\r\n        if (pitchContinuity === void 0) { pitchContinuity = 27.5625; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (timeContinuity === void 0) { timeContinuity = 100; }\r\n        return this.algorithms.PitchContours(peakBins, peakSaliences, binResolution, hopSize, minDuration, peakDistributionThreshold, peakFrameThreshold, pitchContinuity, sampleRate, timeContinuity);\r\n    };\r\n    /**\r\n    * This algorithm converts a set of pitch contours into a sequence of predominant f0 values in Hz by taking the value of the most predominant contour in each frame.\r\n    This algorithm is intended to receive its \"contoursBins\", \"contoursSaliences\", and \"contoursStartTimes\" inputs from the PitchContours algorithm. The \"duration\" input corresponds to the time duration of the input signal. The output is a vector of estimated pitch values and a vector of confidence values. Check https://essentia.upf.edu/reference/std_PitchContoursMelody.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} contoursBins array of frame-wise vectors of cent bin values representing each contour\r\n    * @param {VectorVectorFloat} contoursSaliences array of frame-wise vectors of pitch saliences representing each contour\r\n    * @param {VectorFloat} contoursStartTimes array of the start times of each contour [s]\r\n    * @param {number} duration time duration of the input signal [s]\r\n    * @param {number} [binResolution=10] salience function bin resolution [cents]\r\n    * @param {number} [filterIterations=3] number of interations for the octave errors / pitch outlier filtering process\r\n    * @param {boolean} [guessUnvoiced=false] Estimate pitch for non-voiced segments by using non-salient contours when no salient ones are present in a frame\r\n    * @param {number} [hopSize=128] the hop size with which the pitch salience function was computed\r\n    * @param {number} [maxFrequency=20000] the minimum allowed frequency for salience function peaks (ignore contours with peaks above) [Hz]\r\n    * @param {number} [minFrequency=80] the minimum allowed frequency for salience function peaks (ignore contours with peaks below) [Hz]\r\n    * @param {number} [referenceFrequency=55] the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal (Hz)\r\n    * @param {boolean} [voiceVibrato=false] detect voice vibrato\r\n    * @param {number} [voicingTolerance=0.2] allowed deviation below the average contour mean salience of all contours (fraction of the standard deviation)\r\n    * @returns {object} {pitch: 'vector of estimated pitch values (i.e., melody) [Hz]', pitchConfidence: 'confidence with which the pitch was detected'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchContoursMelody = function (contoursBins, contoursSaliences, contoursStartTimes, duration, binResolution, filterIterations, guessUnvoiced, hopSize, maxFrequency, minFrequency, referenceFrequency, sampleRate, voiceVibrato, voicingTolerance) {\r\n        if (binResolution === void 0) { binResolution = 10; }\r\n        if (filterIterations === void 0) { filterIterations = 3; }\r\n        if (guessUnvoiced === void 0) { guessUnvoiced = false; }\r\n        if (hopSize === void 0) { hopSize = 128; }\r\n        if (maxFrequency === void 0) { maxFrequency = 20000; }\r\n        if (minFrequency === void 0) { minFrequency = 80; }\r\n        if (referenceFrequency === void 0) { referenceFrequency = 55; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (voiceVibrato === void 0) { voiceVibrato = false; }\r\n        if (voicingTolerance === void 0) { voicingTolerance = 0.2; }\r\n        return this.algorithms.PitchContoursMelody(contoursBins, contoursSaliences, contoursStartTimes, duration, binResolution, filterIterations, guessUnvoiced, hopSize, maxFrequency, minFrequency, referenceFrequency, sampleRate, voiceVibrato, voicingTolerance);\r\n    };\r\n    /**\r\n    * This algorithm converts a set of pitch contours into a sequence of f0 values in Hz by taking the value of the most salient contour in each frame.\r\n    In contrast to pitchContoursMelody, it assumes a single source.\r\n    This algorithm is intended to receive its \"contoursBins\", \"contoursSaliences\", and \"contoursStartTimes\" inputs from the PitchContours algorithm. The \"duration\" input corresponds to the time duration of the input signal. The output is a vector of estimated pitch values and a vector of confidence values. Check https://essentia.upf.edu/reference/std_PitchContoursMonoMelody.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} contoursBins array of frame-wise vectors of cent bin values representing each contour\r\n    * @param {VectorVectorFloat} contoursSaliences array of frame-wise vectors of pitch saliences representing each contour\r\n    * @param {VectorFloat} contoursStartTimes array of the start times of each contour [s]\r\n    * @param {number} duration time duration of the input signal [s]\r\n    * @param {number} [binResolution=10] salience function bin resolution [cents]\r\n    * @param {number} [filterIterations=3] number of interations for the octave errors / pitch outlier filtering process\r\n    * @param {boolean} [guessUnvoiced=false] Estimate pitch for non-voiced segments by using non-salient contours when no salient ones are present in a frame\r\n    * @param {number} [hopSize=128] the hop size with which the pitch salience function was computed\r\n    * @param {number} [maxFrequency=20000] the minimum allowed frequency for salience function peaks (ignore contours with peaks above) [Hz]\r\n    * @param {number} [minFrequency=80] the minimum allowed frequency for salience function peaks (ignore contours with peaks below) [Hz]\r\n    * @param {number} [referenceFrequency=55] the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal (Hz)\r\n    * @returns {object} {pitch: 'vector of estimated pitch values (i.e., melody) [Hz]', pitchConfidence: 'confidence with which the pitch was detected'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchContoursMonoMelody = function (contoursBins, contoursSaliences, contoursStartTimes, duration, binResolution, filterIterations, guessUnvoiced, hopSize, maxFrequency, minFrequency, referenceFrequency, sampleRate) {\r\n        if (binResolution === void 0) { binResolution = 10; }\r\n        if (filterIterations === void 0) { filterIterations = 3; }\r\n        if (guessUnvoiced === void 0) { guessUnvoiced = false; }\r\n        if (hopSize === void 0) { hopSize = 128; }\r\n        if (maxFrequency === void 0) { maxFrequency = 20000; }\r\n        if (minFrequency === void 0) { minFrequency = 80; }\r\n        if (referenceFrequency === void 0) { referenceFrequency = 55; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.PitchContoursMonoMelody(contoursBins, contoursSaliences, contoursStartTimes, duration, binResolution, filterIterations, guessUnvoiced, hopSize, maxFrequency, minFrequency, referenceFrequency, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm post-processes a set of pitch contours into a sequence of mutliple f0 values in Hz.\r\n    This algorithm is intended to receive its \"contoursBins\", \"contoursSaliences\", and \"contoursStartTimes\" inputs from the PitchContours algorithm. The \"duration\" input corresponds to the time duration of the input signal. The output is a vector of estimated pitch values Check https://essentia.upf.edu/reference/std_PitchContoursMultiMelody.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} contoursBins array of frame-wise vectors of cent bin values representing each contour\r\n    * @param {VectorVectorFloat} contoursSaliences array of frame-wise vectors of pitch saliences representing each contour\r\n    * @param {VectorFloat} contoursStartTimes array of the start times of each contour [s]\r\n    * @param {number} duration time duration of the input signal [s]\r\n    * @param {number} [binResolution=10] salience function bin resolution [cents]\r\n    * @param {number} [filterIterations=3] number of interations for the octave errors / pitch outlier filtering process\r\n    * @param {boolean} [guessUnvoiced=false] Estimate pitch for non-voiced segments by using non-salient contours when no salient ones are present in a frame\r\n    * @param {number} [hopSize=128] the hop size with which the pitch salience function was computed\r\n    * @param {number} [maxFrequency=20000] the minimum allowed frequency for salience function peaks (ignore contours with peaks above) [Hz]\r\n    * @param {number} [minFrequency=80] the minimum allowed frequency for salience function peaks (ignore contours with peaks below) [Hz]\r\n    * @param {number} [referenceFrequency=55] the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal (Hz)\r\n    * @returns {object} {pitch: 'vector of estimated pitch values (i.e., melody) [Hz]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchContoursMultiMelody = function (contoursBins, contoursSaliences, contoursStartTimes, duration, binResolution, filterIterations, guessUnvoiced, hopSize, maxFrequency, minFrequency, referenceFrequency, sampleRate) {\r\n        if (binResolution === void 0) { binResolution = 10; }\r\n        if (filterIterations === void 0) { filterIterations = 3; }\r\n        if (guessUnvoiced === void 0) { guessUnvoiced = false; }\r\n        if (hopSize === void 0) { hopSize = 128; }\r\n        if (maxFrequency === void 0) { maxFrequency = 20000; }\r\n        if (minFrequency === void 0) { minFrequency = 80; }\r\n        if (referenceFrequency === void 0) { referenceFrequency = 55; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.PitchContoursMultiMelody(contoursBins, contoursSaliences, contoursStartTimes, duration, binResolution, filterIterations, guessUnvoiced, hopSize, maxFrequency, minFrequency, referenceFrequency, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm corrects the fundamental frequency estimations for a sequence of frames given pitch values together with their confidence values. In particular, it removes non-confident parts and spurious jumps in pitch and applies octave corrections. Check https://essentia.upf.edu/reference/std_PitchFilter.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} pitch vector of pitch values for the input frames [Hz]\r\n    * @param {VectorFloat} pitchConfidence vector of pitch confidence values for the input frames\r\n    * @param {number} [confidenceThreshold=36] ratio between the average confidence of the most confident chunk and the minimum allowed average confidence of a chunk\r\n    * @param {number} [minChunkSize=30] minumum number of frames in non-zero pitch chunks\r\n    * @param {boolean} [useAbsolutePitchConfidence=false] treat negative pitch confidence values as positive (use with melodia guessUnvoiced=True)\r\n    * @returns {object} {pitchFiltered: 'vector of corrected pitch values [Hz]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchFilter = function (pitch, pitchConfidence, confidenceThreshold, minChunkSize, useAbsolutePitchConfidence) {\r\n        if (confidenceThreshold === void 0) { confidenceThreshold = 36; }\r\n        if (minChunkSize === void 0) { minChunkSize = 30; }\r\n        if (useAbsolutePitchConfidence === void 0) { useAbsolutePitchConfidence = false; }\r\n        return this.algorithms.PitchFilter(pitch, pitchConfidence, confidenceThreshold, minChunkSize, useAbsolutePitchConfidence);\r\n    };\r\n    /**\r\n    * This algorithm estimates the fundamental frequency corresponding to the melody of a monophonic music signal based on the MELODIA algorithm. While the algorithm is originally designed to extract the predominant melody from polyphonic music [1], this implementation is adapted for monophonic signals. The approach is based on the creation and characterization of pitch contours, time continuous sequences of pitch candidates grouped using auditory streaming cues. To this end, PitchSalienceFunction, PitchSalienceFunctionPeaks, PitchContours, and PitchContoursMonoMelody algorithms are employed. It is strongly advised to use the default parameter values which are optimized according to [1] (where further details are provided) except for minFrequency and maxFrequency, which will depend on your application. Check https://essentia.upf.edu/reference/std_PitchMelodia.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [binResolution=10] salience function bin resolution [cents]\r\n    * @param {number} [filterIterations=3] number of iterations for the octave errors / pitch outlier filtering process\r\n    * @param {number} [frameSize=2048] the frame size for computing pitch saliecnce\r\n    * @param {boolean} [guessUnvoiced=false] estimate pitch for non-voiced segments by using non-salient contours when no salient ones are present in a frame\r\n    * @param {number} [harmonicWeight=0.8] harmonic weighting parameter (weight decay ratio between two consequent harmonics, =1 for no decay)\r\n    * @param {number} [hopSize=128] the hop size with which the pitch salience function was computed\r\n    * @param {number} [magnitudeCompression=1] magnitude compression parameter for the salience function (=0 for maximum compression, =1 for no compression)\r\n    * @param {number} [magnitudeThreshold=40] spectral peak magnitude threshold (maximum allowed difference from the highest peak in dBs)\r\n    * @param {number} [maxFrequency=20000] the minimum allowed frequency for salience function peaks (ignore contours with peaks above) [Hz]\r\n    * @param {number} [minDuration=100] the minimum allowed contour duration [ms]\r\n    * @param {number} [minFrequency=40] the minimum allowed frequency for salience function peaks (ignore contours with peaks below) [Hz]\r\n    * @param {number} [numberHarmonics=20] number of considered harmonics\r\n    * @param {number} [peakDistributionThreshold=0.9] allowed deviation below the peak salience mean over all frames (fraction of the standard deviation)\r\n    * @param {number} [peakFrameThreshold=0.9] per-frame salience threshold factor (fraction of the highest peak salience in a frame)\r\n    * @param {number} [pitchContinuity=27.5625] pitch continuity cue (maximum allowed pitch change during 1 ms time period) [cents]\r\n    * @param {number} [referenceFrequency=55] the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [timeContinuity=100] time continuity cue (the maximum allowed gap duration for a pitch contour) [ms]\r\n    * @returns {object} {pitch: 'the estimated pitch values [Hz]', pitchConfidence: 'confidence with which the pitch was detected'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchMelodia = function (signal, binResolution, filterIterations, frameSize, guessUnvoiced, harmonicWeight, hopSize, magnitudeCompression, magnitudeThreshold, maxFrequency, minDuration, minFrequency, numberHarmonics, peakDistributionThreshold, peakFrameThreshold, pitchContinuity, referenceFrequency, sampleRate, timeContinuity) {\r\n        if (binResolution === void 0) { binResolution = 10; }\r\n        if (filterIterations === void 0) { filterIterations = 3; }\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (guessUnvoiced === void 0) { guessUnvoiced = false; }\r\n        if (harmonicWeight === void 0) { harmonicWeight = 0.8; }\r\n        if (hopSize === void 0) { hopSize = 128; }\r\n        if (magnitudeCompression === void 0) { magnitudeCompression = 1; }\r\n        if (magnitudeThreshold === void 0) { magnitudeThreshold = 40; }\r\n        if (maxFrequency === void 0) { maxFrequency = 20000; }\r\n        if (minDuration === void 0) { minDuration = 100; }\r\n        if (minFrequency === void 0) { minFrequency = 40; }\r\n        if (numberHarmonics === void 0) { numberHarmonics = 20; }\r\n        if (peakDistributionThreshold === void 0) { peakDistributionThreshold = 0.9; }\r\n        if (peakFrameThreshold === void 0) { peakFrameThreshold = 0.9; }\r\n        if (pitchContinuity === void 0) { pitchContinuity = 27.5625; }\r\n        if (referenceFrequency === void 0) { referenceFrequency = 55; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (timeContinuity === void 0) { timeContinuity = 100; }\r\n        return this.algorithms.PitchMelodia(signal, binResolution, filterIterations, frameSize, guessUnvoiced, harmonicWeight, hopSize, magnitudeCompression, magnitudeThreshold, maxFrequency, minDuration, minFrequency, numberHarmonics, peakDistributionThreshold, peakFrameThreshold, pitchContinuity, referenceFrequency, sampleRate, timeContinuity);\r\n    };\r\n    /**\r\n    * This algorithm computes the pitch salience of a spectrum. The pitch salience is given by the ratio of the highest auto correlation value of the spectrum to the non-shifted auto correlation value. Pitch salience was designed as quick measure of tone sensation. Unpitched sounds (non-musical sound effects) and pure tones have an average pitch salience value close to 0 whereas sounds containing several harmonics in the spectrum tend to have a higher value. Check https://essentia.upf.edu/reference/std_PitchSalience.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input audio spectrum\r\n    * @param {number} [highBoundary=5000] until which frequency we are looking for the minimum (must be smaller than half sampleRate) [Hz]\r\n    * @param {number} [lowBoundary=100] from which frequency we are looking for the maximum (must not be larger than highBoundary) [Hz]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {pitchSalience: 'the pitch salience (normalized from 0 to 1)'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchSalience = function (spectrum, highBoundary, lowBoundary, sampleRate) {\r\n        if (highBoundary === void 0) { highBoundary = 5000; }\r\n        if (lowBoundary === void 0) { lowBoundary = 100; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.PitchSalience(spectrum, highBoundary, lowBoundary, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the pitch salience function of a signal frame given its spectral peaks. The salience function covers a pitch range of nearly five octaves (i.e., 6000 cents), starting from the \"referenceFrequency\", and is quantized into cent bins according to the specified \"binResolution\". The salience of a given frequency is computed as the sum of the weighted energies found at integer multiples (harmonics) of that frequency.  Check https://essentia.upf.edu/reference/std_PitchSalienceFunction.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frequencies the frequencies of the spectral peaks [Hz]\r\n    * @param {VectorFloat} magnitudes the magnitudes of the spectral peaks\r\n    * @param {number} [binResolution=10] salience function bin resolution [cents]\r\n    * @param {number} [harmonicWeight=0.8] harmonic weighting parameter (weight decay ratio between two consequent harmonics, =1 for no decay)\r\n    * @param {number} [magnitudeCompression=1] magnitude compression parameter (=0 for maximum compression, =1 for no compression)\r\n    * @param {number} [magnitudeThreshold=40] peak magnitude threshold (maximum allowed difference from the highest peak in dBs)\r\n    * @param {number} [numberHarmonics=20] number of considered harmonics\r\n    * @param {number} [referenceFrequency=55] the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin\r\n    * @returns {object} {salienceFunction: 'array of the quantized pitch salience values'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchSalienceFunction = function (frequencies, magnitudes, binResolution, harmonicWeight, magnitudeCompression, magnitudeThreshold, numberHarmonics, referenceFrequency) {\r\n        if (binResolution === void 0) { binResolution = 10; }\r\n        if (harmonicWeight === void 0) { harmonicWeight = 0.8; }\r\n        if (magnitudeCompression === void 0) { magnitudeCompression = 1; }\r\n        if (magnitudeThreshold === void 0) { magnitudeThreshold = 40; }\r\n        if (numberHarmonics === void 0) { numberHarmonics = 20; }\r\n        if (referenceFrequency === void 0) { referenceFrequency = 55; }\r\n        return this.algorithms.PitchSalienceFunction(frequencies, magnitudes, binResolution, harmonicWeight, magnitudeCompression, magnitudeThreshold, numberHarmonics, referenceFrequency);\r\n    };\r\n    /**\r\n    * This algorithm computes the peaks of a given pitch salience function. Check https://essentia.upf.edu/reference/std_PitchSalienceFunctionPeaks.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} salienceFunction the array of salience function values corresponding to cent frequency bins\r\n    * @param {number} [binResolution=10] salience function bin resolution [cents]\r\n    * @param {number} [maxFrequency=1760] the maximum frequency to evaluate (ignore peaks above) [Hz]\r\n    * @param {number} [minFrequency=55] the minimum frequency to evaluate (ignore peaks below) [Hz]\r\n    * @param {number} [referenceFrequency=55] the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin\r\n    * @returns {object} {salienceBins: 'the cent bins corresponding to salience function peaks', salienceValues: 'the values of salience function peaks'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchSalienceFunctionPeaks = function (salienceFunction, binResolution, maxFrequency, minFrequency, referenceFrequency) {\r\n        if (binResolution === void 0) { binResolution = 10; }\r\n        if (maxFrequency === void 0) { maxFrequency = 1760; }\r\n        if (minFrequency === void 0) { minFrequency = 55; }\r\n        if (referenceFrequency === void 0) { referenceFrequency = 55; }\r\n        return this.algorithms.PitchSalienceFunctionPeaks(salienceFunction, binResolution, maxFrequency, minFrequency, referenceFrequency);\r\n    };\r\n    /**\r\n    * This algorithm estimates the fundamental frequency given the frame of a monophonic music signal. It is an implementation of the Yin algorithm [1] for computations in the time domain. Check https://essentia.upf.edu/reference/std_PitchYin.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal frame\r\n    * @param {number} [frameSize=2048] number of samples in the input frame (this is an optional parameter to optimize memory allocation)\r\n    * @param {boolean} [interpolate=true] enable interpolation\r\n    * @param {number} [maxFrequency=22050] the maximum allowed frequency [Hz]\r\n    * @param {number} [minFrequency=20] the minimum allowed frequency [Hz]\r\n    * @param {number} [sampleRate=44100] sampling rate of the input audio [Hz]\r\n    * @param {number} [tolerance=0.15] tolerance for peak detection\r\n    * @returns {object} {pitch: 'detected pitch [Hz]', pitchConfidence: 'confidence with which the pitch was detected [0,1]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchYin = function (signal, frameSize, interpolate, maxFrequency, minFrequency, sampleRate, tolerance) {\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (interpolate === void 0) { interpolate = true; }\r\n        if (maxFrequency === void 0) { maxFrequency = 22050; }\r\n        if (minFrequency === void 0) { minFrequency = 20; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (tolerance === void 0) { tolerance = 0.15; }\r\n        return this.algorithms.PitchYin(signal, frameSize, interpolate, maxFrequency, minFrequency, sampleRate, tolerance);\r\n    };\r\n    /**\r\n    * This algorithm estimates the fundamental frequency given the spectrum of a monophonic music signal. It is an implementation of YinFFT algorithm [1], which is an optimized version of Yin algorithm for computation in the frequency domain. It is recommended to window the input spectrum with a Hann window. The raw spectrum can be computed with the Spectrum algorithm. Check https://essentia.upf.edu/reference/std_PitchYinFFT.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input spectrum (preferably created with a hann window)\r\n    * @param {number} [frameSize=2048] number of samples in the input spectrum\r\n    * @param {boolean} [interpolate=true] boolean flag to enable interpolation\r\n    * @param {number} [maxFrequency=22050] the maximum allowed frequency [Hz]\r\n    * @param {number} [minFrequency=20] the minimum allowed frequency [Hz]\r\n    * @param {number} [sampleRate=44100] sampling rate of the input spectrum [Hz]\r\n    * @param {number} [tolerance=1] tolerance for peak detection\r\n    * @returns {object} {pitch: 'detected pitch [Hz]', pitchConfidence: 'confidence with which the pitch was detected [0,1]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchYinFFT = function (spectrum, frameSize, interpolate, maxFrequency, minFrequency, sampleRate, tolerance) {\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (interpolate === void 0) { interpolate = true; }\r\n        if (maxFrequency === void 0) { maxFrequency = 22050; }\r\n        if (minFrequency === void 0) { minFrequency = 20; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (tolerance === void 0) { tolerance = 1; }\r\n        return this.algorithms.PitchYinFFT(spectrum, frameSize, interpolate, maxFrequency, minFrequency, sampleRate, tolerance);\r\n    };\r\n    /**\r\n    * This algorithm computes the pitch track of a mono audio signal using probabilistic Yin algorithm. Check https://essentia.upf.edu/reference/std_PitchYinProbabilistic.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input mono audio signal\r\n    * @param {number} [frameSize=2048] the frame size of FFT\r\n    * @param {number} [hopSize=256] the hop size with which the pitch is computed\r\n    * @param {number} [lowRMSThreshold=0.1] the low RMS amplitude threshold\r\n    * @param {string} [outputUnvoiced=negative] whether output unvoiced frame, zero: output non-voiced pitch as 0.; abs: output non-voiced pitch as absolute values; negative: output non-voiced pitch as negative values\r\n    * @param {boolean} [preciseTime=false] use non-standard precise YIN timing (slow).\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {pitch: 'the output pitch estimations', voicedProbabilities: 'the voiced probabilities'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchYinProbabilistic = function (signal, frameSize, hopSize, lowRMSThreshold, outputUnvoiced, preciseTime, sampleRate) {\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (hopSize === void 0) { hopSize = 256; }\r\n        if (lowRMSThreshold === void 0) { lowRMSThreshold = 0.1; }\r\n        if (outputUnvoiced === void 0) { outputUnvoiced = 'negative'; }\r\n        if (preciseTime === void 0) { preciseTime = false; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.PitchYinProbabilistic(signal, frameSize, hopSize, lowRMSThreshold, outputUnvoiced, preciseTime, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm estimates the fundamental frequencies, their probabilities given the frame of a monophonic music signal. It is a part of the implementation of the probabilistic Yin algorithm [1]. Check https://essentia.upf.edu/reference/std_PitchYinProbabilities.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal frame\r\n    * @param {number} [frameSize=2048] number of samples in the input frame\r\n    * @param {number} [lowAmp=0.1] the low RMS amplitude threshold\r\n    * @param {boolean} [preciseTime=false] use non-standard precise YIN timing (slow).\r\n    * @param {number} [sampleRate=44100] sampling rate of the input audio [Hz]\r\n    * @returns {object} {pitch: 'the output pitch candidate frequencies in cents', probabilities: 'the output pitch candidate probabilities', RMS: 'the output RMS value'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchYinProbabilities = function (signal, frameSize, lowAmp, preciseTime, sampleRate) {\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (lowAmp === void 0) { lowAmp = 0.1; }\r\n        if (preciseTime === void 0) { preciseTime = false; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.PitchYinProbabilities(signal, frameSize, lowAmp, preciseTime, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm estimates the smoothed fundamental frequency given the pitch candidates and probabilities using hidden Markov models. It is a part of the implementation of the probabilistic Yin algorithm [1]. Check https://essentia.upf.edu/reference/std_PitchYinProbabilitiesHMM.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} pitchCandidates the pitch candidates\r\n    * @param {VectorVectorFloat} probabilities the pitch probabilities\r\n    * @param {number} [minFrequency=61.735] minimum detected frequency\r\n    * @param {number} [numberBinsPerSemitone=5] number of bins per semitone\r\n    * @param {number} [selfTransition=0.99] the self transition probabilities\r\n    * @param {number} [yinTrust=0.5] the yin trust parameter\r\n    * @returns {object} {pitch: 'pitch frequencies in Hz'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PitchYinProbabilitiesHMM = function (pitchCandidates, probabilities, minFrequency, numberBinsPerSemitone, selfTransition, yinTrust) {\r\n        if (minFrequency === void 0) { minFrequency = 61.735; }\r\n        if (numberBinsPerSemitone === void 0) { numberBinsPerSemitone = 5; }\r\n        if (selfTransition === void 0) { selfTransition = 0.99; }\r\n        if (yinTrust === void 0) { yinTrust = 0.5; }\r\n        return this.algorithms.PitchYinProbabilitiesHMM(pitchCandidates, probabilities, minFrequency, numberBinsPerSemitone, selfTransition, yinTrust);\r\n    };\r\n    /**\r\n    * This algorithm computes the power mean of an array. It accepts one parameter, p, which is the power (or order or degree) of the Power Mean. Note that if p=-1, the Power Mean is equal to the Harmonic Mean, if p=0, the Power Mean is equal to the Geometric Mean, if p=1, the Power Mean is equal to the Arithmetic Mean, if p=2, the Power Mean is equal to the Root Mean Square. Check https://essentia.upf.edu/reference/std_PowerMean.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array (must contain only positive real numbers)\r\n    * @param {number} [power=1] the power to which to elevate each element before taking the mean\r\n    * @returns {object} {powerMean: 'the power mean of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PowerMean = function (array, power) {\r\n        if (power === void 0) { power = 1; }\r\n        return this.algorithms.PowerMean(array, power);\r\n    };\r\n    /**\r\n    * This algorithm computes the power spectrum of an array of Reals. The resulting power spectrum has a size which is half the size of the input array plus one. Bins contain squared magnitude values. Check https://essentia.upf.edu/reference/std_PowerSpectrum.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [size=2048] the expected size of the input frame (this is purely optional and only targeted at optimizing the creation time of the FFT object)\r\n    * @returns {object} {powerSpectrum: 'power spectrum of the input signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PowerSpectrum = function (signal, size) {\r\n        if (size === void 0) { size = 2048; }\r\n        return this.algorithms.PowerSpectrum(signal, size);\r\n    };\r\n    /**\r\n    * This algorithm estimates the fundamental frequency of the predominant melody from polyphonic music signals using the MELODIA algorithm. It is specifically suited for music with a predominent melodic element, for example the singing voice melody in an accompanied singing recording. The approach [1] is based on the creation and characterization of pitch contours, time continuous sequences of pitch candidates grouped using auditory streaming cues. It furthermore determines for each frame, if the predominant melody is present or not. To this end, PitchSalienceFunction, PitchSalienceFunctionPeaks, PitchContours, and PitchContoursMelody algorithms are employed. It is strongly advised to use the default parameter values which are optimized according to [1] (where further details are provided) except for minFrequency, maxFrequency, and voicingTolerance, which will depend on your application. Check https://essentia.upf.edu/reference/std_PredominantPitchMelodia.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [binResolution=10] salience function bin resolution [cents]\r\n    * @param {number} [filterIterations=3] number of iterations for the octave errors / pitch outlier filtering process\r\n    * @param {number} [frameSize=2048] the frame size for computing pitch salience\r\n    * @param {boolean} [guessUnvoiced=false] estimate pitch for non-voiced segments by using non-salient contours when no salient ones are present in a frame\r\n    * @param {number} [harmonicWeight=0.8] harmonic weighting parameter (weight decay ratio between two consequent harmonics, =1 for no decay)\r\n    * @param {number} [hopSize=128] the hop size with which the pitch salience function was computed\r\n    * @param {number} [magnitudeCompression=1] magnitude compression parameter for the salience function (=0 for maximum compression, =1 for no compression)\r\n    * @param {number} [magnitudeThreshold=40] spectral peak magnitude threshold (maximum allowed difference from the highest peak in dBs)\r\n    * @param {number} [maxFrequency=20000] the minimum allowed frequency for salience function peaks (ignore contours with peaks above) [Hz]\r\n    * @param {number} [minDuration=100] the minimum allowed contour duration [ms]\r\n    * @param {number} [minFrequency=80] the minimum allowed frequency for salience function peaks (ignore contours with peaks below) [Hz]\r\n    * @param {number} [numberHarmonics=20] number of considered harmonics\r\n    * @param {number} [peakDistributionThreshold=0.9] allowed deviation below the peak salience mean over all frames (fraction of the standard deviation)\r\n    * @param {number} [peakFrameThreshold=0.9] per-frame salience threshold factor (fraction of the highest peak salience in a frame)\r\n    * @param {number} [pitchContinuity=27.5625] pitch continuity cue (maximum allowed pitch change during 1 ms time period) [cents]\r\n    * @param {number} [referenceFrequency=55] the reference frequency for Hertz to cent conversion [Hz], corresponding to the 0th cent bin\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [timeContinuity=100] time continuity cue (the maximum allowed gap duration for a pitch contour) [ms]\r\n    * @param {boolean} [voiceVibrato=false] detect voice vibrato\r\n    * @param {number} [voicingTolerance=0.2] allowed deviation below the average contour mean salience of all contours (fraction of the standard deviation)\r\n    * @returns {object} {pitch: 'the estimated pitch values [Hz]', pitchConfidence: 'confidence with which the pitch was detected'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.PredominantPitchMelodia = function (signal, binResolution, filterIterations, frameSize, guessUnvoiced, harmonicWeight, hopSize, magnitudeCompression, magnitudeThreshold, maxFrequency, minDuration, minFrequency, numberHarmonics, peakDistributionThreshold, peakFrameThreshold, pitchContinuity, referenceFrequency, sampleRate, timeContinuity, voiceVibrato, voicingTolerance) {\r\n        if (binResolution === void 0) { binResolution = 10; }\r\n        if (filterIterations === void 0) { filterIterations = 3; }\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (guessUnvoiced === void 0) { guessUnvoiced = false; }\r\n        if (harmonicWeight === void 0) { harmonicWeight = 0.8; }\r\n        if (hopSize === void 0) { hopSize = 128; }\r\n        if (magnitudeCompression === void 0) { magnitudeCompression = 1; }\r\n        if (magnitudeThreshold === void 0) { magnitudeThreshold = 40; }\r\n        if (maxFrequency === void 0) { maxFrequency = 20000; }\r\n        if (minDuration === void 0) { minDuration = 100; }\r\n        if (minFrequency === void 0) { minFrequency = 80; }\r\n        if (numberHarmonics === void 0) { numberHarmonics = 20; }\r\n        if (peakDistributionThreshold === void 0) { peakDistributionThreshold = 0.9; }\r\n        if (peakFrameThreshold === void 0) { peakFrameThreshold = 0.9; }\r\n        if (pitchContinuity === void 0) { pitchContinuity = 27.5625; }\r\n        if (referenceFrequency === void 0) { referenceFrequency = 55; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (timeContinuity === void 0) { timeContinuity = 100; }\r\n        if (voiceVibrato === void 0) { voiceVibrato = false; }\r\n        if (voicingTolerance === void 0) { voicingTolerance = 0.2; }\r\n        return this.algorithms.PredominantPitchMelodia(signal, binResolution, filterIterations, frameSize, guessUnvoiced, harmonicWeight, hopSize, magnitudeCompression, magnitudeThreshold, maxFrequency, minDuration, minFrequency, numberHarmonics, peakDistributionThreshold, peakFrameThreshold, pitchContinuity, referenceFrequency, sampleRate, timeContinuity, voiceVibrato, voicingTolerance);\r\n    };\r\n    /**\r\n    * This algorithm computes the root mean square (quadratic mean) of an array.\r\n    RMS is not defined for empty arrays. In such case, an exception will be thrown\r\n    .\r\n    References:\r\n      [1] Root mean square - Wikipedia, the free encyclopedia,\r\n      http://en.wikipedia.org/wiki/Root_mean_square Check https://essentia.upf.edu/reference/std_RMS.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @returns {object} {rms: 'the root mean square of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.RMS = function (array) {\r\n        return this.algorithms.RMS(array);\r\n    };\r\n    /**\r\n    * This algorithm computes the first 5 raw moments of an array. The output array is of size 6 because the zero-ith moment is used for padding so that the first moment corresponds to index 1. Check https://essentia.upf.edu/reference/std_RawMoments.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @param {number} [range=22050] the range of the input array, used for normalizing the results\r\n    * @returns {object} {rawMoments: 'the (raw) moments of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.RawMoments = function (array, range) {\r\n        if (range === void 0) { range = 22050; }\r\n        return this.algorithms.RawMoments(array, range);\r\n    };\r\n    /**\r\n    * This algorithm computes the Replay Gain loudness value of an audio signal. The algorithm is described in detail in [1]. The value returned is the 'standard' ReplayGain value, not the value with 6dB preamplification as computed by lame, mp3gain, vorbisgain, and all widely used ReplayGain programs. Check https://essentia.upf.edu/reference/std_ReplayGain.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio signal (must be longer than 0.05ms)\r\n    * @param {number} [sampleRate=44100] the sampling rate of the input audio signal [Hz]\r\n    * @returns {object} {replayGain: 'the distance to the suitable average replay level (~-31dbB) defined by SMPTE [dB]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.ReplayGain = function (signal, sampleRate) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.ReplayGain(signal, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm resamples the input signal to the desired sampling rate. Check https://essentia.upf.edu/reference/std_Resample.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [inputSampleRate=44100] the sampling rate of the input signal [Hz]\r\n    * @param {number} [outputSampleRate=44100] the sampling rate of the output signal [Hz]\r\n    * @param {number} [quality=1] the quality of the conversion, 0 for best quality\r\n    * @returns {object} {signal: 'the resampled signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Resample = function (signal, inputSampleRate, outputSampleRate, quality) {\r\n        if (inputSampleRate === void 0) { inputSampleRate = 44100; }\r\n        if (outputSampleRate === void 0) { outputSampleRate = 44100; }\r\n        if (quality === void 0) { quality = 1; }\r\n        return this.algorithms.Resample(signal, inputSampleRate, outputSampleRate, quality);\r\n    };\r\n    /**\r\n    * This algorithm resamples a sequence using FFT / IFFT. The input and output sizes must be an even number. (It is meant to be eqivalent to the resample function in Numpy). Check https://essentia.upf.edu/reference/std_ResampleFFT.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} input input array\r\n    * @param {number} [inSize=128] the size of the input sequence. It needss to be even-sized.\r\n    * @param {number} [outSize=128] the size of the output sequence. It needss to be even-sized.\r\n    * @returns {object} {output: 'output resample array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.ResampleFFT = function (input, inSize, outSize) {\r\n        if (inSize === void 0) { inSize = 128; }\r\n        if (outSize === void 0) { outSize = 128; }\r\n        return this.algorithms.ResampleFFT(input, inSize, outSize);\r\n    };\r\n    /**\r\n    * This algorithm computes rhythm features (bpm, beat positions, beat histogram peaks) for an audio signal. It combines RhythmExtractor2013 for beat tracking and BPM estimation with BpmHistogramDescriptors algorithms. Check https://essentia.upf.edu/reference/std_RhythmDescriptors.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the audio input signal\r\n    * @returns {object} {beats_position: 'See RhythmExtractor2013 algorithm documentation', confidence: 'See RhythmExtractor2013 algorithm documentation', bpm: 'See RhythmExtractor2013 algorithm documentation', bpm_estimates: 'See RhythmExtractor2013 algorithm documentation', bpm_intervals: 'See RhythmExtractor2013 algorithm documentation', first_peak_bpm: 'See BpmHistogramDescriptors algorithm documentation', first_peak_spread: 'See BpmHistogramDescriptors algorithm documentation', first_peak_weight: 'See BpmHistogramDescriptors algorithm documentation', second_peak_bpm: 'See BpmHistogramDescriptors algorithm documentation', second_peak_spread: 'See BpmHistogramDescriptors algorithm documentation', second_peak_weight: 'See BpmHistogramDescriptors algorithm documentation', histogram: 'bpm histogram [bpm]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.RhythmDescriptors = function (signal) {\r\n        return this.algorithms.RhythmDescriptors(signal);\r\n    };\r\n    /**\r\n    * This algorithm estimates the tempo in bpm and beat positions given an audio signal. The algorithm combines several periodicity functions and estimates beats using TempoTap and TempoTapTicks. It combines:\r\n    - onset detection functions based on high-frequency content (see OnsetDetection)\r\n    - complex-domain spectral difference function (see OnsetDetection)\r\n    - periodicity function based on energy bands (see FrequencyBands, TempoScaleBands) Check https://essentia.upf.edu/reference/std_RhythmExtractor.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the audio input signal\r\n    * @param {number} [frameHop=1024] the number of feature frames separating two evaluations\r\n    * @param {number} [frameSize=1024] the number audio samples used to compute a feature\r\n    * @param {number} [hopSize=256] the number of audio samples per features\r\n    * @param {number} [lastBeatInterval=0.1] the minimum interval between last beat and end of file [s]\r\n    * @param {number} [maxTempo=208] the fastest tempo to detect [bpm]\r\n    * @param {number} [minTempo=40] the slowest tempo to detect [bpm]\r\n    * @param {number} [numberFrames=1024] the number of feature frames to buffer on\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {any[]} [tempoHints=[]] the optional list of initial beat locations, to favor the detection of pre-determined tempo period and beats alignment [s]\r\n    * @param {number} [tolerance=0.24] the minimum interval between two consecutive beats [s]\r\n    * @param {boolean} [useBands=true] whether or not to use band energy as periodicity function\r\n    * @param {boolean} [useOnset=true] whether or not to use onsets as periodicity function\r\n    * @returns {object} {bpm: 'the tempo estimation [bpm]', ticks: ' the estimated tick locations [s]', estimates: 'the bpm estimation per frame [bpm]', bpmIntervals: 'list of beats interval [s]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.RhythmExtractor = function (signal, frameHop, frameSize, hopSize, lastBeatInterval, maxTempo, minTempo, numberFrames, sampleRate, tempoHints, tolerance, useBands, useOnset) {\r\n        if (frameHop === void 0) { frameHop = 1024; }\r\n        if (frameSize === void 0) { frameSize = 1024; }\r\n        if (hopSize === void 0) { hopSize = 256; }\r\n        if (lastBeatInterval === void 0) { lastBeatInterval = 0.1; }\r\n        if (maxTempo === void 0) { maxTempo = 208; }\r\n        if (minTempo === void 0) { minTempo = 40; }\r\n        if (numberFrames === void 0) { numberFrames = 1024; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (tempoHints === void 0) { tempoHints = []; }\r\n        if (tolerance === void 0) { tolerance = 0.24; }\r\n        if (useBands === void 0) { useBands = true; }\r\n        if (useOnset === void 0) { useOnset = true; }\r\n        var vectempoHints = new this.module.VectorFloat();\r\n        for (var i = 0; i < vectempoHints.size(); i++) {\r\n            vectempoHints.push_back(tempoHints[i]);\r\n        }\r\n        return this.algorithms.RhythmExtractor(signal, frameHop, frameSize, hopSize, lastBeatInterval, maxTempo, minTempo, numberFrames, sampleRate, vectempoHints, tolerance, useBands, useOnset);\r\n    };\r\n    /**\r\n    * This algorithm extracts the beat positions and estimates their confidence as well as tempo in bpm for an audio signal. The beat locations can be computed using:\r\n      - 'multifeature', the BeatTrackerMultiFeature algorithm\r\n      - 'degara', the BeatTrackerDegara algorithm (note that there is no confidence estimation for this method, the output confidence value is always 0) Check https://essentia.upf.edu/reference/std_RhythmExtractor2013.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the audio input signal\r\n    * @param {number} [maxTempo=208] the fastest tempo to detect [bpm]\r\n    * @param {string} [method=multifeature] the method used for beat tracking\r\n    * @param {number} [minTempo=40] the slowest tempo to detect [bpm]\r\n    * @returns {object} {bpm: 'the tempo estimation [bpm]', ticks: ' the estimated tick locations [s]', confidence: 'confidence with which the ticks are detected (ignore this value if using 'degara' method)', estimates: 'the list of bpm estimates characterizing the bpm distribution for the signal [bpm]', bpmIntervals: 'list of beats interval [s]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.RhythmExtractor2013 = function (signal, maxTempo, method, minTempo) {\r\n        if (maxTempo === void 0) { maxTempo = 208; }\r\n        if (method === void 0) { method = 'multifeature'; }\r\n        if (minTempo === void 0) { minTempo = 40; }\r\n        return this.algorithms.RhythmExtractor2013(signal, maxTempo, method, minTempo);\r\n    };\r\n    /**\r\n    * This algorithm implements the rhythm transform. It computes a tempogram, a representation of rhythmic periodicities in the input signal in the rhythm domain, by using FFT similarly to computation of spectrum in the frequency domain [1]. Additional features, including rhythmic centroid and a rhythmic counterpart of MFCCs, can be derived from this rhythmic representation. Check https://essentia.upf.edu/reference/std_RhythmTransform.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} melBands the energies in the mel bands\r\n    * @param {number} [frameSize=256] the frame size to compute the rhythm trasform\r\n    * @param {number} [hopSize=32] the hop size to compute the rhythm transform\r\n    * @returns {object} {rhythm: 'consecutive frames in the rhythm domain'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.RhythmTransform = function (melBands, frameSize, hopSize) {\r\n        if (frameSize === void 0) { frameSize = 256; }\r\n        if (hopSize === void 0) { hopSize = 32; }\r\n        return this.algorithms.RhythmTransform(melBands, frameSize, hopSize);\r\n    };\r\n    /**\r\n    * This algorithm computes the roll-off frequency of a spectrum. The roll-off frequency is defined as the frequency under which some percentage (cutoff) of the total energy of the spectrum is contained. The roll-off frequency can be used to distinguish between harmonic (below roll-off) and noisy sounds (above roll-off). Check https://essentia.upf.edu/reference/std_RollOff.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input audio spectrum (must have more than one elements)\r\n    * @param {number} [cutoff=0.85] the ratio of total energy to attain before yielding the roll-off frequency\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal (used to normalize rollOff) [Hz]\r\n    * @returns {object} {rollOff: 'the roll-off frequency [Hz]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.RollOff = function (spectrum, cutoff, sampleRate) {\r\n        if (cutoff === void 0) { cutoff = 0.85; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.RollOff(spectrum, cutoff, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the SNR of the input audio in a frame-wise manner. The algorithm assumes that:\r\n      1. The noise is gaussian.\r\n      2. There is a region of noise (without signal) at the beginning of the stream in order to estimate the PSD of the noise.[1]\r\n    Once the noise PSD is estimated, the algorithm relies on the Ephraim-Malah [2] recursion to estimate the SNR for each frequency bin.\r\n    The algorithm also returns an overall (a single value for the whole spectrum) SNR estimation and an averaged overall SNR estimation using Exponential Moving Average filtering.\r\n    This algorithm throws a Warning if less than 15 frames are used to estimte the noise PSD. Check https://essentia.upf.edu/reference/std_SNR.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input audio frame\r\n    * @param {number} [MAAlpha=0.95] Alpha coefficient for the EMA SNR estimation [2]\r\n    * @param {number} [MMSEAlpha=0.98] Alpha coefficient for the MMSE estimation [1].\r\n    * @param {number} [NoiseAlpha=0.9] Alpha coefficient for the EMA noise estimation [2]\r\n    * @param {number} [frameSize=512] the size of the input frame\r\n    * @param {number} [noiseThreshold=-40] Threshold to detect frames without signal\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {boolean} [useBroadbadNoiseCorrection=true] flag to apply the -10 * log10(BW) broadband noise correction factor\r\n    * @returns {object} {instantSNR: 'SNR value for the the current frame', averagedSNR: 'averaged SNR through an Exponential Moving Average filter', spectralSNR: 'instant SNR for each frequency bin'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SNR = function (frame, MAAlpha, MMSEAlpha, NoiseAlpha, frameSize, noiseThreshold, sampleRate, useBroadbadNoiseCorrection) {\r\n        if (MAAlpha === void 0) { MAAlpha = 0.95; }\r\n        if (MMSEAlpha === void 0) { MMSEAlpha = 0.98; }\r\n        if (NoiseAlpha === void 0) { NoiseAlpha = 0.9; }\r\n        if (frameSize === void 0) { frameSize = 512; }\r\n        if (noiseThreshold === void 0) { noiseThreshold = -40; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (useBroadbadNoiseCorrection === void 0) { useBroadbadNoiseCorrection = true; }\r\n        return this.algorithms.SNR(frame, MAAlpha, MMSEAlpha, NoiseAlpha, frameSize, noiseThreshold, sampleRate, useBroadbadNoiseCorrection);\r\n    };\r\n    /**\r\n    * this algorithm outputs the staring/ending locations of the saturated regions in seconds. Saturated regions are found by means of a tripe criterion:\r\n       1. samples in a saturated region should have more energy than a given threshold.\r\n       2. the difference between the samples in a saturated region should be smaller than a given threshold.\r\n       3. the duration of the saturated region should be longer than a given threshold. Check https://essentia.upf.edu/reference/std_SaturationDetector.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input audio frame\r\n    * @param {number} [differentialThreshold=0.001] minimum difference between contiguous samples of the salturated regions\r\n    * @param {number} [energyThreshold=-1] mininimum energy of the samples in the saturated regions [dB]\r\n    * @param {number} [frameSize=512] expected input frame size\r\n    * @param {number} [hopSize=256] hop size used for the analysis\r\n    * @param {number} [minimumDuration=0.005] minimum duration of the saturated regions [ms]\r\n    * @param {number} [sampleRate=44100] sample rate used for the analysis\r\n    * @returns {object} {starts: 'starting times of the detected saturated regions [s]', ends: 'ending times of the detected saturated regions [s]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SaturationDetector = function (frame, differentialThreshold, energyThreshold, frameSize, hopSize, minimumDuration, sampleRate) {\r\n        if (differentialThreshold === void 0) { differentialThreshold = 0.001; }\r\n        if (energyThreshold === void 0) { energyThreshold = -1; }\r\n        if (frameSize === void 0) { frameSize = 512; }\r\n        if (hopSize === void 0) { hopSize = 256; }\r\n        if (minimumDuration === void 0) { minimumDuration = 0.005; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.SaturationDetector(frame, differentialThreshold, energyThreshold, frameSize, hopSize, minimumDuration, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm scales the audio by the specified factor using clipping if required. Check https://essentia.upf.edu/reference/std_Scale.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio signal\r\n    * @param {boolean} [clipping=true] boolean flag whether to apply clipping or not\r\n    * @param {number} [factor=10] the multiplication factor by which the audio will be scaled\r\n    * @param {number} [maxAbsValue=1] the maximum value above which to apply clipping\r\n    * @returns {object} {signal: 'the output audio signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Scale = function (signal, clipping, factor, maxAbsValue) {\r\n        if (clipping === void 0) { clipping = true; }\r\n        if (factor === void 0) { factor = 10; }\r\n        if (maxAbsValue === void 0) { maxAbsValue = 1; }\r\n        return this.algorithms.Scale(signal, clipping, factor, maxAbsValue);\r\n    };\r\n    /**\r\n    * This algorithm subtracts the sinusoids computed with the sine model analysis from an input audio signal. It ouputs an audio signal. Check https://essentia.upf.edu/reference/std_SineSubtraction.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input audio frame to subtract from\r\n    * @param {VectorFloat} magnitudes the magnitudes of the sinusoidal peaks\r\n    * @param {VectorFloat} frequencies the frequencies of the sinusoidal peaks [Hz]\r\n    * @param {VectorFloat} phases the phases of the sinusoidal peaks\r\n    * @param {number} [fftSize=512] the size of the FFT internal process (full spectrum size) and output frame. Minimum twice the hopsize.\r\n    * @param {number} [hopSize=128] the hop size between frames\r\n    * @param {number} [sampleRate=44100] the audio sampling rate [Hz]\r\n    * @returns {object} {frame: 'the output audio frame'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SineSubtraction = function (frame, magnitudes, frequencies, phases, fftSize, hopSize, sampleRate) {\r\n        if (fftSize === void 0) { fftSize = 512; }\r\n        if (hopSize === void 0) { hopSize = 128; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.SineSubtraction(frame, magnitudes, frequencies, phases, fftSize, hopSize, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the spectrum energy of a single beat across the whole frequency range and on each specified frequency band given an audio segment. It detects the onset of the beat within the input segment, computes spectrum on a window starting on this onset, and estimates energy (see Energy and EnergyBandRatio algorithms). The frequency bands used by default are: 0-200 Hz, 200-400 Hz, 400-800 Hz, 800-1600 Hz, 1600-3200 Hz, 3200-22000Hz, following E. Scheirer [1]. Check https://essentia.upf.edu/reference/std_SingleBeatLoudness.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} beat audio segement containing a beat\r\n    * @param {number} [beatDuration=0.05] window size for the beat's energy computation (the window starts at the onset) [s]\r\n    * @param {number} [beatWindowDuration=0.1] window size for the beat's onset detection [s]\r\n    * @param {any[]} [frequencyBands=[0, 200, 400, 800, 1600, 3200, 22000]] frequency bands\r\n    * @param {string} [onsetStart=sumEnergy] criteria for finding the start of the beat\r\n    * @param {number} [sampleRate=44100] the audio sampling rate [Hz]\r\n    * @returns {object} {loudness: 'the beat's energy across the whole spectrum', loudnessBandRatio: 'the beat's energy ratio for each band'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SingleBeatLoudness = function (beat, beatDuration, beatWindowDuration, frequencyBands, onsetStart, sampleRate) {\r\n        if (beatDuration === void 0) { beatDuration = 0.05; }\r\n        if (beatWindowDuration === void 0) { beatWindowDuration = 0.1; }\r\n        if (frequencyBands === void 0) { frequencyBands = [0, 200, 400, 800, 1600, 3200, 22000]; }\r\n        if (onsetStart === void 0) { onsetStart = 'sumEnergy'; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        var vecfrequencyBands = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecfrequencyBands.size(); i++) {\r\n            vecfrequencyBands.push_back(frequencyBands[i]);\r\n        }\r\n        return this.algorithms.SingleBeatLoudness(beat, beatDuration, beatWindowDuration, vecfrequencyBands, onsetStart, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm splits an audio signal into segments given their start and end times. Check https://essentia.upf.edu/reference/std_Slicer.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} audio the input audio signal\r\n    * @param {any[]} [endTimes=[]] the list of end times for the slices you want to extract\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {any[]} [startTimes=[]] the list of start times for the slices you want to extract\r\n    * @param {string} [timeUnits=seconds] the units of time of the start and end times\r\n    * @returns {object} {frame: 'the frames of the sliced input signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Slicer = function (audio, endTimes, sampleRate, startTimes, timeUnits) {\r\n        if (endTimes === void 0) { endTimes = []; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (startTimes === void 0) { startTimes = []; }\r\n        if (timeUnits === void 0) { timeUnits = 'seconds'; }\r\n        var vecendTimes = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecendTimes.size(); i++) {\r\n            vecendTimes.push_back(endTimes[i]);\r\n        }\r\n        var vecstartTimes = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecstartTimes.size(); i++) {\r\n            vecstartTimes.push_back(startTimes[i]);\r\n        }\r\n        return this.algorithms.Slicer(audio, vecendTimes, sampleRate, vecstartTimes, timeUnits);\r\n    };\r\n    /**\r\n    * This algorithm computes the spectral centroid of a signal in time domain. A first difference filter is applied to the input signal. Then the centroid is computed by dividing the norm of the resulting signal by the norm of the input signal. The centroid is given in hertz.\r\n    References:\r\n     [1] Udo Zölzer (2002). DAFX Digital Audio Effects pag.364-365\r\n     Check https://essentia.upf.edu/reference/std_SpectralCentroidTime.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @param {number} [sampleRate=44100] sampling rate of the input spectrum [Hz]\r\n    * @returns {object} {centroid: 'the spectral centroid of the signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SpectralCentroidTime = function (array, sampleRate) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.SpectralCentroidTime(array, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the spectral complexity of a spectrum. The spectral complexity is based on the number of peaks in the input spectrum. Check https://essentia.upf.edu/reference/std_SpectralComplexity.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input spectrum\r\n    * @param {number} [magnitudeThreshold=0.005] the minimum spectral-peak magnitude that contributes to spectral complexity\r\n    * @param {number} [sampleRate=44100] the audio sampling rate [Hz]\r\n    * @returns {object} {spectralComplexity: 'the spectral complexity of the input spectrum'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SpectralComplexity = function (spectrum, magnitudeThreshold, sampleRate) {\r\n        if (magnitudeThreshold === void 0) { magnitudeThreshold = 0.005; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.SpectralComplexity(spectrum, magnitudeThreshold, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the Spectral Contrast feature of a spectrum. It is based on the Octave Based Spectral Contrast feature as described in [1]. The version implemented here is a modified version to improve discriminative power and robustness. The modifications are described in [2]. Check https://essentia.upf.edu/reference/std_SpectralContrast.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the audio spectrum\r\n    * @param {number} [frameSize=2048] the size of the fft frames\r\n    * @param {number} [highFrequencyBound=11000] the upper bound of the highest band\r\n    * @param {number} [lowFrequencyBound=20] the lower bound of the lowest band\r\n    * @param {number} [neighbourRatio=0.4] the ratio of the bins in the sub band used to calculate the peak and valley\r\n    * @param {number} [numberBands=6] the number of bands in the filter\r\n    * @param {number} [sampleRate=22050] the sampling rate of the audio signal\r\n    * @param {number} [staticDistribution=0.15] the ratio of the bins to distribute equally\r\n    * @returns {object} {spectralContrast: 'the spectral contrast coefficients', spectralValley: 'the magnitudes of the valleys'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SpectralContrast = function (spectrum, frameSize, highFrequencyBound, lowFrequencyBound, neighbourRatio, numberBands, sampleRate, staticDistribution) {\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (highFrequencyBound === void 0) { highFrequencyBound = 11000; }\r\n        if (lowFrequencyBound === void 0) { lowFrequencyBound = 20; }\r\n        if (neighbourRatio === void 0) { neighbourRatio = 0.4; }\r\n        if (numberBands === void 0) { numberBands = 6; }\r\n        if (sampleRate === void 0) { sampleRate = 22050; }\r\n        if (staticDistribution === void 0) { staticDistribution = 0.15; }\r\n        return this.algorithms.SpectralContrast(spectrum, frameSize, highFrequencyBound, lowFrequencyBound, neighbourRatio, numberBands, sampleRate, staticDistribution);\r\n    };\r\n    /**\r\n    * This algorithm extracts peaks from a spectrum. It is important to note that the peak algorithm is independent of an input that is linear or in dB, so one has to adapt the threshold to fit with the type of data fed to it. The algorithm relies on PeakDetection algorithm which is run with parabolic interpolation [1]. The exactness of the peak-searching depends heavily on the windowing type. It gives best results with dB input, a blackman-harris 92dB window and interpolation set to true. According to [1], spectral peak frequencies tend to be about twice as accurate when dB magnitude is used rather than just linear magnitude. For further information about the peak detection, see the description of the PeakDetection algorithm. Check https://essentia.upf.edu/reference/std_SpectralPeaks.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input spectrum\r\n    * @param {number} [magnitudeThreshold=0] peaks below this given threshold are not outputted\r\n    * @param {number} [maxFrequency=5000] the maximum frequency of the range to evaluate [Hz]\r\n    * @param {number} [maxPeaks=100] the maximum number of returned peaks\r\n    * @param {number} [minFrequency=0] the minimum frequency of the range to evaluate [Hz]\r\n    * @param {string} [orderBy=frequency] the ordering type of the outputted peaks (ascending by frequency or descending by magnitude)\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {frequencies: 'the frequencies of the spectral peaks [Hz]', magnitudes: 'the magnitudes of the spectral peaks'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SpectralPeaks = function (spectrum, magnitudeThreshold, maxFrequency, maxPeaks, minFrequency, orderBy, sampleRate) {\r\n        if (magnitudeThreshold === void 0) { magnitudeThreshold = 0; }\r\n        if (maxFrequency === void 0) { maxFrequency = 5000; }\r\n        if (maxPeaks === void 0) { maxPeaks = 100; }\r\n        if (minFrequency === void 0) { minFrequency = 0; }\r\n        if (orderBy === void 0) { orderBy = 'frequency'; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.SpectralPeaks(spectrum, magnitudeThreshold, maxFrequency, maxPeaks, minFrequency, orderBy, sampleRate);\r\n    };\r\n    /**\r\n    * Performs spectral whitening of spectral peaks of a spectrum. The algorithm works in dB scale, but the conversion is done by the algorithm so input should be in linear scale. The concept of 'whitening' refers to 'white noise' or a non-zero flat spectrum. It first computes a spectral envelope similar to the 'true envelope' in [1], and then modifies the amplitude of each peak relative to the envelope. For example, the predominant peaks will have a value close to 0dB because they are very close to the envelope. On the other hand, minor peaks between significant peaks will have lower amplitudes such as -30dB. Check https://essentia.upf.edu/reference/std_SpectralWhitening.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the audio linear spectrum\r\n    * @param {VectorFloat} frequencies the spectral peaks' linear frequencies\r\n    * @param {VectorFloat} magnitudes the spectral peaks' linear magnitudes\r\n    * @param {number} [maxFrequency=5000] max frequency to apply whitening to [Hz]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {magnitudes: 'the whitened spectral peaks' linear magnitudes'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SpectralWhitening = function (spectrum, frequencies, magnitudes, maxFrequency, sampleRate) {\r\n        if (maxFrequency === void 0) { maxFrequency = 5000; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.SpectralWhitening(spectrum, frequencies, magnitudes, maxFrequency, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the magnitude spectrum of an array of Reals. The resulting magnitude spectrum has a size which is half the size of the input array plus one. Bins contain raw (linear) magnitude values. Check https://essentia.upf.edu/reference/std_Spectrum.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input audio frame\r\n    * @param {number} [size=2048] the expected size of the input audio signal (this is an optional parameter to optimize memory allocation)\r\n    * @returns {object} {spectrum: 'magnitude spectrum of the input audio signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Spectrum = function (frame, size) {\r\n        if (size === void 0) { size = 2048; }\r\n        return this.algorithms.Spectrum(frame, size);\r\n    };\r\n    /**\r\n    * This algorithm computes the magnitude of the Constant-Q spectrum. See ConstantQ algorithm for more details.\r\n     Check https://essentia.upf.edu/reference/std_SpectrumCQ.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input audio frame\r\n    * @param {number} [binsPerOctave=12] number of bins per octave\r\n    * @param {number} [minFrequency=32.7] minimum frequency [Hz]\r\n    * @param {number} [minimumKernelSize=4] minimum size allowed for frequency kernels\r\n    * @param {number} [numberBins=84] number of frequency bins, starting at minFrequency\r\n    * @param {number} [sampleRate=44100] FFT sampling rate [Hz]\r\n    * @param {number} [scale=1] filters scale. Larger values use longer windows\r\n    * @param {number} [threshold=0.01] bins whose magnitude is below this quantile are discarded\r\n    * @param {string} [windowType=hann] the window type, which can be 'hamming', 'hann', 'triangular', 'square' or 'blackmanharrisXX'\r\n    * @param {boolean} [zeroPhase=true] a boolean value that enables zero-phase windowing. Input audio frames should be windowed with the same phase mode\r\n    * @returns {object} {spectrumCQ: 'the magnitude constant-Q spectrum'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SpectrumCQ = function (frame, binsPerOctave, minFrequency, minimumKernelSize, numberBins, sampleRate, scale, threshold, windowType, zeroPhase) {\r\n        if (binsPerOctave === void 0) { binsPerOctave = 12; }\r\n        if (minFrequency === void 0) { minFrequency = 32.7; }\r\n        if (minimumKernelSize === void 0) { minimumKernelSize = 4; }\r\n        if (numberBins === void 0) { numberBins = 84; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (scale === void 0) { scale = 1; }\r\n        if (threshold === void 0) { threshold = 0.01; }\r\n        if (windowType === void 0) { windowType = 'hann'; }\r\n        if (zeroPhase === void 0) { zeroPhase = true; }\r\n        return this.algorithms.SpectrumCQ(frame, binsPerOctave, minFrequency, minimumKernelSize, numberBins, sampleRate, scale, threshold, windowType, zeroPhase);\r\n    };\r\n    /**\r\n    * This algorithm computes energy in triangular frequency bands of a spectrum equally spaced on the cent scale. Each band is computed to have a constant wideness in the cent scale. For each band the power-spectrum (mag-squared) is summed. Check https://essentia.upf.edu/reference/std_SpectrumToCent.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input spectrum (must be greater than size one)\r\n    * @param {number} [bands=720] number of bins to compute. Default is 720 (6 octaves with the default 'centBinResolution')\r\n    * @param {number} [centBinResolution=10] Width of each band in cents. Default is 10 cents\r\n    * @param {number} [inputSize=32768] the size of the spectrum\r\n    * @param {boolean} [log=true] compute log-energies (log10 (1 + energy))\r\n    * @param {number} [minimumFrequency=164] central frequency of the first band of the bank [Hz]\r\n    * @param {string} [normalize=unit_sum] use unit area or vertex equal to 1 triangles.\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {string} [type=power] use magnitude or power spectrum\r\n    * @returns {object} {bands: 'the energy in each band', frequencies: 'the central frequency of each band'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SpectrumToCent = function (spectrum, bands, centBinResolution, inputSize, log, minimumFrequency, normalize, sampleRate, type) {\r\n        if (bands === void 0) { bands = 720; }\r\n        if (centBinResolution === void 0) { centBinResolution = 10; }\r\n        if (inputSize === void 0) { inputSize = 32768; }\r\n        if (log === void 0) { log = true; }\r\n        if (minimumFrequency === void 0) { minimumFrequency = 164; }\r\n        if (normalize === void 0) { normalize = 'unit_sum'; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (type === void 0) { type = 'power'; }\r\n        return this.algorithms.SpectrumToCent(spectrum, bands, centBinResolution, inputSize, log, minimumFrequency, normalize, sampleRate, type);\r\n    };\r\n    /**\r\n    * Evaluates a piecewise spline of type b, beta or quadratic.\r\n    The input value, i.e. the point at which the spline is to be evaluated typically should be between xPoins[0] and xPoinst[size-1]. If the value lies outside this range, extrapolation is used.\r\n    Regarding spline types:\r\n      - B: evaluates a cubic B spline approximant.\r\n      - Beta: evaluates a cubic beta spline approximant. For beta splines parameters 'beta1' and 'beta2' can be supplied. For no bias set beta1 to 1 and for no tension set beta2 to 0. Note that if beta1=1 and beta2=0, the cubic beta becomes a cubic B spline. On the other hand if beta1=1 and beta2 is large the beta spline turns into a linear spline.\r\n      - Quadratic: evaluates a piecewise quadratic spline at a point. Note that size of input must be odd. Check https://essentia.upf.edu/reference/std_Spline.html for more details.\r\n    * @method\r\n    * @param {number} x the input coordinate (x-axis)\r\n    * @param {number} [beta1=1] the skew or bias parameter (only available for type beta)\r\n    * @param {number} [beta2=0] the tension parameter\r\n    * @param {string} [type=b] the type of spline to be computed\r\n    * @param {any[]} [xPoints=[0, 1]] the x-coordinates where data is specified (the points must be arranged in ascending order and cannot contain duplicates)\r\n    * @param {any[]} [yPoints=[0, 1]] the y-coordinates to be interpolated (i.e. the known data)\r\n    * @returns {object} {y: 'the value of the spline at x'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Spline = function (x, beta1, beta2, type, xPoints, yPoints) {\r\n        if (beta1 === void 0) { beta1 = 1; }\r\n        if (beta2 === void 0) { beta2 = 0; }\r\n        if (type === void 0) { type = 'b'; }\r\n        if (xPoints === void 0) { xPoints = [0, 1]; }\r\n        if (yPoints === void 0) { yPoints = [0, 1]; }\r\n        var vecxPoints = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecxPoints.size(); i++) {\r\n            vecxPoints.push_back(xPoints[i]);\r\n        }\r\n        var vecyPoints = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecyPoints.size(); i++) {\r\n            vecyPoints.push_back(yPoints[i]);\r\n        }\r\n        return this.algorithms.Spline(x, beta1, beta2, type, vecxPoints, vecyPoints);\r\n    };\r\n    /**\r\n    * This algorithm computes the sinusoidal plus residual model analysis.  Check https://essentia.upf.edu/reference/std_SprModelAnal.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input frame\r\n    * @param {number} [fftSize=2048] the size of the internal FFT size (full spectrum size)\r\n    * @param {number} [freqDevOffset=20] minimum frequency deviation at 0Hz\r\n    * @param {number} [freqDevSlope=0.01] slope increase of minimum frequency deviation\r\n    * @param {number} [hopSize=512] the hop size between frames\r\n    * @param {number} [magnitudeThreshold=0] peaks below this given threshold are not outputted\r\n    * @param {number} [maxFrequency=5000] the maximum frequency of the range to evaluate [Hz]\r\n    * @param {number} [maxPeaks=100] the maximum number of returned peaks\r\n    * @param {number} [maxnSines=100] maximum number of sines per frame\r\n    * @param {number} [minFrequency=0] the minimum frequency of the range to evaluate [Hz]\r\n    * @param {string} [orderBy=frequency] the ordering type of the outputted peaks (ascending by frequency or descending by magnitude)\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {frequencies: 'the frequencies of the sinusoidal peaks [Hz]', magnitudes: 'the magnitudes of the sinusoidal peaks', phases: 'the phases of the sinusoidal peaks', res: 'output residual frame'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SprModelAnal = function (frame, fftSize, freqDevOffset, freqDevSlope, hopSize, magnitudeThreshold, maxFrequency, maxPeaks, maxnSines, minFrequency, orderBy, sampleRate) {\r\n        if (fftSize === void 0) { fftSize = 2048; }\r\n        if (freqDevOffset === void 0) { freqDevOffset = 20; }\r\n        if (freqDevSlope === void 0) { freqDevSlope = 0.01; }\r\n        if (hopSize === void 0) { hopSize = 512; }\r\n        if (magnitudeThreshold === void 0) { magnitudeThreshold = 0; }\r\n        if (maxFrequency === void 0) { maxFrequency = 5000; }\r\n        if (maxPeaks === void 0) { maxPeaks = 100; }\r\n        if (maxnSines === void 0) { maxnSines = 100; }\r\n        if (minFrequency === void 0) { minFrequency = 0; }\r\n        if (orderBy === void 0) { orderBy = 'frequency'; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.SprModelAnal(frame, fftSize, freqDevOffset, freqDevSlope, hopSize, magnitudeThreshold, maxFrequency, maxPeaks, maxnSines, minFrequency, orderBy, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the sinusoidal plus residual model synthesis from SPS model analysis. Check https://essentia.upf.edu/reference/std_SprModelSynth.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} magnitudes the magnitudes of the sinusoidal peaks\r\n    * @param {VectorFloat} frequencies the frequencies of the sinusoidal peaks [Hz]\r\n    * @param {VectorFloat} phases the phases of the sinusoidal peaks\r\n    * @param {VectorFloat} res the residual frame\r\n    * @param {number} [fftSize=2048] the size of the output FFT frame (full spectrum size)\r\n    * @param {number} [hopSize=512] the hop size between frames\r\n    * @param {number} [sampleRate=44100] the audio sampling rate [Hz]\r\n    * @returns {object} {frame: 'the output audio frame of the Sinusoidal Plus Stochastic model', sineframe: 'the output audio frame for sinusoidal component ', resframe: 'the output audio frame for stochastic component '}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SprModelSynth = function (magnitudes, frequencies, phases, res, fftSize, hopSize, sampleRate) {\r\n        if (fftSize === void 0) { fftSize = 2048; }\r\n        if (hopSize === void 0) { hopSize = 512; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.SprModelSynth(magnitudes, frequencies, phases, res, fftSize, hopSize, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the stochastic model analysis.  Check https://essentia.upf.edu/reference/std_SpsModelAnal.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input frame\r\n    * @param {number} [fftSize=2048] the size of the internal FFT size (full spectrum size)\r\n    * @param {number} [freqDevOffset=20] minimum frequency deviation at 0Hz\r\n    * @param {number} [freqDevSlope=0.01] slope increase of minimum frequency deviation\r\n    * @param {number} [hopSize=512] the hop size between frames\r\n    * @param {number} [magnitudeThreshold=0] peaks below this given threshold are not outputted\r\n    * @param {number} [maxFrequency=5000] the maximum frequency of the range to evaluate [Hz]\r\n    * @param {number} [maxPeaks=100] the maximum number of returned peaks\r\n    * @param {number} [maxnSines=100] maximum number of sines per frame\r\n    * @param {number} [minFrequency=0] the minimum frequency of the range to evaluate [Hz]\r\n    * @param {string} [orderBy=frequency] the ordering type of the outputted peaks (ascending by frequency or descending by magnitude)\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [stocf=0.2] decimation factor used for the stochastic approximation\r\n    * @returns {object} {frequencies: 'the frequencies of the sinusoidal peaks [Hz]', magnitudes: 'the magnitudes of the sinusoidal peaks', phases: 'the phases of the sinusoidal peaks', stocenv: 'the stochastic envelope'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SpsModelAnal = function (frame, fftSize, freqDevOffset, freqDevSlope, hopSize, magnitudeThreshold, maxFrequency, maxPeaks, maxnSines, minFrequency, orderBy, sampleRate, stocf) {\r\n        if (fftSize === void 0) { fftSize = 2048; }\r\n        if (freqDevOffset === void 0) { freqDevOffset = 20; }\r\n        if (freqDevSlope === void 0) { freqDevSlope = 0.01; }\r\n        if (hopSize === void 0) { hopSize = 512; }\r\n        if (magnitudeThreshold === void 0) { magnitudeThreshold = 0; }\r\n        if (maxFrequency === void 0) { maxFrequency = 5000; }\r\n        if (maxPeaks === void 0) { maxPeaks = 100; }\r\n        if (maxnSines === void 0) { maxnSines = 100; }\r\n        if (minFrequency === void 0) { minFrequency = 0; }\r\n        if (orderBy === void 0) { orderBy = 'frequency'; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (stocf === void 0) { stocf = 0.2; }\r\n        return this.algorithms.SpsModelAnal(frame, fftSize, freqDevOffset, freqDevSlope, hopSize, magnitudeThreshold, maxFrequency, maxPeaks, maxnSines, minFrequency, orderBy, sampleRate, stocf);\r\n    };\r\n    /**\r\n    * This algorithm computes the sinusoidal plus stochastic model synthesis from SPS model analysis. Check https://essentia.upf.edu/reference/std_SpsModelSynth.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} magnitudes the magnitudes of the sinusoidal peaks\r\n    * @param {VectorFloat} frequencies the frequencies of the sinusoidal peaks [Hz]\r\n    * @param {VectorFloat} phases the phases of the sinusoidal peaks\r\n    * @param {VectorFloat} stocenv the stochastic envelope\r\n    * @param {number} [fftSize=2048] the size of the output FFT frame (full spectrum size)\r\n    * @param {number} [hopSize=512] the hop size between frames\r\n    * @param {number} [sampleRate=44100] the audio sampling rate [Hz]\r\n    * @param {number} [stocf=0.2] decimation factor used for the stochastic approximation\r\n    * @returns {object} {frame: 'the output audio frame of the Sinusoidal Plus Stochastic model', sineframe: 'the output audio frame for sinusoidal component ', stocframe: 'the output audio frame for stochastic component '}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SpsModelSynth = function (magnitudes, frequencies, phases, stocenv, fftSize, hopSize, sampleRate, stocf) {\r\n        if (fftSize === void 0) { fftSize = 2048; }\r\n        if (hopSize === void 0) { hopSize = 512; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (stocf === void 0) { stocf = 0.2; }\r\n        return this.algorithms.SpsModelSynth(magnitudes, frequencies, phases, stocenv, fftSize, hopSize, sampleRate, stocf);\r\n    };\r\n    /**\r\n    * This algorithm outputs if there is a cut at the beginning or at the end of the audio by locating the first and last non-silent frames and comparing their positions to the actual beginning and end of the audio. The input audio is considered to be cut at the beginning (or the end) and the corresponding flag is activated if the first (last) non-silent frame occurs before (after) the configurable time threshold. Check https://essentia.upf.edu/reference/std_StartStopCut.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} audio the input audio\r\n    * @param {number} [frameSize=256] the frame size for the internal power analysis\r\n    * @param {number} [hopSize=256] the hop size for the internal power analysis\r\n    * @param {number} [maximumStartTime=10] if the first non-silent frame occurs before maximumStartTime startCut is activated [ms]\r\n    * @param {number} [maximumStopTime=10] if the last non-silent frame occurs after maximumStopTime to the end stopCut is activated [ms]\r\n    * @param {number} [sampleRate=44100] the sample rate\r\n    * @param {number} [threshold=-60] the threshold below which average energy is defined as silence [dB]\r\n    * @returns {object} {startCut: '1 if there is a cut at the begining of the audio', stopCut: '1 if there is a cut at the end of the audio'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.StartStopCut = function (audio, frameSize, hopSize, maximumStartTime, maximumStopTime, sampleRate, threshold) {\r\n        if (frameSize === void 0) { frameSize = 256; }\r\n        if (hopSize === void 0) { hopSize = 256; }\r\n        if (maximumStartTime === void 0) { maximumStartTime = 10; }\r\n        if (maximumStopTime === void 0) { maximumStopTime = 10; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (threshold === void 0) { threshold = -60; }\r\n        return this.algorithms.StartStopCut(audio, frameSize, hopSize, maximumStartTime, maximumStopTime, sampleRate, threshold);\r\n    };\r\n    /**\r\n    * This algorithm outputs the frame at which sound begins and the frame at which sound ends. Check https://essentia.upf.edu/reference/std_StartStopSilence.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input audio frames\r\n    * @param {number} [threshold=-60] the threshold below which average energy is defined as silence [dB]\r\n    * @returns {object} {startFrame: 'number of the first non-silent frame', stopFrame: 'number of the last non-silent frame'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.StartStopSilence = function (frame, threshold) {\r\n        if (threshold === void 0) { threshold = -60; }\r\n        return this.algorithms.StartStopSilence(frame, threshold);\r\n    };\r\n    /**\r\n    * This algorithm computes the stochastic model analysis. It gets the resampled spectral envelope of the stochastic component. Check https://essentia.upf.edu/reference/std_StochasticModelAnal.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input frame\r\n    * @param {number} [fftSize=2048] the size of the internal FFT size (full spectrum size)\r\n    * @param {number} [hopSize=512] the hop size between frames\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [stocf=0.2] decimation factor used for the stochastic approximation\r\n    * @returns {object} {stocenv: 'the stochastic envelope'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.StochasticModelAnal = function (frame, fftSize, hopSize, sampleRate, stocf) {\r\n        if (fftSize === void 0) { fftSize = 2048; }\r\n        if (hopSize === void 0) { hopSize = 512; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (stocf === void 0) { stocf = 0.2; }\r\n        return this.algorithms.StochasticModelAnal(frame, fftSize, hopSize, sampleRate, stocf);\r\n    };\r\n    /**\r\n    * This algorithm computes the stochastic model synthesis. It generates the noisy spectrum from a resampled spectral envelope of the stochastic component. Check https://essentia.upf.edu/reference/std_StochasticModelSynth.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} stocenv the stochastic envelope input\r\n    * @param {number} [fftSize=2048] the size of the internal FFT size (full spectrum size)\r\n    * @param {number} [hopSize=512] the hop size between frames\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [stocf=0.2] decimation factor used for the stochastic approximation\r\n    * @returns {object} {frame: 'the output frame'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.StochasticModelSynth = function (stocenv, fftSize, hopSize, sampleRate, stocf) {\r\n        if (fftSize === void 0) { fftSize = 2048; }\r\n        if (hopSize === void 0) { hopSize = 512; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (stocf === void 0) { stocf = 0.2; }\r\n        return this.algorithms.StochasticModelSynth(stocenv, fftSize, hopSize, sampleRate, stocf);\r\n    };\r\n    /**\r\n    * This algorithm computes the Strong Decay of an audio signal. The Strong Decay is built from the non-linear combination of the signal energy and the signal temporal centroid, the latter being the balance of the absolute value of the signal. A signal containing a temporal centroid near its start boundary and a strong energy is said to have a strong decay. Check https://essentia.upf.edu/reference/std_StrongDecay.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio signal\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {strongDecay: 'the strong decay'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.StrongDecay = function (signal, sampleRate) {\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.StrongDecay(signal, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the Strong Peak of a spectrum. The Strong Peak is defined as the ratio between the spectrum's maximum peak's magnitude and the \"bandwidth\" of the peak above a threshold (half its amplitude). This ratio reveals whether the spectrum presents a very \"pronounced\" maximum peak (i.e. the thinner and the higher the maximum of the spectrum is, the higher the ratio value). Check https://essentia.upf.edu/reference/std_StrongPeak.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input spectrum (must be greater than one element and cannot contain negative values)\r\n    * @returns {object} {strongPeak: 'the Strong Peak ratio'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.StrongPeak = function (spectrum) {\r\n        return this.algorithms.StrongPeak(spectrum);\r\n    };\r\n    /**\r\n    * This algorithm detects onsets given an audio signal using SuperFlux algorithm. This implementation is based on the available reference implementation in python [2]. The algorithm computes spectrum of the input signal, summarizes it into triangular band energies, and computes a onset detection function based on spectral flux tracking spectral trajectories with a maximum filter (SuperFluxNovelty). The peaks of the function are then detected (SuperFluxPeaks). Check https://essentia.upf.edu/reference/std_SuperFluxExtractor.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the audio input signal\r\n    * @param {number} [combine=20] time threshold for double onsets detections (ms)\r\n    * @param {number} [frameSize=2048] the frame size for computing low-level features\r\n    * @param {number} [hopSize=256] the hop size for computing low-level features\r\n    * @param {number} [ratioThreshold=16] ratio threshold for peak picking with respect to novelty_signal/novelty_average rate, use 0 to disable it (for low-energy onsets)\r\n    * @param {number} [sampleRate=44100] the audio sampling rate [Hz]\r\n    * @param {number} [threshold=0.05] threshold for peak peaking with respect to the difference between novelty_signal and average_signal (for onsets in ambient noise)\r\n    * @returns {object} {onsets: 'the onsets times'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SuperFluxExtractor = function (signal, combine, frameSize, hopSize, ratioThreshold, sampleRate, threshold) {\r\n        if (combine === void 0) { combine = 20; }\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (hopSize === void 0) { hopSize = 256; }\r\n        if (ratioThreshold === void 0) { ratioThreshold = 16; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (threshold === void 0) { threshold = 0.05; }\r\n        return this.algorithms.SuperFluxExtractor(signal, combine, frameSize, hopSize, ratioThreshold, sampleRate, threshold);\r\n    };\r\n    /**\r\n    * Onset detection function for Superflux algorithm. See SuperFluxExtractor for more details. Check https://essentia.upf.edu/reference/std_SuperFluxNovelty.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} bands the input bands spectrogram\r\n    * @param {number} [binWidth=3] filter width (number of frequency bins)\r\n    * @param {number} [frameWidth=2] differentiation offset (compute the difference with the N-th previous frame)\r\n    * @returns {object} {differences: 'SuperFlux novelty curve'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SuperFluxNovelty = function (bands, binWidth, frameWidth) {\r\n        if (binWidth === void 0) { binWidth = 3; }\r\n        if (frameWidth === void 0) { frameWidth = 2; }\r\n        return this.algorithms.SuperFluxNovelty(bands, binWidth, frameWidth);\r\n    };\r\n    /**\r\n    * This algorithm detects peaks of an onset detection function computed by the SuperFluxNovelty algorithm. See SuperFluxExtractor for more details. Check https://essentia.upf.edu/reference/std_SuperFluxPeaks.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} novelty the input onset detection function\r\n    * @param {number} [combine=30] time threshold for double onsets detections (ms)\r\n    * @param {number} [frameRate=172] frameRate\r\n    * @param {number} [pre_avg=100] look back duration for moving average filter [ms]\r\n    * @param {number} [pre_max=30] look back duration for moving maximum filter [ms]\r\n    * @param {number} [ratioThreshold=16] ratio threshold for peak picking with respect to novelty_signal/novelty_average rate, use 0 to disable it (for low-energy onsets)\r\n    * @param {number} [threshold=0.05] threshold for peak peaking with respect to the difference between novelty_signal and average_signal (for onsets in ambient noise)\r\n    * @returns {object} {peaks: 'detected peaks' instants [s]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.SuperFluxPeaks = function (novelty, combine, frameRate, pre_avg, pre_max, ratioThreshold, threshold) {\r\n        if (combine === void 0) { combine = 30; }\r\n        if (frameRate === void 0) { frameRate = 172; }\r\n        if (pre_avg === void 0) { pre_avg = 100; }\r\n        if (pre_max === void 0) { pre_max = 30; }\r\n        if (ratioThreshold === void 0) { ratioThreshold = 16; }\r\n        if (threshold === void 0) { threshold = 0.05; }\r\n        return this.algorithms.SuperFluxPeaks(novelty, combine, frameRate, pre_avg, pre_max, ratioThreshold, threshold);\r\n    };\r\n    /**\r\n    * This algorithm calculates the ratio of the temporal centroid to the total length of a signal envelope. This ratio shows how the sound is 'balanced'. Its value is close to 0 if most of the energy lies at the beginning of the sound (e.g. decrescendo or impulsive sounds), close to 0.5 if the sound is symetric (e.g. 'delta unvarying' sounds), and close to 1 if most of the energy lies at the end of the sound (e.g. crescendo sounds). Check https://essentia.upf.edu/reference/std_TCToTotal.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} envelope the envelope of the signal (its length must be greater than 1\r\n    * @returns {object} {TCToTotal: 'the temporal centroid to total length ratio'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TCToTotal = function (envelope) {\r\n        return this.algorithms.TCToTotal(envelope);\r\n    };\r\n    /**\r\n    * This algorithm computes features for tempo tracking to be used with the TempoTap algorithm. See standard_rhythmextractor_tempotap in examples folder. Check https://essentia.upf.edu/reference/std_TempoScaleBands.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} bands the audio power spectrum divided into bands\r\n    * @param {any[]} [bandsGain=[2, 3, 2, 1, 1.20000004768, 2, 3, 2.5]] gain for each bands\r\n    * @param {number} [frameTime=512] the frame rate in samples\r\n    * @returns {object} {scaledBands: 'the output bands after scaling', cumulativeBands: 'cumulative sum of the output bands before scaling'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TempoScaleBands = function (bands, bandsGain, frameTime) {\r\n        if (bandsGain === void 0) { bandsGain = [2, 3, 2, 1, 1.20000004768, 2, 3, 2.5]; }\r\n        if (frameTime === void 0) { frameTime = 512; }\r\n        var vecbandsGain = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecbandsGain.size(); i++) {\r\n            vecbandsGain.push_back(bandsGain[i]);\r\n        }\r\n        return this.algorithms.TempoScaleBands(bands, vecbandsGain, frameTime);\r\n    };\r\n    /**\r\n    * This algorithm estimates the periods and phases of a periodic signal, represented by a sequence of values of any number of detection functions, such as energy bands, onsets locations, etc. It requires to be sequentially run on a vector of such values (\"featuresFrame\") for each particular audio frame in order to get estimations related to that frames. The estimations are done for each detection function separately, utilizing the latest \"frameHop\" frames, including the present one, to compute autocorrelation. Empty estimations will be returned until enough frames are accumulated in the algorithm's buffer.\r\n    The algorithm uses elements of the following beat-tracking methods:\r\n     - BeatIt, elaborated by Fabien Gouyon and Simon Dixon (input features) [1]\r\n     - Multi-comb filter with Rayleigh weighting, Mathew Davies [2] Check https://essentia.upf.edu/reference/std_TempoTap.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} featuresFrame input temporal features of a frame\r\n    * @param {number} [frameHop=1024] number of feature frames separating two evaluations\r\n    * @param {number} [frameSize=256] number of audio samples in a frame\r\n    * @param {number} [maxTempo=208] fastest tempo allowed to be detected [bpm]\r\n    * @param {number} [minTempo=40] slowest tempo allowed to be detected [bpm]\r\n    * @param {number} [numberFrames=1024] number of feature frames to buffer on\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {any[]} [tempoHints=[]] optional list of initial beat locations, to favor the detection of pre-determined tempo period and beats alignment [s]\r\n    * @returns {object} {periods: 'list of tempo estimates found for each input feature, in frames', phases: 'list of initial phase candidates found for each input feature, in frames'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TempoTap = function (featuresFrame, frameHop, frameSize, maxTempo, minTempo, numberFrames, sampleRate, tempoHints) {\r\n        if (frameHop === void 0) { frameHop = 1024; }\r\n        if (frameSize === void 0) { frameSize = 256; }\r\n        if (maxTempo === void 0) { maxTempo = 208; }\r\n        if (minTempo === void 0) { minTempo = 40; }\r\n        if (numberFrames === void 0) { numberFrames = 1024; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (tempoHints === void 0) { tempoHints = []; }\r\n        var vectempoHints = new this.module.VectorFloat();\r\n        for (var i = 0; i < vectempoHints.size(); i++) {\r\n            vectempoHints.push_back(tempoHints[i]);\r\n        }\r\n        return this.algorithms.TempoTap(featuresFrame, frameHop, frameSize, maxTempo, minTempo, numberFrames, sampleRate, vectempoHints);\r\n    };\r\n    /**\r\n    * This algorithm estimates beat positions given an onset detection function.  The detection function is partitioned into 6-second frames with a 1.5-second increment, and the autocorrelation is computed for each frame, and is weighted by a tempo preference curve [2]. Periodicity estimations are done frame-wisely, searching for the best match with the Viterbi algorith [3]. The estimated periods are then passed to the probabilistic beat tracking algorithm [1], which computes beat positions. Check https://essentia.upf.edu/reference/std_TempoTapDegara.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} onsetDetections the input frame-wise vector of onset detection values\r\n    * @param {number} [maxTempo=208] fastest tempo allowed to be detected [bpm]\r\n    * @param {number} [minTempo=40] slowest tempo allowed to be detected [bpm]\r\n    * @param {string} [resample=none] use upsampling of the onset detection function (may increase accuracy)\r\n    * @param {number} [sampleRateODF=86.1328] the sampling rate of the onset detection function [Hz]\r\n    * @returns {object} {ticks: 'the list of resulting ticks [s]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TempoTapDegara = function (onsetDetections, maxTempo, minTempo, resample, sampleRateODF) {\r\n        if (maxTempo === void 0) { maxTempo = 208; }\r\n        if (minTempo === void 0) { minTempo = 40; }\r\n        if (resample === void 0) { resample = 'none'; }\r\n        if (sampleRateODF === void 0) { sampleRateODF = 86.1328; }\r\n        return this.algorithms.TempoTapDegara(onsetDetections, maxTempo, minTempo, resample, sampleRateODF);\r\n    };\r\n    /**\r\n    * This algorithm outputs beat positions and confidence of their estimation based on the maximum mutual agreement between beat candidates estimated by different beat trackers (or using different features). Check https://essentia.upf.edu/reference/std_TempoTapMaxAgreement.html for more details.\r\n    * @method\r\n    * @param {VectorVectorFloat} tickCandidates the tick candidates estimated using different beat trackers (or features) [s]\r\n    * @returns {object} {ticks: 'the list of resulting ticks [s]', confidence: 'confidence with which the ticks were detected [0, 5.32]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TempoTapMaxAgreement = function (tickCandidates) {\r\n        return this.algorithms.TempoTapMaxAgreement(tickCandidates);\r\n    };\r\n    /**\r\n    * This algorithm builds the list of ticks from the period and phase candidates given by the TempoTap algorithm. Check https://essentia.upf.edu/reference/std_TempoTapTicks.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} periods tempo period candidates for the current frame, in frames\r\n    * @param {VectorFloat} phases tempo ticks phase candidates for the current frame, in frames\r\n    * @param {number} [frameHop=512] number of feature frames separating two evaluations\r\n    * @param {number} [hopSize=256] number of audio samples per features\r\n    * @param {number} [sampleRate=44100] sampling rate of the audio signal [Hz]\r\n    * @returns {object} {ticks: 'the list of resulting ticks [s]', matchingPeriods: 'list of matching periods [s]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TempoTapTicks = function (periods, phases, frameHop, hopSize, sampleRate) {\r\n        if (frameHop === void 0) { frameHop = 512; }\r\n        if (hopSize === void 0) { hopSize = 256; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.TempoTapTicks(periods, phases, frameHop, hopSize, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes mel-bands with a particular parametrization specific to MusiCNN based models. Check https://essentia.upf.edu/reference/std_TensorflowInputMusiCNN.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the audio frame\r\n    * @returns {object} {bands: 'the log compressed mel bands'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TensorflowInputMusiCNN = function (frame) {\r\n        return this.algorithms.TensorflowInputMusiCNN(frame);\r\n    };\r\n    /**\r\n    * This algorithm computes mel-bands with a particular parametrization specific to VGGish based models. Check https://essentia.upf.edu/reference/std_TensorflowInputVGGish.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the audio frame\r\n    * @returns {object} {bands: 'the log compressed mel bands'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TensorflowInputVGGish = function (frame) {\r\n        return this.algorithms.TensorflowInputVGGish(frame);\r\n    };\r\n    /**\r\n    * This algorithm computes tonal features for an audio signal Check https://essentia.upf.edu/reference/std_TonalExtractor.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the audio input signal\r\n    * @param {number} [frameSize=4096] the framesize for computing tonal features\r\n    * @param {number} [hopSize=2048] the hopsize for computing tonal features\r\n    * @param {number} [tuningFrequency=440] the tuning frequency of the input signal\r\n    * @returns {object} {chords_changes_rate: 'See ChordsDescriptors algorithm documentation', chords_histogram: 'See ChordsDescriptors algorithm documentation', chords_key: 'See ChordsDescriptors algorithm documentation', chords_number_rate: 'See ChordsDescriptors algorithm documentation', chords_progression: 'See ChordsDetection algorithm documentation', chords_scale: 'See ChordsDetection algorithm documentation', chords_strength: 'See ChordsDetection algorithm documentation', hpcp: 'See HPCP algorithm documentation', hpcp_highres: 'See HPCP algorithm documentation', key_key: 'See Key algorithm documentation', key_scale: 'See Key algorithm documentation', key_strength: 'See Key algorithm documentation'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TonalExtractor = function (signal, frameSize, hopSize, tuningFrequency) {\r\n        if (frameSize === void 0) { frameSize = 4096; }\r\n        if (hopSize === void 0) { hopSize = 2048; }\r\n        if (tuningFrequency === void 0) { tuningFrequency = 440; }\r\n        return this.algorithms.TonalExtractor(signal, frameSize, hopSize, tuningFrequency);\r\n    };\r\n    /**\r\n    * This algorithm estimates the tonic frequency of the lead artist in Indian art music. It uses multipitch representation of the audio signal (pitch salience) to compute a histogram using which the tonic is identified as one of its peak. The decision is made based on the distance between the prominent peaks, the classification is done using a decision tree. Check https://essentia.upf.edu/reference/std_TonicIndianArtMusic.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [binResolution=10] salience function bin resolution [cents]\r\n    * @param {number} [frameSize=2048] the frame size for computing pitch saliecnce\r\n    * @param {number} [harmonicWeight=0.85] harmonic weighting parameter (weight decay ratio between two consequent harmonics, =1 for no decay)\r\n    * @param {number} [hopSize=512] the hop size with which the pitch salience function was computed\r\n    * @param {number} [magnitudeCompression=1] magnitude compression parameter (=0 for maximum compression, =1 for no compression)\r\n    * @param {number} [magnitudeThreshold=40] peak magnitude threshold (maximum allowed difference from the highest peak in dBs)\r\n    * @param {number} [maxTonicFrequency=375] the maximum allowed tonic frequency [Hz]\r\n    * @param {number} [minTonicFrequency=100] the minimum allowed tonic frequency [Hz]\r\n    * @param {number} [numberHarmonics=20] number of considered hamonics\r\n    * @param {number} [numberSaliencePeaks=5]  number of top peaks of the salience function which should be considered for constructing histogram\r\n    * @param {number} [referenceFrequency=55] the reference frequency for Hertz to cent convertion [Hz], corresponding to the 0th cent bin\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @returns {object} {tonic: 'the estimated tonic frequency [Hz]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TonicIndianArtMusic = function (signal, binResolution, frameSize, harmonicWeight, hopSize, magnitudeCompression, magnitudeThreshold, maxTonicFrequency, minTonicFrequency, numberHarmonics, numberSaliencePeaks, referenceFrequency, sampleRate) {\r\n        if (binResolution === void 0) { binResolution = 10; }\r\n        if (frameSize === void 0) { frameSize = 2048; }\r\n        if (harmonicWeight === void 0) { harmonicWeight = 0.85; }\r\n        if (hopSize === void 0) { hopSize = 512; }\r\n        if (magnitudeCompression === void 0) { magnitudeCompression = 1; }\r\n        if (magnitudeThreshold === void 0) { magnitudeThreshold = 40; }\r\n        if (maxTonicFrequency === void 0) { maxTonicFrequency = 375; }\r\n        if (minTonicFrequency === void 0) { minTonicFrequency = 100; }\r\n        if (numberHarmonics === void 0) { numberHarmonics = 20; }\r\n        if (numberSaliencePeaks === void 0) { numberSaliencePeaks = 5; }\r\n        if (referenceFrequency === void 0) { referenceFrequency = 55; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.TonicIndianArtMusic(signal, binResolution, frameSize, harmonicWeight, hopSize, magnitudeCompression, magnitudeThreshold, maxTonicFrequency, minTonicFrequency, numberHarmonics, numberSaliencePeaks, referenceFrequency, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes energy in triangular frequency bands of a spectrum. The arbitrary number of overlapping bands can be specified. For each band the power-spectrum (mag-squared) is summed. Check https://essentia.upf.edu/reference/std_TriangularBands.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the input spectrum (must be greater than size one)\r\n    * @param {any[]} [frequencyBands=[21.533203125, 43.06640625, 64.599609375, 86.1328125, 107.666015625, 129.19921875, 150.732421875, 172.265625, 193.798828125, 215.33203125, 236.865234375, 258.3984375, 279.931640625, 301.46484375, 322.998046875, 344.53125, 366.064453125, 387.59765625, 409.130859375, 430.6640625, 452.197265625, 473.73046875, 495.263671875, 516.796875, 538.330078125, 559.86328125, 581.396484375, 602.9296875, 624.462890625, 645.99609375, 667.529296875, 689.0625, 710.595703125, 732.12890625, 753.662109375, 775.1953125, 796.728515625, 839.794921875, 861.328125, 882.861328125, 904.39453125, 925.927734375, 968.994140625, 990.52734375, 1012.06054688, 1055.12695312, 1076.66015625, 1098.19335938, 1141.25976562, 1184.32617188, 1205.859375, 1248.92578125, 1270.45898438, 1313.52539062, 1356.59179688, 1399.65820312, 1442.72460938, 1485.79101562, 1528.85742188, 1571.92382812, 1614.99023438, 1658.05664062, 1701.12304688, 1765.72265625, 1808.7890625, 1873.38867188, 1916.45507812, 1981.0546875, 2024.12109375, 2088.72070312, 2153.3203125, 2217.91992188, 2282.51953125, 2347.11914062, 2411.71875, 2497.8515625, 2562.45117188, 2627.05078125, 2713.18359375, 2799.31640625, 2885.44921875, 2950.04882812, 3036.18164062, 3143.84765625, 3229.98046875, 3316.11328125, 3423.77929688, 3509.91210938, 3617.578125, 3725.24414062, 3832.91015625, 3940.57617188, 4069.77539062, 4177.44140625, 4306.640625, 4435.83984375, 4565.0390625, 4694.23828125, 4844.97070312, 4974.16992188, 5124.90234375, 5275.63476562, 5426.3671875, 5577.09960938, 5749.36523438, 5921.63085938, 6093.89648438, 6266.16210938, 6459.9609375, 6653.75976562, 6847.55859375, 7041.35742188, 7256.68945312, 7450.48828125, 7687.35351562, 7902.68554688, 8139.55078125, 8376.41601562, 8613.28125, 8871.6796875, 9130.078125, 9388.4765625, 9668.40820312, 9948.33984375, 10249.8046875, 10551.2695312, 10852.734375, 11175.7324219, 11498.7304688, 11843.2617188, 12187.7929688, 12553.8574219, 12919.921875, 13285.9863281, 13673.5839844, 14082.7148438, 14491.8457031, 14922.5097656, 15353.1738281, 15805.3710938, 16257.5683594]] list of frequency ranges into which the spectrum is divided (these must be in ascending order and connot contain duplicates),each triangle is build as x(i-1)=0, x(i)=1, x(i+1)=0 over i, the resulting number of bands is size of input array - 2\r\n    * @param {number} [inputSize=1025] the size of the spectrum\r\n    * @param {boolean} [log=true] compute log-energies (log10 (1 + energy))\r\n    * @param {string} [normalize=unit_sum] spectrum bin weights to use for each triangular band: 'unit_max' to make each triangle vertex equal to 1, 'unit_sum' to make each triangle area equal to 1 summing the actual weights of spectrum bins, 'unit_area' to make each triangle area equal to 1 normalizing the weights of each triangle by its bandwidth\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {string} [type=power] use magnitude or power spectrum\r\n    * @param {string} [weighting=linear] type of weighting function for determining triangle area\r\n    * @returns {object} {bands: 'the energy in each band'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TriangularBands = function (spectrum, frequencyBands, inputSize, log, normalize, sampleRate, type, weighting) {\r\n        if (frequencyBands === void 0) { frequencyBands = [21.533203125, 43.06640625, 64.599609375, 86.1328125, 107.666015625, 129.19921875, 150.732421875, 172.265625, 193.798828125, 215.33203125, 236.865234375, 258.3984375, 279.931640625, 301.46484375, 322.998046875, 344.53125, 366.064453125, 387.59765625, 409.130859375, 430.6640625, 452.197265625, 473.73046875, 495.263671875, 516.796875, 538.330078125, 559.86328125, 581.396484375, 602.9296875, 624.462890625, 645.99609375, 667.529296875, 689.0625, 710.595703125, 732.12890625, 753.662109375, 775.1953125, 796.728515625, 839.794921875, 861.328125, 882.861328125, 904.39453125, 925.927734375, 968.994140625, 990.52734375, 1012.06054688, 1055.12695312, 1076.66015625, 1098.19335938, 1141.25976562, 1184.32617188, 1205.859375, 1248.92578125, 1270.45898438, 1313.52539062, 1356.59179688, 1399.65820312, 1442.72460938, 1485.79101562, 1528.85742188, 1571.92382812, 1614.99023438, 1658.05664062, 1701.12304688, 1765.72265625, 1808.7890625, 1873.38867188, 1916.45507812, 1981.0546875, 2024.12109375, 2088.72070312, 2153.3203125, 2217.91992188, 2282.51953125, 2347.11914062, 2411.71875, 2497.8515625, 2562.45117188, 2627.05078125, 2713.18359375, 2799.31640625, 2885.44921875, 2950.04882812, 3036.18164062, 3143.84765625, 3229.98046875, 3316.11328125, 3423.77929688, 3509.91210938, 3617.578125, 3725.24414062, 3832.91015625, 3940.57617188, 4069.77539062, 4177.44140625, 4306.640625, 4435.83984375, 4565.0390625, 4694.23828125, 4844.97070312, 4974.16992188, 5124.90234375, 5275.63476562, 5426.3671875, 5577.09960938, 5749.36523438, 5921.63085938, 6093.89648438, 6266.16210938, 6459.9609375, 6653.75976562, 6847.55859375, 7041.35742188, 7256.68945312, 7450.48828125, 7687.35351562, 7902.68554688, 8139.55078125, 8376.41601562, 8613.28125, 8871.6796875, 9130.078125, 9388.4765625, 9668.40820312, 9948.33984375, 10249.8046875, 10551.2695312, 10852.734375, 11175.7324219, 11498.7304688, 11843.2617188, 12187.7929688, 12553.8574219, 12919.921875, 13285.9863281, 13673.5839844, 14082.7148438, 14491.8457031, 14922.5097656, 15353.1738281, 15805.3710938, 16257.5683594]; }\r\n        if (inputSize === void 0) { inputSize = 1025; }\r\n        if (log === void 0) { log = true; }\r\n        if (normalize === void 0) { normalize = 'unit_sum'; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (type === void 0) { type = 'power'; }\r\n        if (weighting === void 0) { weighting = 'linear'; }\r\n        var vecfrequencyBands = new this.module.VectorFloat();\r\n        for (var i = 0; i < vecfrequencyBands.size(); i++) {\r\n            vecfrequencyBands.push_back(frequencyBands[i]);\r\n        }\r\n        return this.algorithms.TriangularBands(spectrum, vecfrequencyBands, inputSize, log, normalize, sampleRate, type, weighting);\r\n    };\r\n    /**\r\n    * This algorithm computes energy in the bark bands of a spectrum. It is different to the regular BarkBands algorithm in that is more configurable so that it can be used in the BFCC algorithm to produce output similar to Rastamat (http://www.ee.columbia.edu/ln/rosa/matlab/rastamat/)\r\n    See the BFCC algorithm documentation for more information as to why you might want to choose this over Mel frequency analysis\r\n    It is recommended that the input \"spectrum\" be calculated by the Spectrum algorithm. Check https://essentia.upf.edu/reference/std_TriangularBarkBands.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} spectrum the audio spectrum\r\n    * @param {number} [highFrequencyBound=22050] an upper-bound limit for the frequencies to be included in the bands\r\n    * @param {number} [inputSize=1025] the size of the spectrum\r\n    * @param {boolean} [log=false] compute log-energies (log10 (1 + energy))\r\n    * @param {number} [lowFrequencyBound=0] a lower-bound limit for the frequencies to be included in the bands\r\n    * @param {string} [normalize=unit_sum] 'unit_max' makes the vertex of all the triangles equal to 1, 'unit_sum' makes the area of all the triangles equal to 1\r\n    * @param {number} [numberBands=24] the number of output bands\r\n    * @param {number} [sampleRate=44100] the sample rate\r\n    * @param {string} [type=power] 'power' to output squared units, 'magnitude' to keep it as the input\r\n    * @param {string} [weighting=warping] type of weighting function for determining triangle area\r\n    * @returns {object} {bands: 'the energy in bark bands'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TriangularBarkBands = function (spectrum, highFrequencyBound, inputSize, log, lowFrequencyBound, normalize, numberBands, sampleRate, type, weighting) {\r\n        if (highFrequencyBound === void 0) { highFrequencyBound = 22050; }\r\n        if (inputSize === void 0) { inputSize = 1025; }\r\n        if (log === void 0) { log = false; }\r\n        if (lowFrequencyBound === void 0) { lowFrequencyBound = 0; }\r\n        if (normalize === void 0) { normalize = 'unit_sum'; }\r\n        if (numberBands === void 0) { numberBands = 24; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (type === void 0) { type = 'power'; }\r\n        if (weighting === void 0) { weighting = 'warping'; }\r\n        return this.algorithms.TriangularBarkBands(spectrum, highFrequencyBound, inputSize, log, lowFrequencyBound, normalize, numberBands, sampleRate, type, weighting);\r\n    };\r\n    /**\r\n    * This algorithm extracts a segment of an audio signal given its start and end times.\r\n    Giving \"startTime\" greater than \"endTime\" will raise an exception. Check https://essentia.upf.edu/reference/std_Trimmer.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {boolean} [checkRange=false] check whether the specified time range for a slice fits the size of input signal (throw exception if not)\r\n    * @param {number} [endTime=1e+06] the end time of the slice you want to extract [s]\r\n    * @param {number} [sampleRate=44100] the sampling rate of the input audio signal [Hz]\r\n    * @param {number} [startTime=0] the start time of the slice you want to extract [s]\r\n    * @returns {object} {signal: 'the trimmed signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Trimmer = function (signal, checkRange, endTime, sampleRate, startTime) {\r\n        if (checkRange === void 0) { checkRange = false; }\r\n        if (endTime === void 0) { endTime = 1e+06; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (startTime === void 0) { startTime = 0; }\r\n        return this.algorithms.Trimmer(signal, checkRange, endTime, sampleRate, startTime);\r\n    };\r\n    /**\r\n    * This algorithm calculates the tristimulus of a signal given its harmonic peaks. The tristimulus has been introduced as a timbre equivalent to the color attributes in the vision. Tristimulus measures the mixture of harmonics in a given sound, grouped into three sections. The first tristimulus measures the relative weight of the first harmonic; the second tristimulus measures the relative weight of the second, third, and fourth harmonics taken together; and the third tristimulus measures the relative weight of all the remaining harmonics. Check https://essentia.upf.edu/reference/std_Tristimulus.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frequencies the frequencies of the harmonic peaks ordered by frequency\r\n    * @param {VectorFloat} magnitudes the magnitudes of the harmonic peaks ordered by frequency\r\n    * @returns {object} {tristimulus: 'a three-element vector that measures the mixture of harmonics of the given spectrum'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Tristimulus = function (frequencies, magnitudes) {\r\n        return this.algorithms.Tristimulus(frequencies, magnitudes);\r\n    };\r\n    /**\r\n    * This algorithm implements a “true-peak” level meter for clipping detection. According to the ITU-R recommendations, “true-peak” values overcoming the full-scale range are potential sources of “clipping in subsequent processes, such as within particular D/A converters or during sample-rate conversion”.\r\n    The ITU-R BS.1770-4[1] (by default) and the ITU-R BS.1770-2[2] signal-flows can be used. Go to the references for information about the differences.\r\n    Only the peaks (if any) exceeding the configurable amplitude threshold are returned.\r\n    Note: the parameters 'blockDC' and 'emphasise' work only when 'version' is set to 2.\r\n    References:\r\n      [1] Series, B. S. (2011). Recommendation  ITU-R  BS.1770-4. Algorithms to measure audio programme loudness and true-peak audio level,\r\n      https://www.itu.int/dms_pubrec/itu-r/rec/bs/R-REC-BS.1770-4-201510-I!!PDF-E.pdf\r\n      [2] Series, B. S. (2011). Recommendation  ITU-R  BS.1770-2. Algorithms to measure audio programme loudness and true-peak audio level,\r\n      https://www.itu.int/dms_pubrec/itu-r/rec/bs/R-REC-BS.1770-2-201103-S!!PDF-E.pdf\r\n     Check https://essentia.upf.edu/reference/std_TruePeakDetector.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input audio signal\r\n    * @param {boolean} [blockDC=false] flag to activate the optional DC blocker\r\n    * @param {boolean} [emphasise=false] flag to activate the optional emphasis filter\r\n    * @param {number} [oversamplingFactor=4] times the signal is oversapled\r\n    * @param {number} [quality=1] type of interpolation applied (see libresmple)\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {number} [threshold=-0.0002] threshold to detect peaks [dB]\r\n    * @param {number} [version=4] algorithm version\r\n    * @returns {object} {peakLocations: 'the peak locations in the ouput signal', output: 'the processed signal'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TruePeakDetector = function (signal, blockDC, emphasise, oversamplingFactor, quality, sampleRate, threshold, version) {\r\n        if (blockDC === void 0) { blockDC = false; }\r\n        if (emphasise === void 0) { emphasise = false; }\r\n        if (oversamplingFactor === void 0) { oversamplingFactor = 4; }\r\n        if (quality === void 0) { quality = 1; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (threshold === void 0) { threshold = -0.0002; }\r\n        if (version === void 0) { version = 4; }\r\n        return this.algorithms.TruePeakDetector(signal, blockDC, emphasise, oversamplingFactor, quality, sampleRate, threshold, version);\r\n    };\r\n    /**\r\n    * This algorithm estimates the tuning frequency give a sequence/set of spectral peaks. The result is the tuning frequency in Hz, and its distance from 440Hz in cents. This version is slightly adapted from the original algorithm [1], but gives the same results. Check https://essentia.upf.edu/reference/std_TuningFrequency.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frequencies the frequencies of the spectral peaks [Hz]\r\n    * @param {VectorFloat} magnitudes the magnitudes of the spectral peaks\r\n    * @param {number} [resolution=1] resolution in cents (logarithmic scale, 100 cents = 1 semitone) for tuning frequency determination\r\n    * @returns {object} {tuningFrequency: 'the tuning frequency [Hz]', tuningCents: 'the deviation from 440 Hz (between -35 to 65 cents)'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TuningFrequency = function (frequencies, magnitudes, resolution) {\r\n        if (resolution === void 0) { resolution = 1; }\r\n        return this.algorithms.TuningFrequency(frequencies, magnitudes, resolution);\r\n    };\r\n    /**\r\n    * This algorithm extracts the tuning frequency of an audio signal Check https://essentia.upf.edu/reference/std_TuningFrequencyExtractor.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the audio input signal\r\n    * @param {number} [frameSize=4096] the frameSize for computing tuning frequency\r\n    * @param {number} [hopSize=2048] the hopsize for computing tuning frequency\r\n    * @returns {object} {tuningFrequency: 'the computed tuning frequency'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.TuningFrequencyExtractor = function (signal, frameSize, hopSize) {\r\n        if (frameSize === void 0) { frameSize = 4096; }\r\n        if (hopSize === void 0) { hopSize = 2048; }\r\n        return this.algorithms.TuningFrequencyExtractor(signal, frameSize, hopSize);\r\n    };\r\n    /**\r\n    * This algorithm performs basic arithmetical operations element by element given an array.\r\n    Note:\r\n      - log and ln are equivalent to the natural logarithm\r\n      - for log, ln, log10 and lin2db, x is clipped to 1e-30 for x<1e-30\r\n      - for x<0, sqrt(x) is invalid\r\n      - scale and shift parameters define linear transformation to be applied to the resulting elements Check https://essentia.upf.edu/reference/std_UnaryOperator.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @param {number} [scale=1] multiply result by factor\r\n    * @param {number} [shift=0] shift result by value (add value)\r\n    * @param {string} [type=identity] the type of the unary operator to apply to input array\r\n    * @returns {object} {array: 'the input array transformed by unary operation'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.UnaryOperator = function (array, scale, shift, type) {\r\n        if (scale === void 0) { scale = 1; }\r\n        if (shift === void 0) { shift = 0; }\r\n        if (type === void 0) { type = 'identity'; }\r\n        return this.algorithms.UnaryOperator(array, scale, shift, type);\r\n    };\r\n    /**\r\n    * This algorithm performs basic arithmetical operations element by element given an array.\r\n    Note:\r\n      - log and ln are equivalent to the natural logarithm\r\n      - for log, ln, log10 and lin2db, x is clipped to 1e-30 for x<1e-30\r\n      - for x<0, sqrt(x) is invalid\r\n      - scale and shift parameters define linear transformation to be applied to the resulting elements Check https://essentia.upf.edu/reference/std_UnaryOperatorStream.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @param {number} [scale=1] multiply result by factor\r\n    * @param {number} [shift=0] shift result by value (add value)\r\n    * @param {string} [type=identity] the type of the unary operator to apply to input array\r\n    * @returns {object} {array: 'the input array transformed by unary operation'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.UnaryOperatorStream = function (array, scale, shift, type) {\r\n        if (scale === void 0) { scale = 1; }\r\n        if (shift === void 0) { shift = 0; }\r\n        if (type === void 0) { type = 'identity'; }\r\n        return this.algorithms.UnaryOperatorStream(array, scale, shift, type);\r\n    };\r\n    /**\r\n    * This algorithm computes the variance of an array. Check https://essentia.upf.edu/reference/std_Variance.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the input array\r\n    * @returns {object} {variance: 'the variance of the input array'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Variance = function (array) {\r\n        return this.algorithms.Variance(array);\r\n    };\r\n    /**\r\n    * This algorithm detects the presence of vibrato and estimates its parameters given a pitch contour [Hz]. The result is the vibrato frequency in Hz and the extent (peak to peak) in cents. If no vibrato is detected in a frame, the output of both values is zero. Check https://essentia.upf.edu/reference/std_Vibrato.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} pitch the pitch trajectory [Hz].\r\n    * @param {number} [maxExtend=250] maximum considered vibrato extent [cents]\r\n    * @param {number} [maxFrequency=8] maximum considered vibrato frequency [Hz]\r\n    * @param {number} [minExtend=50] minimum considered vibrato extent [cents]\r\n    * @param {number} [minFrequency=4] minimum considered vibrato frequency [Hz]\r\n    * @param {number} [sampleRate=344.531] sample rate of the input pitch contour\r\n    * @returns {object} {vibratoFrequency: 'estimated vibrato frequency (or speed) [Hz]; zero if no vibrato was detected.', vibratoExtend: 'estimated vibrato extent (or depth) [cents]; zero if no vibrato was detected.'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Vibrato = function (pitch, maxExtend, maxFrequency, minExtend, minFrequency, sampleRate) {\r\n        if (maxExtend === void 0) { maxExtend = 250; }\r\n        if (maxFrequency === void 0) { maxFrequency = 8; }\r\n        if (minExtend === void 0) { minExtend = 50; }\r\n        if (minFrequency === void 0) { minFrequency = 4; }\r\n        if (sampleRate === void 0) { sampleRate = 344.531; }\r\n        return this.algorithms.Vibrato(pitch, maxExtend, maxFrequency, minExtend, minFrequency, sampleRate);\r\n    };\r\n    /**\r\n    * This algorithm computes the warped auto-correlation of an audio signal. The implementation is an adapted version of K. Schmidt's implementation of the matlab algorithm from the 'warped toolbox' by Aki Harma and Matti Karjalainen found [2]. For a detailed explanation of the algorithm, see [1].\r\n    This algorithm is only defined for positive lambda = 1.0674*sqrt(2.0*atan(0.00006583*sampleRate)/PI) - 0.1916, thus it will throw an exception when the supplied sampling rate does not pass the requirements.\r\n    If maxLag is larger than the size of the input array, an exception is thrown. Check https://essentia.upf.edu/reference/std_WarpedAutoCorrelation.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} array the array to be analyzed\r\n    * @param {number} [maxLag=1] the maximum lag for which the auto-correlation is computed (inclusive) (must be smaller than signal size)\r\n    * @param {number} [sampleRate=44100] the audio sampling rate [Hz]\r\n    * @returns {object} {warpedAutoCorrelation: 'the warped auto-correlation vector'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.WarpedAutoCorrelation = function (array, maxLag, sampleRate) {\r\n        if (maxLag === void 0) { maxLag = 1; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        return this.algorithms.WarpedAutoCorrelation(array, maxLag, sampleRate);\r\n    };\r\n    /**\r\n    *  This algorithm estimates the Power Spectral Density of the input signal using the Welch's method [1].\r\n     The input should be fed with the overlapped audio frames. The algorithm stores internally therequired past frames to compute each output. Call reset() to clear the buffers. This implentation is based on Scipy [2] Check https://essentia.upf.edu/reference/std_Welch.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input stereo audio signal\r\n    * @param {number} [averagingFrames=10] amount of frames to average\r\n    * @param {number} [fftSize=1024] size of the FFT. Zero padding is added if this is larger the input frame size.\r\n    * @param {number} [frameSize=512] the expected size of the input audio signal (this is an optional parameter to optimize memory allocation)\r\n    * @param {number} [sampleRate=44100] the sampling rate of the audio signal [Hz]\r\n    * @param {string} [scaling=density] 'density' normalizes the result to the bandwidth while 'power' outputs the unnormalized power spectrum\r\n    * @param {string} [windowType=hann] the window type, which can be 'hamming', 'hann', 'triangular', 'square' or 'blackmanharrisXX'\r\n    * @returns {object} {psd: 'Power Spectral Density [dB] or [dB/Hz]'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Welch = function (frame, averagingFrames, fftSize, frameSize, sampleRate, scaling, windowType) {\r\n        if (averagingFrames === void 0) { averagingFrames = 10; }\r\n        if (fftSize === void 0) { fftSize = 1024; }\r\n        if (frameSize === void 0) { frameSize = 512; }\r\n        if (sampleRate === void 0) { sampleRate = 44100; }\r\n        if (scaling === void 0) { scaling = 'density'; }\r\n        if (windowType === void 0) { windowType = 'hann'; }\r\n        return this.algorithms.Welch(frame, averagingFrames, fftSize, frameSize, sampleRate, scaling, windowType);\r\n    };\r\n    /**\r\n    * This algorithm applies windowing to an audio signal. It optionally applies zero-phase windowing and optionally adds zero-padding. The resulting windowed frame size is equal to the incoming frame size plus the number of padded zeros. By default, the available windows are normalized (to have an area of 1) and then scaled by a factor of 2. Check https://essentia.upf.edu/reference/std_Windowing.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} frame the input audio frame\r\n    * @param {boolean} [normalized=true] a boolean value to specify whether to normalize windows (to have an area of 1) and then scale by a factor of 2\r\n    * @param {number} [size=1024] the window size\r\n    * @param {string} [type=hann] the window type, which can be 'hamming', 'hann', 'triangular', 'square' or 'blackmanharrisXX'\r\n    * @param {number} [zeroPadding=0] the size of the zero-padding\r\n    * @param {boolean} [zeroPhase=true] a boolean value that enables zero-phase windowing\r\n    * @returns {object} {frame: 'the windowed audio frame'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.Windowing = function (frame, normalized, size, type, zeroPadding, zeroPhase) {\r\n        if (normalized === void 0) { normalized = true; }\r\n        if (size === void 0) { size = 1024; }\r\n        if (type === void 0) { type = 'hann'; }\r\n        if (zeroPadding === void 0) { zeroPadding = 0; }\r\n        if (zeroPhase === void 0) { zeroPhase = true; }\r\n        return this.algorithms.Windowing(frame, normalized, size, type, zeroPadding, zeroPhase);\r\n    };\r\n    /**\r\n    * This algorithm computes the zero-crossing rate of an audio signal. It is the number of sign changes between consecutive signal values divided by the total number of values. Noisy signals tend to have higher zero-crossing rate.\r\n    In order to avoid small variations around zero caused by noise, a threshold around zero is given to consider a valid zerocrosing whenever the boundary is crossed. Check https://essentia.upf.edu/reference/std_ZeroCrossingRate.html for more details.\r\n    * @method\r\n    * @param {VectorFloat} signal the input signal\r\n    * @param {number} [threshold=0] the threshold which will be taken as the zero axis in both positive and negative sign\r\n    * @returns {object} {zeroCrossingRate: 'the zero-crossing rate'}\r\n    * @memberof Essentia\r\n    */\r\n    Essentia.prototype.ZeroCrossingRate = function (signal, threshold) {\r\n        if (threshold === void 0) { threshold = 0; }\r\n        return this.algorithms.ZeroCrossingRate(signal, threshold);\r\n    };\r\n    return Essentia;\r\n}());\n\nexport default Essentia;\n","// EssentiaJS import for professional-grade audio analysis\nimport Essentia from 'essentia.js/dist/essentia.js-core.es.js';\n\n/**\n * Enhanced Web Audio API manager powered by EssentiaJS\n * Provides superior audio analysis and pitch detection for tongue drums\n */\nexport class AudioManager {\n  constructor(options = {}) {\n    this.audioContext = null;\n    this.analyser = null;\n    this.microphone = null;\n    this.stream = null;\n    this.essentia = null;\n    this.isListening = false;\n    this.animationFrame = null;\n    \n    // Configuration\n    this.fftSize = options.fftSize || 4096;\n    this.sampleRate = 44100;\n    this.sensitivity = options.sensitivity || 0.7;\n    this.cooldownTime = options.cooldownTime || 150;\n    this.lastDetectionTime = 0;\n    \n    // Callbacks\n    this.onNoteDetectedCallback = null;\n    this.onErrorCallback = null;\n    \n    // Tongue frequency mapping\n    this.tongueFrequencies = {};\n    \n    // Audio buffers for EssentiaJS\n    this.audioBuffer = new Float32Array(this.fftSize);\n    this.bufferIndex = 0;\n    this.bufferFilled = false;\n    \n    // Web Audio API fallback throttling\n    this.lastWebAudioAnalysis = 0;\n    this.webAudioThrottleMs = 50; // Analyze every 50ms for fallback\n    \n    // EssentiaJS initialization status\n    this.essentiaInitialized = false;\n    this.essentiaInitializing = false;\n  }\n\n  /**\n   * Initialize EssentiaJS for advanced audio analysis\n   */\n  async initializeEssentia() {\n    if (this.essentiaInitializing || this.essentiaInitialized) return this.essentiaInitialized;\n    \n    this.essentiaInitializing = true;\n    \n    try {\n      console.log('🎵 Initializing EssentiaJS for professional audio analysis...');\n      \n      // Initialize Essentia with proper configuration\n      this.essentia = new Essentia();\n      \n      // Verify EssentiaJS is ready\n      if (this.essentia && typeof this.essentia.Windowing === 'function') {\n        console.log('✅ EssentiaJS successfully initialized!');\n        this.essentiaInitialized = true;\n        this.essentiaInitializing = false;\n        return true;\n      } else {\n        throw new Error('EssentiaJS methods not available');\n      }\n    } catch (error) {\n      console.warn('⚠️ EssentiaJS initialization failed, using Web Audio API fallback:', error);\n      this.essentia = null;\n      this.essentiaInitialized = false;\n      this.essentiaInitializing = false;\n      return false;\n    }\n  }\n\n  /**\n   * Set callback for note detection events\n   */\n  onNoteDetected(callback) {\n    this.onNoteDetectedCallback = callback;\n  }\n\n  /**\n   * Set callback for error events\n   */\n  onError(callback) {\n    this.onErrorCallback = callback;\n  }\n\n  /**\n   * Update tongue frequency mappings\n   */\n  updateTongueFrequencies(frequencies) {\n    this.tongueFrequencies = { ...frequencies };\n  }\n\n  /**\n   * Set detection sensitivity (0.0 to 1.0)\n   */\n  setSensitivity(sensitivity) {\n    this.sensitivity = Math.max(0.0, Math.min(1.0, sensitivity));\n  }\n\n  /**\n   * Start listening for audio input\n   */\n  async startListening() {\n    if (this.isListening) return;\n\n    try {\n      // Request microphone access with enhanced constraints\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: false,\n          noiseSuppression: false,\n          autoGainControl: false,\n          sampleRate: this.sampleRate,\n          channelCount: 1\n        }\n      });\n\n      // Create audio context and nodes\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)({\n        sampleRate: this.sampleRate\n      });\n      \n      this.microphone = this.audioContext.createMediaStreamSource(this.stream);\n      this.analyser = this.audioContext.createAnalyser();\n      \n      // Configure analyser\n      this.analyser.fftSize = this.fftSize;\n      this.analyser.smoothingTimeConstant = 0.3;\n      this.analyser.minDecibels = -90;\n      this.analyser.maxDecibels = -10;\n\n      // Create a script processor for real-time audio analysis\n      this.processor = this.audioContext.createScriptProcessor(1024, 1, 1);\n      this.processor.onaudioprocess = (event) => {\n        this.processAudioFrame(event.inputBuffer.getChannelData(0));\n      };\n\n      // Connect audio graph\n      this.microphone.connect(this.analyser);\n      this.microphone.connect(this.processor);\n      this.processor.connect(this.audioContext.destination);\n\n      this.isListening = true;\n      console.log('Audio listening started');\n\n    } catch (error) {\n      console.error('Failed to start audio listening:', error);\n      if (this.onErrorCallback) {\n        this.onErrorCallback(`Microphone access failed: ${error.message}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Process real-time audio frames for pitch detection\n   */\n  processAudioFrame(inputData) {\n    if (!this.isListening) return;\n\n    // If EssentiaJS is available, use it for frame-by-frame analysis\n    if (this.essentia) {\n      // Fill audio buffer for EssentiaJS analysis\n      const framesToCopy = Math.min(inputData.length, this.audioBuffer.length - this.bufferIndex);\n      for (let i = 0; i < framesToCopy; i++) {\n        this.audioBuffer[this.bufferIndex + i] = inputData[i];\n      }\n      \n      this.bufferIndex += framesToCopy;\n      \n      // When buffer is full, analyze it with EssentiaJS\n      if (this.bufferIndex >= this.audioBuffer.length) {\n        this.bufferFilled = true;\n        this.bufferIndex = 0;\n        this.analyzeAudioBuffer();\n      }\n    } else {\n      // Fallback to Web Audio API analysis with throttling\n      const now = Date.now();\n      if (now - this.lastWebAudioAnalysis >= this.webAudioThrottleMs) {\n        this.lastWebAudioAnalysis = now;\n        this.analyzeWithWebAudio();\n      }\n    }\n  }\n\n  /**\n   * Analyze audio buffer using EssentiaJS for pitch detection\n   */\n  analyzeAudioBuffer() {\n    if (!this.bufferFilled) return;\n\n    try {\n      if (this.essentia) {\n        // Use EssentiaJS for advanced analysis\n        this.analyzeWithEssentia();\n      } else {\n        // Fallback to basic Web Audio API analysis\n        this.analyzeWithWebAudio();\n      }\n    } catch (error) {\n      console.warn('Audio analysis error:', error);\n      // Fallback to basic analysis if EssentiaJS fails\n      this.analyzeWithWebAudio();\n    }\n  }\n\n  /**\n   * Advanced analysis using EssentiaJS\n   */\n  analyzeWithEssentia() {\n    try {\n      // Apply windowing to reduce spectral leakage\n      const windowedSignal = this.essentia.Windowing(this.audioBuffer, 'hann');\n      \n      // Compute FFT spectrum for spectral analysis\n      const spectrum = this.essentia.Spectrum(windowedSignal);\n      \n      // Detect pitch using YIN algorithm (more accurate for monophonic instruments like tongue drums)\n      const pitchYin = this.essentia.PitchYin(this.audioBuffer, 0.15); // Slightly higher threshold for drums\n      \n      // Also try PitchYinFFT for comparison (works better for some frequencies)\n      let pitchYinFFT = null;\n      try {\n        pitchYinFFT = this.essentia.PitchYinFFT(this.audioBuffer, 4096, 0.15);\n      } catch (fftError) {\n        console.log('PitchYinFFT not available, using PitchYin only');\n      }\n      \n      // Find spectral peaks for harmonic analysis\n      const spectralPeaks = this.essentia.SpectralPeaks(spectrum);\n      \n      // Use the most reliable pitch estimate\n      let finalPitch = pitchYin;\n      if (pitchYinFFT && Math.abs(pitchYinFFT - pitchYin) < 20) {\n        // If both algorithms agree (within 20Hz), average them\n        finalPitch = (pitchYin + pitchYinFFT) / 2;\n      } else if (pitchYinFFT && pitchYin === 0) {\n        // If YIN failed but YinFFT has a result\n        finalPitch = pitchYinFFT;\n      }\n      \n      if (finalPitch && finalPitch > 50 && finalPitch < 2000) {\n        this.processPitchDetection(finalPitch, {\n          frequency: spectralPeaks.frequency || [],\n          magnitude: spectralPeaks.magnitude || [],\n          confidence: 0.8 // EssentiaJS provides high confidence\n        });\n      }\n    } catch (error) {\n      console.warn('EssentiaJS analysis failed, falling back to Web Audio API:', error);\n      this.analyzeWithWebAudio();\n    }\n  }\n\n  /**\n   * Basic analysis using Web Audio API as fallback\n   */\n  analyzeWithWebAudio() {\n    // Get frequency domain data from the existing analyser\n    const bufferLength = this.analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n    this.analyser.getByteFrequencyData(dataArray);\n    \n    // Find the peak frequency\n    let maxIndex = 0;\n    let maxValue = 0;\n    \n    for (let i = 0; i < bufferLength; i++) {\n      if (dataArray[i] > maxValue) {\n        maxValue = dataArray[i];\n        maxIndex = i;\n      }\n    }\n    \n    // Convert bin index to frequency\n    const frequency = (maxIndex * this.audioContext.sampleRate) / (this.analyser.fftSize * 2);\n    \n    // Only process if we have a strong enough signal and reasonable frequency\n    if (maxValue > 50 && frequency > 50 && frequency < 2000) {\n      this.processPitchDetection(frequency, { confidence: maxValue / 255 });\n    }\n  }\n\n  /**\n   * Combine multiple pitch estimates for higher accuracy\n   */\n  combinePitchEstimates(pitchYin, pitchMelodia, spectralPeaks) {\n    const pitches = [];\n    \n    // Add YIN pitch if valid\n    if (pitchYin > 0) pitches.push(pitchYin);\n    \n    // Add Melodia pitch if valid\n    if (pitchMelodia > 0) pitches.push(pitchMelodia);\n    \n    // Add dominant spectral peak if it looks like a fundamental\n    if (spectralPeaks.frequency.length > 0) {\n      const dominantFreq = spectralPeaks.frequency[0];\n      if (dominantFreq > 50 && dominantFreq < 2000) {\n        pitches.push(dominantFreq);\n      }\n    }\n    \n    if (pitches.length === 0) return null;\n    \n    // Return median pitch for robustness\n    pitches.sort((a, b) => a - b);\n    const midIndex = Math.floor(pitches.length / 2);\n    return pitches.length % 2 === 0 \n      ? (pitches[midIndex - 1] + pitches[midIndex]) / 2\n      : pitches[midIndex];\n  }\n\n  /**\n   * Process detected pitch and map to tongue\n   */\n  processPitchDetection(frequency, spectralPeaks) {\n    const currentTime = Date.now();\n    \n    // Apply cooldown to prevent excessive triggering\n    if (currentTime - this.lastDetectionTime < this.cooldownTime) {\n      return;\n    }\n\n    // Find closest tongue frequency\n    const detection = this.findClosestTongue(frequency, spectralPeaks);\n    \n    if (detection && detection.confidence >= this.sensitivity) {\n      this.lastDetectionTime = currentTime;\n      \n      if (this.onNoteDetectedCallback) {\n        this.onNoteDetectedCallback(detection);\n      }\n    }\n  }\n\n  /**\n   * Find the closest tongue for a detected frequency\n   */\n  findClosestTongue(frequency, spectralPeaks) {\n    if (Object.keys(this.tongueFrequencies).length === 0) {\n      return null;\n    }\n\n    let bestMatch = null;\n    let smallestDifference = Infinity;\n    \n    // Check each tongue frequency\n    for (const [tongueStr, tongueFreq] of Object.entries(this.tongueFrequencies)) {\n      const tongue = parseInt(tongueStr);\n      const difference = Math.abs(frequency - tongueFreq);\n      const percentDifference = difference / tongueFreq;\n      \n      // Enhanced tolerance based on spectral characteristics\n      let tolerance = 0.06; // Base 6% tolerance\n      \n      // Increase tolerance for higher frequencies\n      if (tongueFreq > 800) tolerance = 0.08;\n      if (tongueFreq > 1200) tolerance = 0.10;\n      \n      // Check for harmonic relationships in spectral peaks\n      const hasHarmonicSupport = this.checkHarmonicSupport(tongueFreq, spectralPeaks);\n      if (hasHarmonicSupport) {\n        tolerance += 0.02; // Allow slightly more tolerance with harmonic support\n      }\n      \n      if (percentDifference <= tolerance && difference < smallestDifference) {\n        smallestDifference = difference;\n        bestMatch = {\n          tongue: tongue,\n          frequency: frequency,\n          targetFrequency: tongueFreq,\n          confidence: Math.max(0, 1 - (percentDifference / tolerance))\n        };\n      }\n    }\n    \n    return bestMatch;\n  }\n\n  /**\n   * Check for harmonic support in spectral peaks\n   */\n  checkHarmonicSupport(fundamental, spectralPeaks) {\n    if (!spectralPeaks.frequency || spectralPeaks.frequency.length < 2) {\n      return false;\n    }\n    \n    // Look for 2nd and 3rd harmonics\n    const secondHarmonic = fundamental * 2;\n    const thirdHarmonic = fundamental * 3;\n    \n    const tolerance = 0.1; // 10% tolerance for harmonics\n    \n    for (const peakFreq of spectralPeaks.frequency) {\n      const secondDiff = Math.abs(peakFreq - secondHarmonic) / secondHarmonic;\n      const thirdDiff = Math.abs(peakFreq - thirdHarmonic) / thirdHarmonic;\n      \n      if (secondDiff <= tolerance || thirdDiff <= tolerance) {\n        return true;\n      }\n    }\n    \n    return false;\n  }\n\n  /**\n   * Stop listening and clean up resources\n   */\n  stopListening() {\n    if (!this.isListening) return;\n\n    this.isListening = false;\n\n    if (this.processor) {\n      this.processor.disconnect();\n      this.processor = null;\n    }\n\n    if (this.microphone) {\n      this.microphone.disconnect();\n      this.microphone = null;\n    }\n\n    if (this.analyser) {\n      this.analyser.disconnect();\n      this.analyser = null;\n    }\n\n    if (this.stream) {\n      this.stream.getTracks().forEach(track => track.stop());\n      this.stream = null;\n    }\n\n    if (this.audioContext && this.audioContext.state !== 'closed') {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n\n    console.log('Audio listening stopped');\n  }\n\n  /**\n   * Test microphone access and basic functionality\n   */\n  async testMicrophone() {\n    try {\n      const testStream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: this.sampleRate,\n          channelCount: 1\n        }\n      });\n      \n      // Test for a short duration\n      setTimeout(() => {\n        testStream.getTracks().forEach(track => track.stop());\n      }, 1000);\n      \n      return true;\n    } catch (error) {\n      console.error('Microphone test failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get current audio context state\n   */\n  getAudioContextState() {\n    return this.audioContext ? this.audioContext.state : 'closed';\n  }\n\n  /**\n   * Get sampling rate information\n   */\n  getSampleRate() {\n    return this.audioContext ? this.audioContext.sampleRate : this.sampleRate;\n  }\n}\n","/**\n * Drum configuration utilities and scale mappings for tongue drums\n * Handles frequency calculations, layouts, and preset configurations\n */\n\n// Scale patterns in semitones relative to root note\nexport const SCALE_PATTERNS = {\n  major: [0, 2, 4, 5, 7, 9, 11],\n  minor: [0, 2, 3, 5, 7, 8, 10],\n  pentatonic: [0, 2, 4, 7, 9],\n  minorPentatonic: [0, 3, 5, 7, 10],\n  dorian: [0, 2, 3, 5, 7, 9, 10],\n  mixolydian: [0, 2, 4, 5, 7, 9, 10],\n  lydian: [0, 2, 4, 6, 7, 9, 11],\n  akebono: [0, 2, 3, 7, 8],\n  hijaz: [0, 1, 4, 5, 7, 8, 11]\n};\n\n// Note names to semitone offsets from C\nexport const NOTE_TO_SEMITONE = {\n  'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5,\n  'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11\n};\n\n// Preset drum configurations with layouts and frequency mappings\nexport const DRUM_PRESETS = {\n  'D Major 15-note': {\n    noteCount: 15,\n    key: 'D',\n    scaleType: 'major',\n    rootOctave: 4,\n    layout: null\n  },\n  'G Minor 13-note': {\n    noteCount: 13,\n    key: 'G',\n    scaleType: 'minor',\n    rootOctave: 4,\n    layout: null\n  },\n  'C Pentatonic 11-note': {\n    noteCount: 11,\n    key: 'C',\n    scaleType: 'pentatonic',\n    rootOctave: 4,\n    layout: null\n  },\n  'A Minor Pentatonic 9-note': {\n    noteCount: 9,\n    key: 'A',\n    scaleType: 'minorPentatonic',\n    rootOctave: 4,\n    layout: null\n  },\n  'F Akebono 8-note': {\n    noteCount: 8,\n    key: 'F',\n    scaleType: 'akebono',\n    rootOctave: 4,\n    layout: null\n  }\n};\n\n/**\n * Drum configuration manager class\n */\nexport class DrumConfigManager {\n  constructor(config = {}) {\n    this.config = {\n      noteCount: config.noteCount || 15,\n      key: config.key || 'D',\n      scaleType: config.scaleType || 'major',\n      rootOctave: config.rootOctave || 4\n    };\n    \n    this.customLayouts = new Map();\n    this.loadPresetsFromStorage();\n  }\n\n  /**\n   * Update drum configuration\n   */\n  updateConfig(newConfig) {\n    this.config = { ...this.config, ...newConfig };\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig() {\n    return { ...this.config };\n  }\n\n  /**\n   * Calculate frequency for a specific tongue\n   */\n  getTongueFrequency(tongueNumber) {\n    if (tongueNumber < 1 || tongueNumber > this.config.noteCount) {\n      return null;\n    }\n    \n    // Get base frequency for root note in specified octave\n    const baseFrequency = this.getNoteFrequency(this.config.key, this.config.rootOctave);\n    \n    // Get scale pattern\n    const pattern = SCALE_PATTERNS[this.config.scaleType] || SCALE_PATTERNS.major;\n    \n    // Calculate note offset\n    const scaleIndex = (tongueNumber - 1) % pattern.length;\n    const octaveOffset = Math.floor((tongueNumber - 1) / pattern.length);\n    const semitoneOffset = pattern[scaleIndex] + (octaveOffset * 12);\n    \n    // Calculate frequency using equal temperament\n    return baseFrequency * Math.pow(2, semitoneOffset / 12);\n  }\n\n  /**\n   * Get all tongue frequencies as a mapping\n   */\n  getTongueFrequencies() {\n    const frequencies = {};\n    for (let i = 1; i <= this.config.noteCount; i++) {\n      frequencies[i] = this.getTongueFrequency(i);\n    }\n    return frequencies;\n  }\n\n  /**\n   * Get frequency for a specific note and octave\n   */\n  getNoteFrequency(note, octave) {\n    const semitoneOffset = NOTE_TO_SEMITONE[note] || 0;\n    // A4 = 440 Hz, calculate from there\n    const semitonesFromA4 = (octave - 4) * 12 + semitoneOffset - 9; // A is the 9th semitone\n    return 440 * Math.pow(2, semitonesFromA4 / 12);\n  }\n\n  /**\n   * Generate default circular layout for tongues\n   */\n  generateDefaultLayout() {\n    const positions = {};\n    const centerX = 300; // Canvas center\n    const centerY = 300;\n    const radius = 200;\n\n    for (let i = 1; i <= this.config.noteCount; i++) {\n      const angle = (2 * Math.PI * (i - 1)) / this.config.noteCount - Math.PI / 2;\n      const x = centerX + Math.cos(angle) * radius;\n      const y = centerY + Math.sin(angle) * radius;\n      \n      positions[i] = { x, y };\n    }\n\n    return {\n      name: `Default ${this.config.noteCount}-Note Layout`,\n      positions: positions\n    };\n  }\n\n  /**\n   * Load a preset configuration\n   */\n  loadPreset(presetName) {\n    const preset = DRUM_PRESETS[presetName];\n    if (!preset) {\n      console.warn(`Preset \"${presetName}\" not found`);\n      return null;\n    }\n\n    this.updateConfig({\n      noteCount: preset.noteCount,\n      key: preset.key,\n      scaleType: preset.scaleType,\n      rootOctave: preset.rootOctave\n    });\n\n    return preset.layout;\n  }\n\n  /**\n   * Save custom layout\n   */\n  saveCustomLayout(layout) {\n    this.customLayouts.set(layout.name, layout);\n    this.savePresetsToStorage();\n  }\n\n  /**\n   * Get custom layout by name\n   */\n  getCustomLayout(name) {\n    return this.customLayouts.get(name);\n  }\n\n  /**\n   * Get all available presets (built-in + custom)\n   */\n  getAllPresets() {\n    const presets = { ...DRUM_PRESETS };\n    \n    // Add custom layouts\n    for (const [name, layout] of this.customLayouts) {\n      presets[name] = {\n        noteCount: this.config.noteCount,\n        key: this.config.key,\n        scaleType: this.config.scaleType,\n        rootOctave: this.config.rootOctave,\n        layout: layout\n      };\n    }\n    \n    return presets;\n  }\n\n  /**\n   * Get formatted drum information string\n   */\n  getDrumInfo() {\n    const scaleDisplayName = this.config.scaleType.charAt(0).toUpperCase() + \n                           this.config.scaleType.slice(1);\n    return `${this.config.noteCount}-Note ${this.config.key} ${scaleDisplayName}`;\n  }\n\n  /**\n   * Get note name for a specific tongue\n   */\n  getTongueNoteName(tongueNumber) {\n    if (tongueNumber < 1 || tongueNumber > this.config.noteCount) {\n      return 'Invalid';\n    }\n    \n    const pattern = SCALE_PATTERNS[this.config.scaleType] || SCALE_PATTERNS.major;\n    const scaleIndex = (tongueNumber - 1) % pattern.length;\n    const octaveOffset = Math.floor((tongueNumber - 1) / pattern.length);\n    \n    // Calculate semitone offset from root\n    const rootSemitone = NOTE_TO_SEMITONE[this.config.key] || 0;\n    const noteSemitone = (rootSemitone + pattern[scaleIndex]) % 12;\n    const noteOctave = this.config.rootOctave + octaveOffset + \n                      Math.floor((rootSemitone + pattern[scaleIndex]) / 12);\n    \n    // Convert back to note name\n    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n    const noteName = noteNames[noteSemitone];\n    \n    return `${noteName}${noteOctave}`;\n  }\n\n  /**\n   * Analyze detected frequency and provide note information\n   */\n  analyzeFrequency(frequency) {\n    // Find closest semitone\n    const A4 = 440;\n    const semitoneFromA4 = Math.round(12 * Math.log2(frequency / A4));\n    const closestFrequency = A4 * Math.pow(2, semitoneFromA4 / 12);\n    const centsOff = Math.round(1200 * Math.log2(frequency / closestFrequency));\n    \n    // Calculate note name and octave\n    const noteIndex = (semitoneFromA4 + 9) % 12; // A4 is index 9\n    const octave = 4 + Math.floor((semitoneFromA4 + 9) / 12);\n    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n    const noteName = noteNames[noteIndex < 0 ? noteIndex + 12 : noteIndex];\n    \n    return {\n      frequency: frequency,\n      closestNote: `${noteName}${octave}`,\n      closestFrequency: closestFrequency,\n      centsOff: centsOff,\n      inTune: Math.abs(centsOff) <= 10\n    };\n  }\n\n  /**\n   * Validate if a tongue sequence is musically coherent\n   */\n  validateSequence(sequence) {\n    if (!sequence || sequence.length === 0) {\n      return { valid: false, reason: 'Empty sequence' };\n    }\n    \n    // Check if all tongue numbers are valid\n    for (const note of sequence) {\n      const tongueNumber = typeof note === 'object' ? note.tongue : note;\n      if (tongueNumber < 1 || tongueNumber > this.config.noteCount) {\n        return { valid: false, reason: `Invalid tongue number: ${tongueNumber}` };\n      }\n    }\n    \n    // Check for reasonable melodic intervals (no jumps > 2 octaves)\n    for (let i = 1; i < sequence.length; i++) {\n      const prevTongue = typeof sequence[i-1] === 'object' ? sequence[i-1].tongue : sequence[i-1];\n      const currTongue = typeof sequence[i] === 'object' ? sequence[i].tongue : sequence[i];\n      \n      const prevFreq = this.getTongueFrequency(prevTongue);\n      const currFreq = this.getTongueFrequency(currTongue);\n      \n      const interval = Math.abs(Math.log2(currFreq / prevFreq));\n      if (interval > 2) { // More than 2 octaves\n        return { \n          valid: false, \n          reason: `Large melodic jump between tongues ${prevTongue} and ${currTongue}` \n        };\n      }\n    }\n    \n    return { valid: true };\n  }\n\n  /**\n   * Save presets to localStorage\n   */\n  savePresetsToStorage() {\n    try {\n      const customData = {};\n      for (const [name, layout] of this.customLayouts) {\n        customData[name] = layout;\n      }\n      localStorage.setItem('tongueDrumCustomLayouts', JSON.stringify(customData));\n    } catch (error) {\n      console.warn('Failed to save custom layouts to storage:', error);\n    }\n  }\n\n  /**\n   * Load presets from localStorage\n   */\n  loadPresetsFromStorage() {\n    try {\n      const customData = localStorage.getItem('tongueDrumCustomLayouts');\n      if (customData) {\n        const layouts = JSON.parse(customData);\n        for (const [name, layout] of Object.entries(layouts)) {\n          this.customLayouts.set(name, layout);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load custom layouts from storage:', error);\n    }\n  }\n\n  /**\n   * Export configuration as JSON\n   */\n  exportConfig() {\n    return {\n      config: this.config,\n      customLayouts: Object.fromEntries(this.customLayouts),\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Import configuration from JSON\n   */\n  importConfig(data) {\n    try {\n      if (data.config) {\n        this.updateConfig(data.config);\n      }\n      \n      if (data.customLayouts) {\n        this.customLayouts.clear();\n        for (const [name, layout] of Object.entries(data.customLayouts)) {\n          this.customLayouts.set(name, layout);\n        }\n        this.savePresetsToStorage();\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Failed to import configuration:', error);\n      return false;\n    }\n  }\n}\n","import { DrumConfigManager } from '../utils/drumConfig.js';\n\n/**\n * DrumVisualizer component handles the drum display and tongue interactions\n */\nexport class DrumVisualizer {\n  constructor(container) {\n    this.container = container;\n    this.drumElement = container.querySelector('#drumVisual');\n    this.centerElement = container.querySelector('#centerNote');\n    \n    if (!this.drumElement || !this.centerElement) {\n      throw new Error('Required drum elements not found');\n    }\n\n    // Initialize with default configuration\n    this.configManager = new DrumConfigManager({\n      noteCount: 15,\n      key: 'D',\n      scaleType: 'major',\n      rootOctave: 4\n    });\n\n    this.customLayout = null;\n    this.onTongueClick = null;\n\n    this.updateDrumVisual();\n  }\n\n  /**\n   * Update drum configuration and refresh visual\n   */\n  updateConfiguration(config) {\n    this.configManager.updateConfig(config);\n    this.updateDrumVisual();\n  }\n\n  /**\n   * Set custom layout for tongues\n   */\n  setCustomLayout(layout) {\n    this.customLayout = layout;\n    this.updateDrumVisual();\n  }\n\n  /**\n   * Set callback for tongue click events\n   */\n  onTongueClicked(callback) {\n    this.onTongueClick = callback;\n  }\n\n  /**\n   * Highlight a specific tongue (for note detection feedback)\n   */\n  highlightTongue(tongueNumber, duration = 500) {\n    const tongue = this.drumElement.querySelector(`[data-tongue=\"${tongueNumber}\"]`);\n    if (!tongue) return;\n\n    // Clear existing highlighting\n    this.clearHighlights();\n\n    // Add playing class\n    tongue.classList.add('playing');\n\n    // Remove highlighting after duration\n    setTimeout(() => {\n      tongue.classList.remove('playing');\n    }, duration);\n  }\n\n  /**\n   * Show which tongue should be played next\n   */\n  showNextTongue(tongueNumber) {\n    // Clear existing next indicators\n    this.drumElement.querySelectorAll('.tongue').forEach(t => {\n      t.classList.remove('next');\n    });\n\n    // Highlight the next tongue\n    const tongue = this.drumElement.querySelector(`[data-tongue=\"${tongueNumber}\"]`);\n    if (tongue) {\n      tongue.classList.add('next');\n    }\n  }\n\n  /**\n   * Clear all visual highlights\n   */\n  clearHighlights() {\n    this.drumElement.querySelectorAll('.tongue').forEach(tongue => {\n      tongue.classList.remove('playing', 'next');\n    });\n  }\n\n  /**\n   * Get current drum configuration\n   */\n  getConfiguration() {\n    return this.configManager.getConfig();\n  }\n\n  /**\n   * Get tongue frequencies mapping\n   */\n  getTongueFrequencies() {\n    return this.configManager.getTongueFrequencies();\n  }\n\n  /**\n   * Update the visual drum display\n   */\n  updateDrumVisual() {\n    const config = this.configManager.getConfig();\n    \n    // Update drum size class\n    this.drumElement.className = `drum-visual drum-${config.noteCount}`;\n    \n    // Update center note\n    this.centerElement.className = `center-note center-${config.noteCount}`;\n    this.centerElement.textContent = '0';\n    \n    // Clear existing tongues\n    const existingTongues = this.drumElement.querySelectorAll('.tongue, .draggable-tongue');\n    existingTongues.forEach(tongue => tongue.remove());\n    \n    // Generate new tongues\n    if (this.customLayout) {\n      this.generateCustomLayout();\n    } else {\n      this.generateCircularLayout();\n    }\n  }\n\n  /**\n   * Generate tongues using custom layout positions\n   */\n  generateCustomLayout() {\n    if (!this.customLayout) return;\n\n    const config = this.configManager.getConfig();\n    const positions = this.customLayout.positions;\n    \n    for (let i = 1; i <= config.noteCount; i++) {\n      const tongue = document.createElement('div');\n      tongue.className = `tongue tongue-${config.noteCount}`;\n      tongue.dataset.tongue = i.toString();\n      tongue.textContent = i.toString();\n      \n      // Use custom position if available, otherwise default\n      if (positions[i]) {\n        // Convert absolute positions to relative for the visual drum container\n        const drumRect = this.drumElement.getBoundingClientRect();\n        const drumWidth = drumRect.width || 500;\n        const drumHeight = drumRect.height || 500;\n        const canvasWidth = 600; // Original canvas width from layout builder\n        const canvasHeight = 600; // Original canvas height from layout builder\n        \n        const scaleX = drumWidth / canvasWidth;\n        const scaleY = drumHeight / canvasHeight;\n        \n        const x = positions[i].x * scaleX;\n        const y = positions[i].y * scaleY;\n        \n        tongue.style.position = 'absolute';\n        tongue.style.left = x + 'px';\n        tongue.style.top = y + 'px';\n      } else {\n        // Fallback to circular positioning\n        this.positionTongueCircularly(tongue, i, config.noteCount);\n      }\n      \n      // Add click handler\n      tongue.addEventListener('click', () => {\n        if (this.onTongueClick) {\n          this.onTongueClick(i);\n        }\n      });\n      \n      this.drumElement.appendChild(tongue);\n    }\n  }\n\n  /**\n   * Generate tongues in circular layout\n   */\n  generateCircularLayout() {\n    const config = this.configManager.getConfig();\n    \n    for (let i = 1; i <= config.noteCount; i++) {\n      const tongue = document.createElement('div');\n      tongue.className = `tongue tongue-${config.noteCount}`;\n      tongue.dataset.tongue = i.toString();\n      tongue.textContent = i.toString();\n      \n      this.positionTongueCircularly(tongue, i, config.noteCount);\n      \n      // Add click handler\n      tongue.addEventListener('click', () => {\n        if (this.onTongueClick) {\n          this.onTongueClick(i);\n        }\n      });\n      \n      this.drumElement.appendChild(tongue);\n    }\n  }\n\n  /**\n   * Position a tongue element in circular layout\n   */\n  positionTongueCircularly(tongue, index, totalCount) {\n    const drumRect = this.drumElement.getBoundingClientRect();\n    const radius = Math.max(drumRect.width, drumRect.height) / 2 - 50;\n    \n    // Calculate position in circle (start at top, -Math.PI/2)\n    const angle = (2 * Math.PI * (index - 1)) / totalCount - Math.PI / 2;\n    const x = Math.cos(angle) * radius;\n    const y = Math.sin(angle) * radius;\n    \n    // Position relative to center\n    tongue.style.position = 'absolute';\n    tongue.style.left = `calc(50% + ${x}px - 22px)`; // Account for tongue width\n    tongue.style.top = `calc(50% + ${y}px - 35px)`; // Account for tongue height\n  }\n\n  /**\n   * Resize the drum visualization\n   */\n  resize() {\n    // Recalculate positions if using circular layout\n    if (!this.customLayout) {\n      this.updateDrumVisual();\n    }\n  }\n\n  /**\n   * Get formatted drum info string\n   */\n  getDrumInfo() {\n    return this.configManager.getDrumInfo();\n  }\n\n  /**\n   * Simulate note detection for testing\n   */\n  simulateNoteDetection(tongueNumber) {\n    const frequency = this.configManager.getTongueFrequency(tongueNumber);\n    if (!frequency) return null;\n\n    const detection = {\n      tongue: tongueNumber,\n      confidence: 0.95,\n      frequency: frequency,\n      targetFrequency: frequency\n    };\n\n    this.highlightTongue(tongueNumber);\n    return detection;\n  }\n\n  /**\n   * Load a preset configuration\n   */\n  loadPreset(presetName) {\n    const customLayout = this.configManager.loadPreset(presetName);\n    if (customLayout) {\n      this.setCustomLayout(customLayout);\n    } else {\n      this.setCustomLayout(null);\n    }\n    this.updateDrumVisual();\n    return true;\n  }\n\n  /**\n   * Get note name for a specific tongue\n   */\n  getTongueNoteName(tongueNumber) {\n    return this.configManager.getTongueNoteName(tongueNumber);\n  }\n\n  /**\n   * Get all available presets\n   */\n  getAllPresets() {\n    return this.configManager.getAllPresets();\n  }\n\n  /**\n   * Add visual feedback for successful note detection\n   */\n  showDetectionFeedback(detection) {\n    this.highlightTongue(detection.tongue, 400);\n    \n    // Add confidence indicator\n    const tongue = this.drumElement.querySelector(`[data-tongue=\"${detection.tongue}\"]`);\n    if (tongue && detection.confidence) {\n      const confidenceBar = document.createElement('div');\n      confidenceBar.className = 'confidence-indicator';\n      confidenceBar.style.width = `${detection.confidence * 100}%`;\n      tongue.appendChild(confidenceBar);\n      \n      setTimeout(() => {\n        confidenceBar.remove();\n      }, 400);\n    }\n  }\n\n  /**\n   * Show frequency analysis overlay\n   */\n  showFrequencyAnalysis(frequency) {\n    const analysis = this.configManager.analyzeFrequency(frequency);\n    \n    // Create temporary display element\n    const display = document.createElement('div');\n    display.className = 'frequency-analysis';\n    display.innerHTML = `\n      <div class=\"detected-freq\">${frequency.toFixed(1)} Hz</div>\n      <div class=\"closest-note\">${analysis.closestNote}</div>\n      <div class=\"cents-off ${analysis.inTune ? 'in-tune' : 'out-of-tune'}\">\n        ${analysis.centsOff > 0 ? '+' : ''}${analysis.centsOff} cents\n      </div>\n    `;\n    \n    this.container.appendChild(display);\n    \n    setTimeout(() => {\n      display.remove();\n    }, 2000);\n  }\n\n  /**\n   * Export current drum state\n   */\n  exportDrumState() {\n    return {\n      configuration: this.getConfiguration(),\n      customLayout: this.customLayout,\n      drumInfo: this.getDrumInfo(),\n      tongueFrequencies: this.getTongueFrequencies()\n    };\n  }\n\n  /**\n   * Import drum state\n   */\n  importDrumState(state) {\n    if (state.configuration) {\n      this.updateConfiguration(state.configuration);\n    }\n    \n    if (state.customLayout) {\n      this.setCustomLayout(state.customLayout);\n    }\n    \n    return true;\n  }\n}\n","/**\n * NotationBuilder component for creating visual sequences\n */\nexport class NotationBuilder {\n  constructor(container, drumConfig) {\n    this.container = container;\n    this.drumConfig = drumConfig;\n\n    // Get required elements\n    this.selectorGrid = container.querySelector('#tongueSelector');\n    this.sequenceContainer = container.querySelector('#sequenceContainer');\n    this.playButton = container.querySelector('#playSequence');\n    this.clearButton = container.querySelector('#clearSequence');\n    this.exportButton = container.querySelector('#exportSequence');\n    this.closeButton = container.querySelector('#closeBuilder');\n\n    if (!this.selectorGrid || !this.sequenceContainer || !this.playButton || \n        !this.clearButton || !this.exportButton || !this.closeButton) {\n      throw new Error('Required notation builder elements not found');\n    }\n\n    this.sequence = [];\n    this.isPlaying = false;\n    this.onSequenceChange = null;\n    this.onSequenceExport = null;\n    this.onClose = null;\n    this.onTonguePlay = null;\n\n    this.setupEventListeners();\n    this.createTongueSelector();\n    this.updateSequenceDisplay();\n  }\n\n  /**\n   * Set up event listeners for builder controls\n   */\n  setupEventListeners() {\n    this.playButton.addEventListener('click', () => this.playSequence());\n    this.clearButton.addEventListener('click', () => this.clearSequence());\n    this.exportButton.addEventListener('click', () => this.exportSequence());\n    this.closeButton.addEventListener('click', () => this.close());\n  }\n\n  /**\n   * Update drum configuration and regenerate selector\n   */\n  updateConfiguration(config) {\n    this.drumConfig = config;\n    this.createTongueSelector();\n  }\n\n  /**\n   * Set callback for sequence changes\n   */\n  onSequenceChanged(callback) {\n    this.onSequenceChange = callback;\n  }\n\n  /**\n   * Set callback for sequence export\n   */\n  onSequenceExported(callback) {\n    this.onSequenceExport = callback;\n  }\n\n  /**\n   * Set callback for builder close\n   */\n  onBuilderClosed(callback) {\n    this.onClose = callback;\n  }\n\n  /**\n   * Set callback for tongue play events\n   */\n  onTonguePlayback(callback) {\n    this.onTonguePlay = callback;\n  }\n\n  /**\n   * Create the tongue selector grid\n   */\n  createTongueSelector() {\n    this.selectorGrid.innerHTML = '';\n    \n    for (let i = 1; i <= this.drumConfig.noteCount; i++) {\n      const tongueDiv = document.createElement('div');\n      tongueDiv.className = 'selector-tongue';\n      tongueDiv.innerHTML = `\n        <div class=\"tongue-number\">${i}</div>\n        <div class=\"octave-controls\">\n          <div class=\"octave-btn\" data-octave=\"high\" title=\"High octave\">↑</div>\n          <div class=\"octave-btn active\" data-octave=\"middle\" title=\"Middle octave\">•</div>\n          <div class=\"octave-btn\" data-octave=\"low\" title=\"Low octave\">↓</div>\n        </div>\n      `;\n      \n      // Add click handlers\n      tongueDiv.addEventListener('click', (e) => {\n        const target = e.target;\n        if (target.classList.contains('octave-btn')) {\n          this.setOctaveForTongue(tongueDiv, target.dataset.octave);\n        } else if (!target.closest('.octave-controls')) {\n          this.addNoteToSequence(i, this.getSelectedOctave(tongueDiv));\n        }\n      });\n      \n      this.selectorGrid.appendChild(tongueDiv);\n    }\n  }\n\n  /**\n   * Set octave selection for a tongue\n   */\n  setOctaveForTongue(tongueDiv, octave) {\n    // Update octave button states\n    tongueDiv.querySelectorAll('.octave-btn').forEach(btn => {\n      btn.classList.remove('active');\n    });\n    tongueDiv.querySelector(`[data-octave=\"${octave}\"]`)?.classList.add('active');\n  }\n\n  /**\n   * Get selected octave for a tongue\n   */\n  getSelectedOctave(tongueDiv) {\n    const activeBtn = tongueDiv.querySelector('.octave-btn.active');\n    return activeBtn?.dataset.octave || 'middle';\n  }\n\n  /**\n   * Add a note to the sequence\n   */\n  addNoteToSequence(tongueNumber, octave) {\n    const note = {\n      tongue: tongueNumber,\n      octave: octave\n    };\n    \n    this.sequence.push(note);\n    this.updateSequenceDisplay();\n    \n    // Trigger callbacks\n    if (this.onSequenceChange) {\n      this.onSequenceChange([...this.sequence]);\n    }\n    \n    if (this.onTonguePlay) {\n      this.onTonguePlay(tongueNumber);\n    }\n  }\n\n  /**\n   * Remove a note from the sequence\n   */\n  removeNoteFromSequence(index) {\n    if (index >= 0 && index < this.sequence.length) {\n      this.sequence.splice(index, 1);\n      this.updateSequenceDisplay();\n      \n      if (this.onSequenceChange) {\n        this.onSequenceChange([...this.sequence]);\n      }\n    }\n  }\n\n  /**\n   * Update the sequence display\n   */\n  updateSequenceDisplay() {\n    if (this.sequence.length === 0) {\n      this.sequenceContainer.innerHTML = '<div class=\"empty-sequence\">Click tongue numbers above to start building your song!</div>';\n      return;\n    }\n    \n    this.sequenceContainer.innerHTML = '';\n    \n    this.sequence.forEach((note, index) => {\n      const noteDiv = document.createElement('div');\n      noteDiv.className = 'sequence-note';\n      \n      const octaveMarker = note.octave === 'high' \n        ? '<div class=\"note-octave high\">•</div>'\n        : note.octave === 'low' \n        ? '<div class=\"note-octave low\">•</div>'\n        : '';\n      \n      noteDiv.innerHTML = `\n        <div class=\"note-number\">${note.tongue}</div>\n        ${octaveMarker}\n        <button class=\"note-remove\" data-index=\"${index}\">×</button>\n      `;\n      \n      // Add remove handler\n      const removeBtn = noteDiv.querySelector('.note-remove');\n      removeBtn.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.removeNoteFromSequence(index);\n      });\n      \n      this.sequenceContainer.appendChild(noteDiv);\n    });\n  }\n\n  /**\n   * Play the current sequence\n   */\n  async playSequence() {\n    if (this.sequence.length === 0) {\n      alert('Please add some notes to the sequence first!');\n      return;\n    }\n    \n    if (this.isPlaying) return;\n    \n    this.isPlaying = true;\n    this.playButton.textContent = '⏸️ Playing...';\n    this.playButton.setAttribute('disabled', 'true');\n    \n    try {\n      for (let i = 0; i < this.sequence.length; i++) {\n        const note = this.sequence[i];\n        \n        // Highlight current note in sequence\n        const sequenceNotes = this.sequenceContainer.querySelectorAll('.sequence-note');\n        sequenceNotes.forEach(n => n.classList.remove('playing'));\n        if (sequenceNotes[i]) {\n          sequenceNotes[i].classList.add('playing');\n        }\n        \n        // Play note\n        if (this.onTonguePlay) {\n          this.onTonguePlay(note.tongue);\n        }\n        \n        // Wait before next note\n        await new Promise(resolve => setTimeout(resolve, 600));\n      }\n      \n      // Clear highlights\n      const sequenceNotes = this.sequenceContainer.querySelectorAll('.sequence-note');\n      sequenceNotes.forEach(n => n.classList.remove('playing'));\n      \n    } finally {\n      this.isPlaying = false;\n      this.playButton.textContent = '▶️ Play Sequence';\n      this.playButton.removeAttribute('disabled');\n    }\n  }\n\n  /**\n   * Clear the sequence\n   */\n  clearSequence() {\n    this.sequence = [];\n    this.updateSequenceDisplay();\n    \n    if (this.onSequenceChange) {\n      this.onSequenceChange([]);\n    }\n  }\n\n  /**\n   * Export the sequence\n   */\n  exportSequence() {\n    if (this.sequence.length === 0) {\n      alert('Please add some notes to the sequence first!');\n      return;\n    }\n    \n    if (this.onSequenceExport) {\n      this.onSequenceExport([...this.sequence]);\n    }\n  }\n\n  /**\n   * Close the builder\n   */\n  close() {\n    if (this.onClose) {\n      this.onClose();\n    }\n  }\n\n  /**\n   * Show/hide the builder\n   */\n  setVisible(visible) {\n    this.container.style.display = visible ? 'block' : 'none';\n  }\n\n  /**\n   * Get current sequence\n   */\n  getSequence() {\n    return [...this.sequence];\n  }\n\n  /**\n   * Set sequence (for loading saved sequences)\n   */\n  setSequence(sequence) {\n    this.sequence = [...sequence];\n    this.updateSequenceDisplay();\n    \n    if (this.onSequenceChange) {\n      this.onSequenceChange([...this.sequence]);\n    }\n  }\n\n  /**\n   * Convert sequence to simple notation format\n   */\n  sequenceToNotation() {\n    return this.sequence.map(note => {\n      if (note.octave === 'high') {\n        return `${note.tongue}^`;\n      } else if (note.octave === 'low') {\n        return `${note.tongue}v`;\n      } else {\n        return note.tongue;\n      }\n    });\n  }\n\n  /**\n   * Convert notation format to sequence\n   */\n  static notationToSequence(notation) {\n    return notation.map(note => {\n      if (typeof note === 'string') {\n        if (note.endsWith('^')) {\n          return {\n            tongue: parseInt(note.slice(0, -1)),\n            octave: 'high'\n          };\n        } else if (note.endsWith('v')) {\n          return {\n            tongue: parseInt(note.slice(0, -1)),\n            octave: 'low'\n          };\n        } else {\n          return {\n            tongue: parseInt(note),\n            octave: 'middle'\n          };\n        }\n      } else {\n        return {\n          tongue: note,\n          octave: 'middle'\n        };\n      }\n    });\n  }\n\n  /**\n   * Generate random sequence for testing\n   */\n  generateRandomSequence(length = 8) {\n    this.clearSequence();\n    \n    for (let i = 0; i < length; i++) {\n      const tongueNumber = Math.floor(Math.random() * this.drumConfig.noteCount) + 1;\n      const octaves = ['low', 'middle', 'high'];\n      const octave = octaves[Math.floor(Math.random() * octaves.length)];\n      \n      this.addNoteToSequence(tongueNumber, octave);\n    }\n  }\n\n  /**\n   * Import sequence from various formats\n   */\n  importSequence(data) {\n    try {\n      let sequence;\n      \n      if (typeof data === 'string') {\n        // Try to parse as JSON\n        sequence = JSON.parse(data);\n      } else if (Array.isArray(data)) {\n        sequence = data;\n      } else {\n        throw new Error('Invalid sequence format');\n      }\n      \n      // Validate sequence\n      if (!Array.isArray(sequence)) {\n        throw new Error('Sequence must be an array');\n      }\n      \n      for (const note of sequence) {\n        if (!note.tongue || note.tongue < 1 || note.tongue > this.drumConfig.noteCount) {\n          throw new Error(`Invalid tongue number: ${note.tongue}`);\n        }\n        if (note.octave && !['low', 'middle', 'high'].includes(note.octave)) {\n          throw new Error(`Invalid octave: ${note.octave}`);\n        }\n      }\n      \n      this.setSequence(sequence);\n      return true;\n      \n    } catch (error) {\n      console.error('Failed to import sequence:', error);\n      alert(`Failed to import sequence: ${error.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * Get sequence statistics\n   */\n  getSequenceStats() {\n    if (this.sequence.length === 0) {\n      return null;\n    }\n    \n    const tongueUsage = {};\n    const octaveUsage = { low: 0, middle: 0, high: 0 };\n    let totalTongues = new Set();\n    \n    for (const note of this.sequence) {\n      tongueUsage[note.tongue] = (tongueUsage[note.tongue] || 0) + 1;\n      octaveUsage[note.octave] = (octaveUsage[note.octave] || 0) + 1;\n      totalTongues.add(note.tongue);\n    }\n    \n    return {\n      length: this.sequence.length,\n      uniqueTongues: totalTongues.size,\n      tongueUsage: tongueUsage,\n      octaveUsage: octaveUsage,\n      coverage: (totalTongues.size / this.drumConfig.noteCount) * 100\n    };\n  }\n}\n","/**\n * LayoutBuilder component for creating custom drum layouts with drag-and-drop\n */\nexport class LayoutBuilder {\n  constructor(container, drumConfig) {\n    this.container = container;\n    this.drumConfig = drumConfig;\n\n    // Get required elements\n    this.canvas = container.querySelector('#layoutCanvas');\n    this.saveButton = container.querySelector('#saveLayout');\n    this.resetButton = container.querySelector('#resetLayout');\n    this.closeButton = container.querySelector('#closeLayoutBuilder');\n    this.nameInput = container.querySelector('#layoutName');\n\n    if (!this.canvas || !this.saveButton || !this.resetButton || \n        !this.closeButton || !this.nameInput) {\n      throw new Error('Required layout builder elements not found');\n    }\n\n    // Initialize with default circular layout\n    this.currentLayout = this.generateDefaultLayout();\n    \n    this.dragState = {\n      isDragging: false,\n      dragElement: null,\n      dragOffset: { x: 0, y: 0 }\n    };\n    \n    this.onLayoutSaved = null;\n    this.onClose = null;\n    \n    this.setupEventListeners();\n    this.createDraggableTongues();\n  }\n\n  /**\n   * Set up event listeners\n   */\n  setupEventListeners() {\n    this.saveButton.addEventListener('click', () => this.saveLayout());\n    this.resetButton.addEventListener('click', () => this.resetLayout());\n    this.closeButton.addEventListener('click', () => this.close());\n\n    // Canvas mouse events for dragging\n    this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));\n    this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));\n    this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));\n    this.canvas.addEventListener('mouseleave', (e) => this.handleMouseUp(e));\n\n    // Touch events for mobile\n    this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));\n    this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));\n    this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));\n  }\n\n  /**\n   * Update drum configuration and regenerate layout\n   */\n  updateConfiguration(config) {\n    this.drumConfig = config;\n    this.currentLayout = this.generateDefaultLayout();\n    this.createDraggableTongues();\n  }\n\n  /**\n   * Set callback for layout saved\n   */\n  onLayoutSave(callback) {\n    this.onLayoutSaved = callback;\n  }\n\n  /**\n   * Set callback for builder close\n   */\n  onBuilderClosed(callback) {\n    this.onClose = callback;\n  }\n\n  /**\n   * Generate default circular layout\n   */\n  generateDefaultLayout() {\n    const positions = {};\n    const canvasRect = this.canvas.getBoundingClientRect();\n    const centerX = canvasRect.width / 2 || 300;\n    const centerY = canvasRect.height / 2 || 300;\n    const radius = Math.min(centerX, centerY) - 60;\n\n    for (let i = 1; i <= this.drumConfig.noteCount; i++) {\n      const angle = (2 * Math.PI * (i - 1)) / this.drumConfig.noteCount - Math.PI / 2;\n      const x = centerX + Math.cos(angle) * radius;\n      const y = centerY + Math.sin(angle) * radius;\n      \n      positions[i] = { x, y };\n    }\n\n    return {\n      name: `Custom ${this.drumConfig.noteCount}-Note Layout`,\n      positions: positions\n    };\n  }\n\n  /**\n   * Create draggable tongue elements\n   */\n  createDraggableTongues() {\n    this.canvas.innerHTML = '';\n    \n    // Create center reference\n    const centerDiv = document.createElement('div');\n    centerDiv.className = 'layout-center';\n    centerDiv.textContent = '0';\n    this.canvas.appendChild(centerDiv);\n\n    // Create draggable tongues\n    for (let i = 1; i <= this.drumConfig.noteCount; i++) {\n      const tongueDiv = document.createElement('div');\n      tongueDiv.className = 'draggable-tongue';\n      tongueDiv.dataset.tongue = i.toString();\n      tongueDiv.textContent = i.toString();\n      tongueDiv.draggable = false; // Use custom drag handling\n      \n      // Position according to current layout\n      const pos = this.currentLayout.positions[i];\n      if (pos) {\n        tongueDiv.style.left = pos.x + 'px';\n        tongueDiv.style.top = pos.y + 'px';\n      }\n      \n      this.canvas.appendChild(tongueDiv);\n    }\n  }\n\n  /**\n   * Handle mouse down for drag start\n   */\n  handleMouseDown(e) {\n    const target = e.target;\n    if (!target.classList.contains('draggable-tongue')) return;\n\n    e.preventDefault();\n    this.startDrag(target, e.clientX, e.clientY);\n  }\n\n  /**\n   * Handle mouse move for dragging\n   */\n  handleMouseMove(e) {\n    if (!this.dragState.isDragging || !this.dragState.dragElement) return;\n\n    e.preventDefault();\n    this.updateDragPosition(e.clientX, e.clientY);\n  }\n\n  /**\n   * Handle mouse up for drag end\n   */\n  handleMouseUp(e) {\n    if (this.dragState.isDragging) {\n      this.endDrag();\n    }\n  }\n\n  /**\n   * Handle touch start\n   */\n  handleTouchStart(e) {\n    const target = e.target;\n    if (!target.classList.contains('draggable-tongue')) return;\n\n    e.preventDefault();\n    const touch = e.touches[0];\n    this.startDrag(target, touch.clientX, touch.clientY);\n  }\n\n  /**\n   * Handle touch move\n   */\n  handleTouchMove(e) {\n    if (!this.dragState.isDragging || !this.dragState.dragElement) return;\n\n    e.preventDefault();\n    const touch = e.touches[0];\n    this.updateDragPosition(touch.clientX, touch.clientY);\n  }\n\n  /**\n   * Handle touch end\n   */\n  handleTouchEnd(e) {\n    if (this.dragState.isDragging) {\n      this.endDrag();\n    }\n  }\n\n  /**\n   * Start dragging a tongue element\n   */\n  startDrag(element, clientX, clientY) {\n    const canvasRect = this.canvas.getBoundingClientRect();\n    const elementRect = element.getBoundingClientRect();\n    \n    this.dragState = {\n      isDragging: true,\n      dragElement: element,\n      dragOffset: {\n        x: clientX - elementRect.left,\n        y: clientY - elementRect.top\n      }\n    };\n    \n    element.classList.add('dragging');\n    this.canvas.classList.add('dragging-active');\n  }\n\n  /**\n   * Update drag position\n   */\n  updateDragPosition(clientX, clientY) {\n    if (!this.dragState.dragElement) return;\n\n    const canvasRect = this.canvas.getBoundingClientRect();\n    let x = clientX - canvasRect.left - this.dragState.dragOffset.x;\n    let y = clientY - canvasRect.top - this.dragState.dragOffset.y;\n    \n    // Constrain to canvas bounds\n    const tongueWidth = 44; // From CSS\n    const tongueHeight = 70; // From CSS\n    \n    x = Math.max(0, Math.min(x, canvasRect.width - tongueWidth));\n    y = Math.max(0, Math.min(y, canvasRect.height - tongueHeight));\n    \n    this.dragState.dragElement.style.left = x + 'px';\n    this.dragState.dragElement.style.top = y + 'px';\n  }\n\n  /**\n   * End dragging and update layout\n   */\n  endDrag() {\n    if (!this.dragState.dragElement) return;\n\n    const element = this.dragState.dragElement;\n    const tongueNumber = parseInt(element.dataset.tongue || '0');\n    \n    if (tongueNumber > 0) {\n      // Update layout position\n      this.currentLayout.positions[tongueNumber] = {\n        x: parseFloat(element.style.left),\n        y: parseFloat(element.style.top)\n      };\n    }\n    \n    element.classList.remove('dragging');\n    this.canvas.classList.remove('dragging-active');\n    \n    this.dragState = {\n      isDragging: false,\n      dragElement: null,\n      dragOffset: { x: 0, y: 0 }\n    };\n  }\n\n  /**\n   * Save the current layout\n   */\n  saveLayout() {\n    const layoutName = this.nameInput.value.trim();\n    if (!layoutName) {\n      alert('Please enter a name for the layout');\n      this.nameInput.focus();\n      return;\n    }\n    \n    const layout = {\n      name: layoutName,\n      positions: { ...this.currentLayout.positions }\n    };\n    \n    if (this.onLayoutSaved) {\n      this.onLayoutSaved(layout);\n    }\n    \n    alert(`Layout \"${layoutName}\" saved successfully!`);\n  }\n\n  /**\n   * Reset layout to default circular arrangement\n   */\n  resetLayout() {\n    if (confirm('Reset all tongue positions to default circular layout?')) {\n      this.currentLayout = this.generateDefaultLayout();\n      this.createDraggableTongues();\n    }\n  }\n\n  /**\n   * Close the layout builder\n   */\n  close() {\n    if (this.onClose) {\n      this.onClose();\n    }\n  }\n\n  /**\n   * Show/hide the builder\n   */\n  setVisible(visible) {\n    this.container.style.display = visible ? 'block' : 'none';\n    if (visible) {\n      // Reset layout name input\n      this.nameInput.value = this.currentLayout.name || '';\n    }\n  }\n\n  /**\n   * Load an existing layout for editing\n   */\n  loadLayout(layout) {\n    this.currentLayout = {\n      name: layout.name,\n      positions: { ...layout.positions }\n    };\n    \n    this.nameInput.value = layout.name;\n    this.createDraggableTongues();\n  }\n\n  /**\n   * Get current layout\n   */\n  getCurrentLayout() {\n    return {\n      name: this.currentLayout.name,\n      positions: { ...this.currentLayout.positions }\n    };\n  }\n\n  /**\n   * Auto-arrange tongues in specific patterns\n   */\n  autoArrangePattern(pattern) {\n    const canvasRect = this.canvas.getBoundingClientRect();\n    const centerX = canvasRect.width / 2 || 300;\n    const centerY = canvasRect.height / 2 || 300;\n    const positions = {};\n\n    switch (pattern) {\n      case 'circle':\n        const radius = Math.min(centerX, centerY) - 60;\n        for (let i = 1; i <= this.drumConfig.noteCount; i++) {\n          const angle = (2 * Math.PI * (i - 1)) / this.drumConfig.noteCount - Math.PI / 2;\n          positions[i] = {\n            x: centerX + Math.cos(angle) * radius,\n            y: centerY + Math.sin(angle) * radius\n          };\n        }\n        break;\n\n      case 'grid':\n        const cols = Math.ceil(Math.sqrt(this.drumConfig.noteCount));\n        const spacing = Math.min(canvasRect.width, canvasRect.height) / (cols + 1);\n        for (let i = 1; i <= this.drumConfig.noteCount; i++) {\n          const row = Math.floor((i - 1) / cols);\n          const col = (i - 1) % cols;\n          positions[i] = {\n            x: spacing * (col + 1),\n            y: spacing * (row + 1)\n          };\n        }\n        break;\n\n      case 'spiral':\n        let angle = 0;\n        let radiusSpiral = 20;\n        const spiralGrowth = 15;\n        for (let i = 1; i <= this.drumConfig.noteCount; i++) {\n          positions[i] = {\n            x: centerX + Math.cos(angle) * radiusSpiral,\n            y: centerY + Math.sin(angle) * radiusSpiral\n          };\n          angle += 0.8;\n          radiusSpiral += spiralGrowth;\n        }\n        break;\n\n      case 'line':\n        const spacing_line = (canvasRect.width - 80) / (this.drumConfig.noteCount - 1);\n        for (let i = 1; i <= this.drumConfig.noteCount; i++) {\n          positions[i] = {\n            x: 40 + (i - 1) * spacing_line,\n            y: centerY\n          };\n        }\n        break;\n\n      default:\n        console.warn(`Unknown pattern: ${pattern}`);\n        return;\n    }\n\n    this.currentLayout.positions = positions;\n    this.createDraggableTongues();\n  }\n\n  /**\n   * Export layout as JSON\n   */\n  exportLayout() {\n    const layoutData = {\n      ...this.getCurrentLayout(),\n      drumConfig: this.drumConfig,\n      timestamp: new Date().toISOString()\n    };\n\n    const blob = new Blob([JSON.stringify(layoutData, null, 2)], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    \n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `tongue-drum-layout-${layoutData.name.replace(/\\s+/g, '-')}.json`;\n    a.click();\n    \n    URL.revokeObjectURL(url);\n  }\n\n  /**\n   * Import layout from JSON\n   */\n  importLayout(data) {\n    try {\n      let layoutData;\n      \n      if (typeof data === 'string') {\n        layoutData = JSON.parse(data);\n      } else {\n        layoutData = data;\n      }\n      \n      // Validate layout structure\n      if (!layoutData.name || !layoutData.positions) {\n        throw new Error('Invalid layout format');\n      }\n      \n      // Load the layout\n      this.loadLayout(layoutData);\n      return true;\n      \n    } catch (error) {\n      console.error('Failed to import layout:', error);\n      alert(`Failed to import layout: ${error.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * Get layout statistics\n   */\n  getLayoutStats() {\n    const positions = Object.values(this.currentLayout.positions);\n    if (positions.length === 0) return null;\n    \n    const xs = positions.map(p => p.x);\n    const ys = positions.map(p => p.y);\n    \n    return {\n      tongueCount: positions.length,\n      bounds: {\n        minX: Math.min(...xs),\n        maxX: Math.max(...xs),\n        minY: Math.min(...ys),\n        maxY: Math.max(...ys)\n      },\n      center: {\n        x: xs.reduce((a, b) => a + b, 0) / xs.length,\n        y: ys.reduce((a, b) => a + b, 0) / ys.length\n      }\n    };\n  }\n}\n","import { AudioManager } from './audio/audioManager.js';\nimport { DrumVisualizer } from './components/DrumVisualizer.js';\nimport { NotationBuilder } from './components/NotationBuilder.js';\nimport { LayoutBuilder } from './components/LayoutBuilder.js';\n\n/**\n * Main application class for the Tongue Drum Chum app\n * Now powered by EssentiaJS for professional-grade audio analysis\n */\nclass TongueDrumApp {\n  constructor() {\n    this.audioManager = null;\n    this.drumVisualizer = null;\n    this.notationBuilder = null;\n    this.layoutBuilder = null;\n\n    // Application state\n    this.isListening = false;\n    this.currentConfig = {\n      noteCount: 15,\n      key: 'D',\n      scaleType: 'major',\n      rootOctave: 4\n    };\n    this.detectionHistory = [];\n\n    this.initializeElements();\n    this.setupEventListeners();\n    this.initializeComponents();\n    this.updateUI();\n  }\n\n  /**\n   * Initialize DOM elements\n   */\n  initializeElements() {\n    // Setup panel and navigation - map to actual HTML IDs\n    this.setupPanel = document.querySelector('.setup-panel');\n    this.tabButtons = document.querySelectorAll('.tab');\n    this.tabPanels = document.querySelectorAll('.tab-content');\n\n    // Control buttons - map to actual HTML IDs\n    this.startButton = document.getElementById('startButton');\n    this.stopButton = null; // We'll create this dynamically or handle differently\n    this.testMicButton = document.getElementById('testMicrophone');\n\n    // Create sensitivity controls if they don't exist\n    this.sensitivitySlider = this.createSensitivityControls();\n    this.sensitivityValue = document.getElementById('sensitivityValue');\n\n    // Status displays - map to actual HTML IDs\n    this.detectionResults = document.getElementById('detectionResults');\n    this.audioInfo = document.querySelector('.audio-metrics');\n    this.statusMessage = document.getElementById('status');\n    this.progressBar = document.getElementById('progressFill');\n\n    // Configuration controls - map to actual HTML IDs\n    this.drumSizeSelect = document.getElementById('noteCount');\n    this.keySelect = document.getElementById('drumKey');\n    this.scaleSelect = document.getElementById('scaleType');\n    this.octaveSelect = document.getElementById('rootOctave');\n    this.presetSelect = this.createPresetSelect();\n    this.loadPresetButton = document.getElementById('applyManualConfig');\n\n    // Builder toggles - map to actual HTML IDs\n    this.notationToggle = document.getElementById('toggleBuilder');\n    this.layoutToggle = document.getElementById('loadPhoto'); // We'll repurpose this\n\n    // Auto-detection button\n    this.autoDetectButton = document.getElementById('startDetection');\n\n    // Validate required elements with more lenient approach\n    const requiredElements = [\n      this.setupPanel, this.startButton, this.testMicButton,\n      this.audioInfo, this.statusMessage, this.drumSizeSelect, \n      this.keySelect, this.scaleSelect\n    ];\n\n    const missingElements = requiredElements.filter(el => !el);\n    if (missingElements.length > 0) {\n      console.warn('Some optional DOM elements not found, but continuing...');\n    }\n  }\n\n  /**\n   * Create sensitivity controls if they don't exist\n   */\n  createSensitivityControls() {\n    // Check if sensitivity control already exists\n    let sensitivitySlider = document.getElementById('sensitivitySlider');\n    if (sensitivitySlider) return sensitivitySlider;\n\n    // Create sensitivity controls and add to control panel\n    const controlsDiv = document.querySelector('.controls');\n    if (controlsDiv) {\n      const sensitivityGroup = document.createElement('div');\n      sensitivityGroup.className = 'config-group';\n      sensitivityGroup.innerHTML = `\n        <label for=\"sensitivitySlider\">Detection Sensitivity</label>\n        <div class=\"slider-container\">\n          <input type=\"range\" id=\"sensitivitySlider\" min=\"0.1\" max=\"1.0\" step=\"0.1\" value=\"0.7\">\n          <span id=\"sensitivityValue\">0.7</span>\n        </div>\n        <small>Higher = more sensitive</small>\n      `;\n      controlsDiv.appendChild(sensitivityGroup);\n      return document.getElementById('sensitivitySlider');\n    }\n    return null;\n  }\n\n  /**\n   * Create preset selector if it doesn't exist\n   */\n  createPresetSelect() {\n    // Check if preset select already exists\n    let presetSelect = document.getElementById('presetSelect');\n    if (presetSelect) return presetSelect;\n\n    // Create preset selector in manual config tab\n    const manualTab = document.getElementById('manual-tab');\n    if (manualTab) {\n      const presetGroup = document.createElement('div');\n      presetGroup.className = 'config-group';\n      presetGroup.innerHTML = `\n        <label for=\"presetSelect\">Quick Presets</label>\n        <select id=\"presetSelect\">\n          <option value=\"\">-- Select a preset --</option>\n          <option value=\"D Major 15-note\">D Major 15-note</option>\n          <option value=\"G Minor 13-note\">G Minor 13-note</option>\n          <option value=\"C Pentatonic 11-note\">C Pentatonic 11-note</option>\n        </select>\n      `;\n      manualTab.appendChild(presetGroup);\n      return document.getElementById('presetSelect');\n    }\n    return null;\n  }\n\n  /**\n   * Set up event listeners\n   */\n  setupEventListeners() {\n    // Tab navigation - updated to work with actual HTML\n    this.tabButtons.forEach(button => {\n      button.addEventListener('click', (e) => {\n        const target = e.target;\n        const tabId = target.dataset.tab;\n        if (tabId) {\n          this.switchTab(tabId);\n        }\n      });\n    });\n\n    // Audio controls - handle both detection methods\n    if (this.startButton) {\n      this.startButton.addEventListener('click', () => this.startListening());\n    }\n    if (this.autoDetectButton) {\n      this.autoDetectButton.addEventListener('click', () => this.startListening());\n    }\n    if (this.testMicButton) {\n      this.testMicButton.addEventListener('click', () => this.testMicrophone());\n    }\n\n    // Sensitivity control - only if it exists\n    if (this.sensitivitySlider) {\n      this.sensitivitySlider.addEventListener('input', () => this.updateSensitivity());\n    }\n\n    // Configuration controls\n    if (this.drumSizeSelect) {\n      this.drumSizeSelect.addEventListener('change', () => this.updateConfiguration());\n    }\n    if (this.keySelect) {\n      this.keySelect.addEventListener('change', () => this.updateConfiguration());\n    }\n    if (this.scaleSelect) {\n      this.scaleSelect.addEventListener('change', () => this.updateConfiguration());\n    }\n    if (this.octaveSelect) {\n      this.octaveSelect.addEventListener('change', () => this.updateConfiguration());\n    }\n    if (this.loadPresetButton) {\n      this.loadPresetButton.addEventListener('click', () => this.updateConfiguration());\n    }\n    if (this.presetSelect) {\n      this.presetSelect.addEventListener('change', () => this.loadPreset());\n    }\n\n    // Builder toggles - updated for actual HTML\n    if (this.notationToggle) {\n      this.notationToggle.addEventListener('click', () => this.toggleNotationBuilder());\n    }\n\n    // Window resize handler\n    window.addEventListener('resize', () => {\n      if (this.drumVisualizer) {\n        this.drumVisualizer.resize();\n      }\n    });\n  }\n\n  /**\n   * Initialize main components\n   */\n  initializeComponents() {\n    try {\n      // Initialize drum visualizer - use the existing drum container\n      const drumContainer = document.querySelector('.drum-container');\n      if (drumContainer) {\n        this.drumVisualizer = new DrumVisualizer(drumContainer);\n        this.drumVisualizer.onTongueClicked((tongue) => this.handleTongueClick(tongue));\n      } else {\n        console.warn('Drum container not found, drum visualizer not initialized');\n      }\n\n      // Initialize notation builder - use the existing notation builder\n      const notationContainer = document.getElementById('notationBuilder');\n      if (notationContainer) {\n        this.notationBuilder = new NotationBuilder(notationContainer, this.currentConfig);\n        this.notationBuilder.onSequenceChanged((sequence) => this.handleSequenceChange(sequence));\n        this.notationBuilder.onSequenceExported((sequence) => this.exportSequence(sequence));\n        this.notationBuilder.onBuilderClosed(() => this.toggleNotationBuilder());\n        this.notationBuilder.onTonguePlayback((tongue) => this.playTongue(tongue));\n        this.notationBuilder.setVisible(false);\n      } else {\n        console.warn('Notation builder container not found');\n      }\n\n      // Initialize layout builder - create container if needed or skip for now\n      const layoutContainer = document.getElementById('layoutBuilder');\n      if (layoutContainer) {\n        this.layoutBuilder = new LayoutBuilder(layoutContainer, this.currentConfig);\n        this.layoutBuilder.onLayoutSave((layout) => this.saveCustomLayout(layout));\n        this.layoutBuilder.onBuilderClosed(() => this.toggleLayoutBuilder());\n        this.layoutBuilder.setVisible(false);\n      } else {\n        console.warn('Layout builder container not found - using layout tab instead');\n        // Use the existing layout tab functionality\n        this.setupLayoutTabFunctionality();\n      }\n\n      console.log('🎵 Components initialized successfully!');\n\n    } catch (error) {\n      console.error('Failed to initialize components:', error);\n      this.showStatus('Application partially loaded - some features may be limited', 'warning');\n    }\n  }\n\n  /**\n   * Set up layout tab functionality as fallback\n   */\n  setupLayoutTabFunctionality() {\n    const layoutCanvas = document.getElementById('layoutCanvas');\n    if (layoutCanvas && this.drumVisualizer) {\n      // Add basic drag functionality to the existing layout tab\n      console.log('Setting up basic layout functionality in layout tab');\n    }\n  }\n\n  /**\n   * Switch between tabs\n   */\n  switchTab(tabId) {\n    // Update tab buttons\n    this.tabButtons.forEach(button => {\n      button.classList.toggle('active', button.dataset.tab === tabId);\n    });\n\n    // Update tab panels\n    this.tabPanels.forEach(panel => {\n      panel.classList.toggle('active', panel.id === `${tabId}Tab`);\n    });\n  }\n\n  /**\n   * Start audio listening with EssentiaJS\n   */\n  async startListening() {\n    if (this.isListening || this.audioManager) return;\n\n    try {\n      this.showStatus('Initializing EssentiaJS audio analysis engine...', 'info');\n      this.setProgress(10);\n\n      // Initialize enhanced audio manager with EssentiaJS\n      this.audioManager = new AudioManager({\n        fftSize: 4096,\n        sensitivity: parseFloat(this.sensitivitySlider.value) || 0.7,\n        cooldownTime: 150\n      });\n      \n      this.setProgress(30);\n      \n      // Initialize EssentiaJS (async operation)\n      this.showStatus('Loading EssentiaJS audio analysis engine...', 'info');\n      const essentiaReady = await this.audioManager.initializeEssentia();\n      \n      if (essentiaReady) {\n        this.showStatus('EssentiaJS loaded! Professional-grade pitch detection ready...', 'success');\n      } else {\n        this.showStatus('Using Web Audio API fallback for pitch detection...', 'info');\n      }\n      \n      this.setProgress(40);\n      \n      // Set up note detection callback\n      this.audioManager.onNoteDetected((detection) => this.handleNoteDetection(detection));\n      this.audioManager.onError((error) => this.showStatus(error, 'error'));\n      \n      this.setProgress(60);\n      \n      // Update with current tongue frequencies\n      if (this.drumVisualizer) {\n        const frequencies = this.drumVisualizer.getTongueFrequencies();\n        this.audioManager.updateTongueFrequencies(frequencies);\n      }\n      \n      this.setProgress(70);\n      \n      // Start listening\n      await this.audioManager.startListening();\n      \n      this.setProgress(100);\n      \n      this.isListening = true;\n      this.updateUI();\n      this.showStatus('EssentiaJS audio analysis active - listening for tongue drum notes...', 'success');\n      \n      // Update audio info\n      this.updateAudioInfo();\n      \n      setTimeout(() => this.setProgress(0), 1000);\n\n    } catch (error) {\n      console.error('Failed to start listening:', error);\n      this.showStatus(`Failed to start listening: ${error.message}`, 'error');\n      this.setProgress(0);\n      this.audioManager = null;\n    }\n  }\n\n  /**\n   * Stop audio listening\n   */\n  stopListening() {\n    if (!this.isListening || !this.audioManager) return;\n\n    this.audioManager.stopListening();\n    this.audioManager = null;\n    this.isListening = false;\n    this.updateUI();\n    this.showStatus('Audio analysis stopped', 'info');\n    this.clearDetectionResults();\n  }\n\n  /**\n   * Test microphone access\n   */\n  async testMicrophone() {\n    try {\n      this.showStatus('Testing microphone access...', 'info');\n      \n      const tempAudioManager = new AudioManager();\n      const isWorking = await tempAudioManager.testMicrophone();\n      \n      if (isWorking) {\n        this.showStatus('Microphone test successful! EssentiaJS ready.', 'success');\n      } else {\n        this.showStatus('Microphone test failed', 'error');\n      }\n      \n      tempAudioManager.stopListening();\n    } catch (error) {\n      console.error('Microphone test failed:', error);\n      this.showStatus(`Microphone test failed: ${error.message}`, 'error');\n    }\n  }\n\n  /**\n   * Update sensitivity setting\n   */\n  updateSensitivity() {\n    const sensitivity = parseFloat(this.sensitivitySlider.value);\n    this.sensitivityValue.textContent = sensitivity.toFixed(1);\n    \n    if (this.audioManager) {\n      this.audioManager.setSensitivity(sensitivity);\n    }\n  }\n\n  /**\n   * Update drum configuration\n   */\n  updateConfiguration() {\n    const newConfig = {\n      noteCount: parseInt(this.drumSizeSelect.value),\n      key: this.keySelect.value,\n      scaleType: this.scaleSelect.value,\n      rootOctave: parseInt(this.octaveSelect.value)\n    };\n\n    this.currentConfig = newConfig;\n\n    // Update components\n    if (this.drumVisualizer) {\n      this.drumVisualizer.updateConfiguration(newConfig);\n    }\n    if (this.notationBuilder) {\n      this.notationBuilder.updateConfiguration(newConfig);\n    }\n    if (this.layoutBuilder) {\n      this.layoutBuilder.updateConfiguration(newConfig);\n    }\n\n    // Update audio manager with new frequencies\n    if (this.audioManager && this.drumVisualizer) {\n      const frequencies = this.drumVisualizer.getTongueFrequencies();\n      this.audioManager.updateTongueFrequencies(frequencies);\n    }\n\n    this.updateAudioInfo();\n  }\n\n  /**\n   * Load preset configuration\n   */\n  loadPreset() {\n    const presetName = this.presetSelect.value;\n    if (!presetName) return;\n\n    if (this.drumVisualizer) {\n      const success = this.drumVisualizer.loadPreset(presetName);\n      if (success) {\n        this.showStatus(`Loaded preset: ${presetName}`, 'success');\n        this.updateAudioInfo();\n      } else {\n        this.showStatus(`Failed to load preset: ${presetName}`, 'error');\n      }\n    }\n  }\n\n  /**\n   * Handle note detection from EssentiaJS audio manager\n   */\n  handleNoteDetection(detection) {\n    // Add to history\n    this.detectionHistory.unshift(detection);\n    if (this.detectionHistory.length > 10) {\n      this.detectionHistory = this.detectionHistory.slice(0, 10);\n    }\n\n    // Enhanced visual feedback with confidence\n    if (this.drumVisualizer) {\n      this.drumVisualizer.showDetectionFeedback(detection);\n    }\n\n    // Update detection results display\n    this.updateDetectionResults();\n\n    // Log detection for debugging\n    console.log(`EssentiaJS detected: Tongue ${detection.tongue}, ${detection.frequency.toFixed(1)}Hz, confidence: ${(detection.confidence * 100).toFixed(1)}%`);\n  }\n\n  /**\n   * Handle tongue click from visualizer\n   */\n  handleTongueClick(tongue) {\n    this.playTongue(tongue);\n    \n    // Simulate detection for feedback\n    if (this.drumVisualizer) {\n      this.drumVisualizer.simulateNoteDetection(tongue);\n    }\n  }\n\n  /**\n   * Play a tongue with audio synthesis\n   */\n  playTongue(tongue) {\n    // Enhanced audio synthesis using Web Audio API\n    if (this.drumVisualizer) {\n      const frequency = this.drumVisualizer.getTongueFrequencies()[tongue];\n      if (frequency) {\n        this.synthesizeTongueNote(frequency, 0.5); // 500ms duration\n      }\n      \n      this.drumVisualizer.highlightTongue(tongue, 300);\n    }\n  }\n\n  /**\n   * Synthesize a tongue drum note using Web Audio API\n   */\n  synthesizeTongueNote(frequency, duration) {\n    if (!window.AudioContext && !window.webkitAudioContext) {\n      console.warn('Web Audio API not supported');\n      return;\n    }\n\n    try {\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      \n      // Create oscillator for the fundamental frequency\n      const oscillator = audioContext.createOscillator();\n      const gainNode = audioContext.createGain();\n      \n      // Use a combination of sine waves to simulate tongue drum timbre\n      oscillator.type = 'sine';\n      oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);\n      \n      // Create envelope (attack-decay-sustain-release)\n      const now = audioContext.currentTime;\n      gainNode.gain.setValueAtTime(0, now);\n      gainNode.gain.linearRampToValueAtTime(0.3, now + 0.01); // Attack\n      gainNode.gain.exponentialRampToValueAtTime(0.1, now + 0.1); // Decay\n      gainNode.gain.exponentialRampToValueAtTime(0.05, now + duration * 0.7); // Sustain\n      gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration); // Release\n      \n      // Connect audio graph\n      oscillator.connect(gainNode);\n      gainNode.connect(audioContext.destination);\n      \n      // Start and stop\n      oscillator.start(now);\n      oscillator.stop(now + duration);\n      \n    } catch (error) {\n      console.warn('Failed to synthesize note:', error);\n    }\n  }\n\n  /**\n   * Handle sequence changes from notation builder\n   */\n  handleSequenceChange(sequence) {\n    console.log('Sequence updated:', sequence);\n  }\n\n  /**\n   * Export sequence data with enhanced metadata\n   */\n  exportSequence(sequence) {\n    const notation = this.notationBuilder?.sequenceToNotation() || [];\n    const data = {\n      drumConfig: this.currentConfig,\n      sequence: sequence,\n      notation: notation,\n      tongueFrequencies: this.drumVisualizer?.getTongueFrequencies() || {},\n      timestamp: new Date().toISOString(),\n      version: '2.0-EssentiaJS'\n    };\n\n    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    \n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `tongue-drum-sequence-${Date.now()}.json`;\n    a.click();\n    \n    URL.revokeObjectURL(url);\n    this.showStatus('Sequence exported successfully!', 'success');\n  }\n\n  /**\n   * Save custom layout\n   */\n  saveCustomLayout(layout) {\n    // Save to drum visualizer's config manager\n    if (this.drumVisualizer && this.drumVisualizer.configManager) {\n      this.drumVisualizer.configManager.saveCustomLayout(layout);\n    }\n    \n    // Add to preset selector if not already there\n    let optionExists = false;\n    for (const option of this.presetSelect.options) {\n      if (option.value === layout.name) {\n        optionExists = true;\n        break;\n      }\n    }\n    \n    if (!optionExists) {\n      const option = document.createElement('option');\n      option.value = layout.name;\n      option.textContent = layout.name;\n      this.presetSelect.appendChild(option);\n    }\n    \n    this.showStatus(`Layout \"${layout.name}\" saved!`, 'success');\n  }\n\n  /**\n   * Toggle notation builder visibility\n   */\n  toggleNotationBuilder() {\n    if (!this.notationBuilder) return;\n    \n    const container = document.getElementById('notationBuilder');\n    const isVisible = container.style.display !== 'none';\n    \n    this.notationBuilder.setVisible(!isVisible);\n    this.notationToggle.textContent = isVisible ? '🎵 Show Notation Builder' : '🎵 Hide Notation Builder';\n  }\n\n  /**\n   * Toggle layout builder visibility\n   */\n  toggleLayoutBuilder() {\n    if (!this.layoutBuilder) return;\n    \n    const container = document.getElementById('layoutBuilder');\n    const isVisible = container.style.display !== 'none';\n    \n    this.layoutBuilder.setVisible(!isVisible);\n    this.layoutToggle.textContent = isVisible ? '🎯 Show Layout Builder' : '🎯 Hide Layout Builder';\n  }\n\n  /**\n   * Update UI state\n   */\n  updateUI() {\n    // Update button states - handle missing elements\n    if (this.startButton) {\n      this.startButton.style.display = this.isListening ? 'none' : 'inline-block';\n      this.startButton.textContent = this.isListening ? 'Stop Detection' : 'Start Detection';\n    }\n    \n    if (this.autoDetectButton) {\n      this.autoDetectButton.textContent = this.isListening ? 'Stop Detection' : 'Start Detection';\n    }\n    \n    // Handle stop button if it exists (but it doesn't in our HTML)\n    if (this.stopButton) {\n      this.stopButton.style.display = this.isListening ? 'inline-block' : 'none';\n    }\n    \n    // Update configuration controls - with null checks\n    if (this.drumSizeSelect) this.drumSizeSelect.disabled = this.isListening;\n    if (this.keySelect) this.keySelect.disabled = this.isListening;\n    if (this.scaleSelect) this.scaleSelect.disabled = this.isListening;\n    if (this.octaveSelect) this.octaveSelect.disabled = this.isListening;\n  }\n\n  /**\n   * Update audio information display\n   */\n  updateAudioInfo() {\n    if (this.drumVisualizer) {\n      const drumInfo = this.drumVisualizer.getDrumInfo();\n      const contextState = this.audioManager ? this.audioManager.getAudioContextState() : 'closed';\n      const sampleRate = this.audioManager ? this.audioManager.getSampleRate() : 'N/A';\n      \n      this.audioInfo.innerHTML = `\n        <div class=\"audio-stat\">\n          <span class=\"stat-label\">Configuration:</span>\n          <span class=\"stat-value\">${drumInfo}</span>\n        </div>\n        <div class=\"audio-stat\">\n          <span class=\"stat-label\">Status:</span>\n          <span class=\"stat-value\">${this.isListening ? 'EssentiaJS Active' : 'Stopped'}</span>\n        </div>\n        <div class=\"audio-stat\">\n          <span class=\"stat-label\">Sample Rate:</span>\n          <span class=\"stat-value\">${sampleRate} Hz</span>\n        </div>\n        <div class=\"audio-stat\">\n          <span class=\"stat-label\">Audio Context:</span>\n          <span class=\"stat-value\">${contextState}</span>\n        </div>\n      `;\n    }\n  }\n\n  /**\n   * Update detection results display with enhanced information\n   */\n  updateDetectionResults() {\n    if (this.detectionHistory.length === 0) {\n      this.detectionResults.innerHTML = '<div class=\"no-results\">No notes detected yet... (EssentiaJS ready)</div>';\n      return;\n    }\n\n    const resultsHTML = this.detectionHistory.map(detection => `\n      <div class=\"detection-result\">\n        <span class=\"tongue-number\">Tongue ${detection.tongue}</span>\n        <span class=\"confidence ${detection.confidence > 0.8 ? 'high-confidence' : detection.confidence > 0.5 ? 'medium-confidence' : 'low-confidence'}\">\n          ${(detection.confidence * 100).toFixed(1)}%\n        </span>\n        <span class=\"frequency\">${detection.frequency.toFixed(1)} Hz</span>\n        ${detection.targetFrequency ? `<span class=\"target-freq\">(target: ${detection.targetFrequency.toFixed(1)}Hz)</span>` : ''}\n      </div>\n    `).join('');\n\n    this.detectionResults.innerHTML = resultsHTML;\n  }\n\n  /**\n   * Clear detection results\n   */\n  clearDetectionResults() {\n    this.detectionHistory = [];\n    this.updateDetectionResults();\n  }\n\n  /**\n   * Show status message\n   */\n  showStatus(message, type = 'info') {\n    this.statusMessage.textContent = message;\n    this.statusMessage.className = `status-message ${type}`;\n    \n    // Auto-hide after 5 seconds for non-error messages\n    if (type !== 'error') {\n      setTimeout(() => {\n        this.statusMessage.textContent = '';\n        this.statusMessage.className = 'status-message';\n      }, 5000);\n    }\n  }\n\n  /**\n   * Set progress bar value\n   */\n  setProgress(percent) {\n    this.progressBar.style.width = `${percent}%`;\n    this.progressBar.style.display = percent > 0 ? 'block' : 'none';\n  }\n}\n\n// Initialize the application when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  try {\n    new TongueDrumApp();\n    console.log('🎵 Tongue Drum Chum app initialized successfully with EssentiaJS! 🎵');\n  } catch (error) {\n    console.error('Failed to initialize Tongue Drum Chum app:', error);\n    \n    // Show error message to user\n    const statusElement = document.getElementById('statusMessage');\n    if (statusElement) {\n      statusElement.textContent = `Failed to initialize app: ${error.message}`;\n      statusElement.className = 'status-message error';\n    }\n  }\n});\n"],"names":["__awaiter","thisArg","_arguments","P","generator","resolve","reject","fulfilled","value","step","e","rejected","result","__generator","body","_","t","f","y","g","verb","n","v","op","Essentia","EssentiaWASM","isDebug","audioURL","webAudioCtx","response","arrayBuffer","audioBuffer","_a","channel","buffer","left","right","monoSignal","inputArray","inputVector","inputAudioData","frameSize","hopSize","leftSignal","rightSignal","sampleRate","startAtZero","pitch","signal","bandwidth","cutoffFrequency","order","onsets","type","veconsets","i","array","frequencyDomainCompression","generalized","normalization","spectrum","dctType","highFrequencyBound","inputSize","liftering","logType","lowFrequencyBound","normalize","numberBands","numberCoefficients","weighting","x","xPoints","yPoints","vecxPoints","vecyPoints","maxTempo","minTempo","loudness","loudnessBandRatio","size","beatDuration","beatWindowDuration","beats","frequencyBands","vecbeats","vecfrequencyBands","array1","array2","bpmIntervals","longRegionsPruningTime","shortRegionsMergingTime","tolerance","mode","range","chords","key","scale","pcp","windowSize","ticks","chromaPick","queryFeature","referenceFeature","binarizePercentile","frameStackSize","frameStackStride","noti","oti","otiBinary","streaming","frame","binsPerOctave","minFrequency","minimumKernelSize","normalizeType","numberBins","threshold","windowType","zeroPhase","detectionThreshold","powerEstimationThreshold","silenceThreshold","max","min","alignmentType","disExtension","disOnset","distanceType","arrayX","arrayY","maxLag","minLag","binarize","leftBoundaryFlag","leftBoundaryValue","rightBoundaryFlag","rightBoundaryValue","outputSize","maxTau","minTau","tauMultiplier","envelope","energyThreshold","kernelSize","subFrameSize","frequencies","magnitudes","centralMoments","width","thresholdRatio","startCutoffFrequency","stopCutoffFrequency","startFrequency","stopFrequency","applyRectification","attackTime","releaseTime","halfRectify","norm","lastFrameToEndOfFile","startFromZero","validFrameThresholdRatio","maximumTime","minimumTime","postpowerTime","prepowerThreshold","prepowerTime","bandPreset","bandSplitFrequency","harmonics","maxFrequency","maxShifted","nonLinear","normalized","referenceFrequency","weightType","bpms","bpm","maxHarmonics","hpcp","maxPeaks","maxValue","minValue","fftSize","freqDevOffset","freqDevSlope","harmDevSlope","magnitudeThreshold","maxnSines","nHarmonics","orderBy","stocf","dct","denominator","numerator","vecdenominator","vecnumerator","numHarmonics","pcpSize","profileType","slope","useMajMin","usePolyphony","useThreeChords","audio","averageDetuningCorrection","hpcpSize","maximumSpectralPeaks","pcpThreshold","spectralPeaksThreshold","tuningFrequency","power","startAttackThreshold","stopAttackThreshold","binsPerSemitone","rollOn","bpmEstimate","confidenceThreshold","warpingFormula","causal","log","beatogram","binResolution","harmonicWeight","magnitudeCompression","numberHarmonics","filterIterations","guessUnvoiced","minDuration","peakDistributionThreshold","peakFrameThreshold","pitchContinuity","timeContinuity","numberRealInputs","numberVectorRealInputs","logSpectrogram","meanTuning","localTuning","chromaNormalization","spectralShape","spectralWhitening","tuningMode","useNNLS","fixSeed","level","alpha","frameRate","weightCurve","weightCurveType","vecweightCurve","novelty","maxBpm","minBpm","phase","method","gain","interpolate","maxPosition","minPeakDistance","minPosition","frameSizeOSS","hopSizeOSS","maxBPM","minBPM","oss","positions","pitchDistanceThreshold","rmsThreshold","peakBins","peakSaliences","contoursBins","contoursSaliences","contoursStartTimes","duration","voiceVibrato","voicingTolerance","pitchConfidence","minChunkSize","useAbsolutePitchConfidence","highBoundary","lowBoundary","salienceFunction","lowRMSThreshold","outputUnvoiced","preciseTime","lowAmp","pitchCandidates","probabilities","numberBinsPerSemitone","selfTransition","yinTrust","inputSampleRate","outputSampleRate","quality","input","inSize","outSize","frameHop","lastBeatInterval","numberFrames","tempoHints","useBands","useOnset","vectempoHints","melBands","cutoff","MAAlpha","MMSEAlpha","NoiseAlpha","noiseThreshold","useBroadbadNoiseCorrection","differentialThreshold","minimumDuration","clipping","factor","maxAbsValue","phases","beat","onsetStart","endTimes","startTimes","timeUnits","vecendTimes","vecstartTimes","neighbourRatio","staticDistribution","bands","centBinResolution","minimumFrequency","beta1","beta2","res","stocenv","maximumStartTime","maximumStopTime","combine","ratioThreshold","binWidth","frameWidth","pre_avg","pre_max","bandsGain","frameTime","vecbandsGain","featuresFrame","onsetDetections","resample","sampleRateODF","tickCandidates","periods","maxTonicFrequency","minTonicFrequency","numberSaliencePeaks","checkRange","endTime","startTime","blockDC","emphasise","oversamplingFactor","version","resolution","shift","maxExtend","minExtend","averagingFrames","scaling","zeroPadding","AudioManager","options","error","callback","sensitivity","event","inputData","framesToCopy","now","windowedSignal","pitchYin","pitchYinFFT","fftError","spectralPeaks","finalPitch","bufferLength","dataArray","maxIndex","frequency","pitchMelodia","pitches","dominantFreq","a","b","midIndex","currentTime","detection","bestMatch","smallestDifference","tongueStr","tongueFreq","tongue","difference","percentDifference","fundamental","secondHarmonic","thirdHarmonic","peakFreq","secondDiff","thirdDiff","track","testStream","SCALE_PATTERNS","NOTE_TO_SEMITONE","DRUM_PRESETS","DrumConfigManager","config","newConfig","tongueNumber","baseFrequency","pattern","scaleIndex","octaveOffset","semitoneOffset","note","octave","semitonesFromA4","angle","presetName","preset","layout","name","presets","scaleDisplayName","rootSemitone","noteSemitone","noteOctave","semitoneFromA4","closestFrequency","centsOff","noteIndex","noteName","sequence","prevTongue","currTongue","prevFreq","currFreq","customData","layouts","data","DrumVisualizer","container","drumRect","drumWidth","drumHeight","canvasWidth","canvasHeight","scaleX","scaleY","index","totalCount","radius","customLayout","confidenceBar","analysis","display","state","NotationBuilder","drumConfig","tongueDiv","target","btn","activeBtn","noteDiv","octaveMarker","sequenceNotes","visible","notation","length","octaves","tongueUsage","octaveUsage","totalTongues","LayoutBuilder","canvasRect","centerX","centerY","centerDiv","pos","touch","element","clientX","clientY","elementRect","tongueWidth","tongueHeight","layoutName","cols","spacing","row","col","radiusSpiral","spiralGrowth","spacing_line","layoutData","blob","url","xs","p","ys","TongueDrumApp","el","sensitivitySlider","controlsDiv","sensitivityGroup","presetSelect","manualTab","presetGroup","button","tabId","drumContainer","notationContainer","layoutContainer","panel","tempAudioManager","audioContext","oscillator","gainNode","_b","optionExists","option","isVisible","drumInfo","contextState","resultsHTML","message","percent","statusElement"],"mappings":"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","x_google_ignoreList":[0]}